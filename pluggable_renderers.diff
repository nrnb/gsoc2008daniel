Index: application/src/main/java/cytoscape/TrivialRenderer.java
===================================================================
--- application/src/main/java/cytoscape/TrivialRenderer.java	(.../trunk)	(revision 0)
+++ application/src/main/java/cytoscape/TrivialRenderer.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -0,0 +1,56 @@
+package cytoscape;
+
+//import cytoscape.render.immed.GraphGraphics;
+import java.awt.*;
+import java.awt.geom.*;
+import java.util.Collection;
+import java.util.HashSet;
+
+import org.cytoscape.view.NodeView;
+import org.cytoscape.view.VisualProperty;
+import org.cytoscape.view.renderers.NodeRenderer;
+
+import cytoscape.render.stateful.NodeDetails;
+
+public class TrivialRenderer implements NodeRenderer {
+	private final Ellipse2D.Double m_ellp2d = new Ellipse2D.Double();
+	private String name;
+	
+	public TrivialRenderer(String name){
+		this.name = name;
+	}
+	/**
+	 * Draw a preview image on canvas at given place (using some default NodeDetails that the renderer can make up)
+	 */
+	public void generatePreview(Graphics2D graphics, float[] position){
+		// TODO
+	}
+	
+	/**
+	 * Return a list of visual attributes this renderer can use
+	 */
+	public Collection<VisualProperty>  supportedVisualAttributes(){
+		return new HashSet<VisualProperty>(); // no VisualPropeties defined by this Renderer
+	}
+
+	public void render(Graphics2D m_g2d, NodeDetails nodeDetails, float[] floatBuff1, int node, NodeView nodeView) {
+		System.out.println("rendering by: "+name);
+		
+		// TODO Auto-generated method stub
+		float xMin = floatBuff1[0]; 
+		float yMin =  floatBuff1[1];
+		float xMax = floatBuff1[2];
+		float yMax = floatBuff1[3];
+		
+		Paint fillPaint; 
+		if (nodeView.isSelected()) {
+			fillPaint = Color.cyan;
+		} else {
+			fillPaint = Color.darkGray;
+		}
+
+		m_g2d.setPaint(fillPaint);
+		m_ellp2d.setFrame(xMin, yMin, xMax - xMin, yMax - yMin);
+		m_g2d.fill(m_ellp2d);
+	}
+}

Property changes on: application/src/main/java/cytoscape/TrivialRenderer.java
___________________________________________________________________
Added: svn:mergeinfo

Index: application/src/main/java/cytoscape/dialogs/ExportAsGraphicsFileChooser.java
===================================================================
--- application/src/main/java/cytoscape/dialogs/ExportAsGraphicsFileChooser.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/dialogs/ExportAsGraphicsFileChooser.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -89,7 +89,9 @@
 	private boolean useTransparency(){
 
 		VisualStyle vs = Cytoscape.getVisualMappingManager().getVisualStyle();
-		
+		// FIXME FIXME FIXME
+		return true;
+		/*
 		// Check opacity in default setting
 		Properties node_default_props = vs.getNodeAppearanceCalculator().getDefaultAppearance().getDefaultProperties("");
 		Properties edge_default_props = vs.getEdgeAppearanceCalculator().getDefaultAppearance().getDefaultProperties("");
@@ -97,6 +99,7 @@
 		Enumeration nodePropNames = node_default_props.propertyNames();
 		Enumeration edgePropNames = edge_default_props.propertyNames();
 		
+		
 		while (nodePropNames.hasMoreElements()) {
 			String tmp = (String) nodePropNames.nextElement();
 			if (tmp.contains("Opacity")) {
@@ -114,30 +117,20 @@
 				}
 			}
 		}
-
-		//Check opacity in calculators
-		List<Calculator> node_calculators = vs.getNodeAppearanceCalculator().getCalculators();
-		for (Calculator cal: node_calculators) {
-			if (cal.getVisualPropertyType() == org.cytoscape.vizmap.VisualPropertyType.NODE_OPACITY || 
-			cal.getVisualPropertyType() == org.cytoscape.vizmap.VisualPropertyType.NODE_BORDER_OPACITY ||
-			(cal.getVisualPropertyType() == org.cytoscape.vizmap.VisualPropertyType.NODE_LABEL_OPACITY))
-			{
-				return true;
-			}
-		}
 		
-		List<Calculator> edge_calculators = vs.getEdgeAppearanceCalculator().getCalculators();
+		List<Calculator> edge_calculators = vs.getEdgeCalculators();
 		for (Calculator cal: edge_calculators) {
-			if (cal.getVisualPropertyType()== org.cytoscape.vizmap.VisualPropertyType.EDGE_OPACITY ||
-					cal.getVisualPropertyType()== org.cytoscape.vizmap.VisualPropertyType.EDGE_LABEL_OPACITY ||
-					cal.getVisualPropertyType()== org.cytoscape.vizmap.VisualPropertyType.EDGE_TGTARROW_OPACITY ||
-					cal.getVisualPropertyType()== org.cytoscape.vizmap.VisualPropertyType.EDGE_SRCARROW_OPACITY
+			if (cal.getVisualProperty().getName().equals("EDGE_OPACITY")||
+					cal.getVisualProperty().getName().equals("EDGE_LABEL_OPACITY") ||
+					cal.getVisualProperty().getName().equals("EDGE_TGTARROW_OPACITY") ||
+					cal.getVisualProperty().getName().equals("EDGE_SRCARROW_OPACITY")
 			) {
 				return true;
 			}
 		}
 		
 		return false;
+		*/
 	}
 
 	public CyFileFilter getSelectedFormat()
Index: application/src/main/java/cytoscape/CytoscapeInit.java
===================================================================
--- application/src/main/java/cytoscape/CytoscapeInit.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/CytoscapeInit.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -140,6 +140,7 @@
 		long begintime = System.currentTimeMillis();
 
 		try {
+			Cytoscape.defineHardcodedVisualProperties();
 			initParams = params;
 
 			// setup properties
Index: application/src/main/java/cytoscape/visual/ui/DefaultViewPanel.java
===================================================================
--- application/src/main/java/cytoscape/visual/ui/DefaultViewPanel.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/visual/ui/DefaultViewPanel.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -104,8 +104,7 @@
 		
 		oldView = Cytoscape.getVisualMappingManager().getNetworkView();
 
-		background = Cytoscape.getVisualMappingManager().getVisualStyle()
-		                      .getGlobalAppearanceCalculator().getDefaultBackgroundColor();
+		background = (Color) Cytoscape.getVisualMappingManager().getVisualStyle().getGlobalProperty("backgroundColor");
 		this.setBackground(background);
 	}
 
@@ -155,7 +154,7 @@
 			this.add(canvas);
 
 			canvas.setLocation(PADDING / 2, PADDING / 2);
-			Cytoscape.getVisualMappingManager().applyAppearances();
+			Cytoscape.getVisualMappingManager().getVisualStyle().apply(view);
 
 			if ((background != null) && (canvas != null)) {
 				canvas.setBackground(background);
Index: application/src/main/java/cytoscape/visual/ui/VizMapperMainPanel.java
===================================================================
--- application/src/main/java/cytoscape/visual/ui/VizMapperMainPanel.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/visual/ui/VizMapperMainPanel.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -56,22 +56,17 @@
 
 import cytoscape.util.swing.DropDownMenuButton;
 
+import org.cytoscape.view.DiscreteValue;
 import org.cytoscape.view.GraphView;
+import org.cytoscape.view.VisualPropertyCatalog;
+
 import cytoscape.view.CytoscapeDesktop;
 import cytoscape.view.NetworkPanel;
+import org.cytoscape.view.VisualProperty;
 
-import org.cytoscape.vizmap.ArrowShape;
 import org.cytoscape.vizmap.CalculatorCatalog;
-import org.cytoscape.vizmap.EdgeAppearanceCalculator;
-import org.cytoscape.vizmap.LineStyle;
-import org.cytoscape.vizmap.NodeAppearanceCalculator;
-import org.cytoscape.vizmap.NodeShape;
+import org.cytoscape.vizmap.LabelPosition;
 import org.cytoscape.vizmap.VisualMappingManager;
-import org.cytoscape.vizmap.VisualPropertyType;
-import static org.cytoscape.vizmap.VisualPropertyType.NODE_FONT_SIZE;
-import static org.cytoscape.vizmap.VisualPropertyType.NODE_HEIGHT;
-import static org.cytoscape.vizmap.VisualPropertyType.NODE_LABEL_POSITION;
-import static org.cytoscape.vizmap.VisualPropertyType.NODE_WIDTH;
 
 import org.cytoscape.vizmap.VisualStyle;
 
@@ -94,10 +89,8 @@
 import cytoscape.visual.ui.editors.discrete.FontCellRenderer;
 import cytoscape.visual.ui.editors.discrete.LabelPositionCellRenderer;
 import cytoscape.visual.ui.editors.discrete.ShapeCellRenderer;
-import org.cytoscape.vizmap.icon.ArrowIcon;
-import org.cytoscape.vizmap.icon.NodeIcon;
-import org.cytoscape.vizmap.icon.VisualPropertyIcon;
 
+
 import java.awt.BorderLayout;
 import java.awt.Color;
 import java.awt.Component;
@@ -240,11 +233,10 @@
 	private final Map<String, Map<Object, Object>> discMapBuffer = new HashMap<String, Map<Object, Object>>();
 	private String lastVSName = null;
 	private JScrollPane noMapListScrollPane;
-	private List<VisualPropertyType> noMapping;
 	private JPanel buttonPanel;
 	private JButton addButton;
 	private JPanel bottomPanel;
-	private Map<VisualPropertyType, JDialog> editorWindowManager = new HashMap<VisualPropertyType, JDialog>();
+	private Map<VisualProperty, JDialog> editorWindowManager = new HashMap<VisualProperty, JDialog>();
 	private Map<String, Image> defaultImageManager = new HashMap<String, Image>();
 
 	
@@ -296,11 +288,7 @@
 		colorCellEditor.addPropertyChangeListener(this);
 		fontCellEditor.addPropertyChangeListener(this);
 		numberCellEditor.addPropertyChangeListener(this);
-		shapeCellEditor.addPropertyChangeListener(this);
 		stringCellEditor.addPropertyChangeListener(this);
-		lineCellEditor.addPropertyChangeListener(this);
-		arrowCellEditor.addPropertyChangeListener(this);
-
 		labelPositionEditor.addPropertyChangeListener(this);
 	}
 
@@ -329,13 +317,13 @@
 			boolean isNodeSizeExist = false;
 
 			for (Property prop : props) {
-				if (prop.getDisplayName().equals(VisualPropertyType.NODE_SIZE.getName()))
+				if (prop.getDisplayName().equals("NODE_SIZE"))
 					isNodeSizeExist = true;
 
-				if (prop.getDisplayName().equals(VisualPropertyType.NODE_HEIGHT.getName())) {
+				if (prop.getDisplayName().equals("NODE_HEIGHT")) {
 					nodeHeight = (VizMapperProperty) prop;
 					visualPropertySheetPanel.removeProperty(prop);
-				} else if (prop.getDisplayName().equals(VisualPropertyType.NODE_WIDTH.getName())) {
+				} else if (prop.getDisplayName().equals("NODE_WIDTH")) {
 					nodeWidth = (VizMapperProperty) prop;
 					visualPropertySheetPanel.removeProperty(prop);
 				}
@@ -349,15 +337,15 @@
 			boolean isNodeHExist = false;
 
 			for (Property prop : props) {
-				if (prop.getDisplayName().equals(VisualPropertyType.NODE_SIZE.getName())) {
+				if (prop.getDisplayName().equals("NODE_SIZE")) {
 					nodeSize = (VizMapperProperty) prop;
 					visualPropertySheetPanel.removeProperty(prop);
 				}
 
-				if (prop.getDisplayName().equals(VisualPropertyType.NODE_WIDTH.getName()))
+				if (prop.getDisplayName().equals("NODE_WIDTH"))
 					isNodeWExist = true;
 
-				if (prop.getDisplayName().equals(VisualPropertyType.NODE_HEIGHT.getName()))
+				if (prop.getDisplayName().equals("NODE_HEIGHT"))
 					isNodeHExist = true;
 			}
 
@@ -429,6 +417,7 @@
 		lockSize.setSelected(true);
 		lockSize.addActionListener(new ActionListener() {
 				public void actionPerformed(ActionEvent e) {
+					/* FIXME
 					if (lockSize.isSelected()) {
 						vmm.getVisualStyle().getNodeAppearanceCalculator().setNodeSizeLocked(true);
 						switchNodeSizeLock(true);
@@ -436,7 +425,7 @@
 						vmm.getVisualStyle().getNodeAppearanceCalculator().setNodeSizeLocked(false);
 						switchNodeSizeLock(false);
 					}
-
+					 */
 					Cytoscape.redrawGraph(Cytoscape.getCurrentNetworkView());
 				}
 			});
@@ -514,12 +503,13 @@
 		menu.addPopupMenuListener(this);
 	}
 
-	public static void apply(Object newValue, VisualPropertyType type) {
-		if (newValue != null)
-			type.setDefault(Cytoscape.getVisualMappingManager().getVisualStyle(), newValue);
+	public static void apply(Object newValue, VisualProperty type) {
+		if (newValue != null){
+			Cytoscape.getVisualMappingManager().getVisualStyle().setDefaultValue(type, newValue);
+		}
 	}
 
-	public static Object showValueSelectDialog(VisualPropertyType type, Component caller)
+	public static Object showValueSelectDialog(VisualProperty type, Component caller)
 	    throws Exception {
 		return EditorFactory.showDiscreteEditor(type);
 	}
@@ -728,19 +718,7 @@
 	// For colors
 	private CyColorCellRenderer collorCellRenderer = new CyColorCellRenderer();
 	private CyColorPropertyEditor colorCellEditor = new CyColorPropertyEditor();
-
-	// For shapes
-	private ShapeCellRenderer shapeCellRenderer = new ShapeCellRenderer(VisualPropertyType.NODE_SHAPE);
-	private CyComboBoxPropertyEditor shapeCellEditor = new CyComboBoxPropertyEditor();
-
-	// For Lines
-	private ShapeCellRenderer lineCellRenderer = new ShapeCellRenderer(VisualPropertyType.EDGE_LINE_STYLE);
-	private CyComboBoxPropertyEditor lineCellEditor = new CyComboBoxPropertyEditor();
-
-	// For Arrow shapes
-	private CyComboBoxPropertyEditor arrowCellEditor = new CyComboBoxPropertyEditor();
-	private ShapeCellRenderer arrowShapeCellRenderer = new ShapeCellRenderer(VisualPropertyType.EDGE_TGTARROW_SHAPE);
-
+	
 	// For sizes
 	private CyDoublePropertyEditor numberCellEditor = new CyDoublePropertyEditor();
 
@@ -768,9 +746,6 @@
 
 	// For mapping types.
 	private CyComboBoxPropertyEditor mappingTypeEditor = new CyComboBoxPropertyEditor();
-	private static final Map<Object, Icon> nodeShapeIcons = NodeShape.getIconSet();
-	private static final Map<Object, Icon> arrowShapeIcons = ArrowShape.getIconSet();
-	private static final Map<Object, Icon> lineTypeIcons = LineStyle.getIconSet();
 	private PropertyRendererRegistry rendReg = new PropertyRendererRegistry();
 	private PropertyEditorRegistry editorReg = new PropertyEditorRegistry();
 
@@ -792,13 +767,14 @@
 	}
 
 	private void switchVS(String vsName, boolean redraw) {
+		System.out.println("switching to:"+vsName);
 		if (ignore)
 			return;
 
 		// If new VS name is the same, ignore.
 		if (lastVSName == vsName)
 			return;
-
+		System.out.println("  switching to:"+vsName);
 		closeEditorWindow();
 
 		System.out.println("VS Switched --> " + vsName + ", Last = " + lastVSName);
@@ -809,6 +785,7 @@
 		vmm.setVisualStyle(vsName);
 
 		if (propertyMap.containsKey(vsName)) {
+			System.out.println("  vs in propertyMap");
 			final List<Property> props = propertyMap.get(vsName);
 			final Map<String, Property> unused = new TreeMap<String, Property>();
 
@@ -839,8 +816,10 @@
 			for (Object key : keys) {
 				visualPropertySheetPanel.addProperty(unused.get(key));
 			}
-		} else
+		} else{
+			System.out.println("  vs not in propertyMap");
 			setPropertyTable();
+		}
 
 		// MLC 03/31/08:
 		//lastVSName = vsName;
@@ -856,7 +835,7 @@
 		Image defImg = defaultImageManager.get(vsName);
 
 		if(defImg == null) {
-			// Default image is not available in the buffer.  Create a new one.
+			System.out.println("  Default image is not available in the buffer.  Create a new one.");
 			updateDefaultImage(vsName,
 									(GraphView) ((DefaultViewPanel) DefaultAppearenceBuilder.getDefaultView(vsName)).getView(),
 									defaultAppearencePanel.getSize());
@@ -866,8 +845,7 @@
 		setDefaultPanel(defImg);
 
 		// Sync. lock state
-		final boolean lockState = vmm.getVisualStyle().getNodeAppearanceCalculator()
-		                             .getNodeSizeLocked();
+		final boolean lockState = false; //FIXME: vmm.getVisualStyle().getNodeAppearanceCalculator().getNodeSizeLocked();
 		lockSize.setSelected(lockState);
 		switchNodeSizeLock(lockState);
 		
@@ -876,6 +854,7 @@
 		// Cleanup desktop.
 		Cytoscape.getDesktop().repaint();
 		vsNameComboBox.setSelectedItem(vsName);
+		System.out.println("  vs switching done");
 	}
 
 	private static final String CATEGORY_UNUSED = "Unused Properties";
@@ -912,9 +891,16 @@
 			// Deceptively, getDefaultView actually actually calls VisualMappingManager.setVisualStyle()
 			// so each time we add a combobox item, the visual style is changing.
 			// Make sure to set the lastVSName as we change the visual style:
+			view = null;
+			try{
+			System.out.println("visual style name: "+name);
 			defPanel = DefaultAppearenceBuilder.getDefaultView(name);
 			view = (GraphView) ((DefaultViewPanel) defPanel).getView();
-
+			} catch(Exception e){
+				e.printStackTrace();
+			} catch(Error e){
+				e.printStackTrace();
+			}
 			if (view != null) {
 				System.out.println("Creating Default Image for " + name);
 				updateDefaultImage(name, view, panelSize);
@@ -1069,71 +1055,6 @@
 		                                  .getMappingNames();
 
 		mappingTypeEditor.setAvailableValues(mappingTypes.toArray());
-
-		VisualPropertyIcon newIcon;
-
-		List<Icon> iconList = new ArrayList<Icon>();
-		final List<NodeShape> nodeShapes = new ArrayList<NodeShape>();
-
-		for (Object key : nodeShapeIcons.keySet()) {
-			NodeShape shape = (NodeShape) key;
-
-			if (shape.isSupported()) {
-				iconList.add(nodeShapeIcons.get(key));
-				nodeShapes.add(shape);
-			}
-		}
-
-		Icon[] iconArray = new Icon[iconList.size()];
-		String[] shapeNames = new String[iconList.size()];
-
-		for (int i = 0; i < iconArray.length; i++) {
-			newIcon = ((NodeIcon) iconList.get(i)).clone();
-			newIcon.setIconHeight(16);
-			newIcon.setIconWidth(16);
-			iconArray[i] = newIcon;
-			shapeNames[i] = nodeShapes.get(i).getShapeName();
-		}
-
-		shapeCellEditor.setAvailableValues(nodeShapes.toArray());
-		shapeCellEditor.setAvailableIcons(iconArray);
-
-		iconList.clear();
-		iconList.addAll(arrowShapeIcons.values());
-		iconArray = new Icon[iconList.size()];
-
-		String[] arrowNames = new String[iconList.size()];
-		Set arrowShapes = arrowShapeIcons.keySet();
-
-		for (int i = 0; i < iconArray.length; i++) {
-			newIcon = ((ArrowIcon) iconList.get(i));
-			newIcon.setIconHeight(16);
-			newIcon.setIconWidth(40);
-			newIcon.setBottomPadding(-9);
-			iconArray[i] = newIcon;
-			arrowNames[i] = newIcon.getName();
-		}
-
-		arrowCellEditor.setAvailableValues(arrowShapes.toArray());
-		arrowCellEditor.setAvailableIcons(iconArray);
-
-		iconList = new ArrayList();
-		iconList.addAll(lineTypeIcons.values());
-		iconArray = new Icon[iconList.size()];
-		shapeNames = new String[iconList.size()];
-
-		Set lineTypes = lineTypeIcons.keySet();
-
-		for (int i = 0; i < iconArray.length; i++) {
-			newIcon = (VisualPropertyIcon) (iconList.get(i));
-			newIcon.setIconHeight(16);
-			newIcon.setIconWidth(16);
-			iconArray[i] = newIcon;
-			shapeNames[i] = newIcon.getName();
-		}
-
-		lineCellEditor.setAvailableValues(lineTypes.toArray());
-		lineCellEditor.setAvailableIcons(iconArray);
 	}
 
 	private void updateTableView() {
@@ -1149,7 +1070,7 @@
 
 			if ((shownProp != null) && (shownProp.getParentProperty() != null)
 			    && shownProp.getParentProperty().getDisplayName()
-			                .equals(NODE_LABEL_POSITION.getName())) {
+			                .equals("NODE_LABEL_POSITION")) {
 				// This is label position cell. Need laeger cell.
 				table.setRowHeight(i, 50);
 			} else if ((shownProp != null) && shownProp.getDisplayName().equals(GRAPHICAL_MAP_VIEW)) {
@@ -1157,23 +1078,18 @@
 				final Property parent = shownProp.getParentProperty();
 				final Object type = ((VizMapperProperty) parent).getHiddenObject();
 
-				if (type instanceof VisualPropertyType) {
+				if (type instanceof VisualProperty) {
 					ObjectMapping mapping;
+					VisualProperty vp = (VisualProperty) type;
 
-					if (((VisualPropertyType) type).isNodeProp())
-						mapping = vmm.getVisualStyle().getNodeAppearanceCalculator()
-						             .getCalculator(((VisualPropertyType) type)).getMapping(0);
-					else
-						mapping = vmm.getVisualStyle().getEdgeAppearanceCalculator()
-						             .getCalculator(((VisualPropertyType) type)).getMapping(0);
+					mapping = vmm.getVisualStyle().getCalculator(vp).getMapping(0);
 
 					if (mapping instanceof ContinuousMapping) {
 						table.setRowHeight(i, 80);
 
 						int wi = table.getCellRect(0, 1, true).width;
-						final ImageIcon icon = ContinuousMappingEditorPanel.getIcon(wi, 70,
-						                                                            (VisualPropertyType) type);
-						final Class dataType = ((VisualPropertyType) type).getDataType();
+						final ImageIcon icon = ContinuousMappingEditorPanel.getIcon(wi, 70, vp);
+						final Class dataType = vp.getDataType();
 
 						if (dataType == Color.class) {
 							final DefaultTableCellRenderer gradientRenderer = new DefaultTableCellRenderer();
@@ -1286,18 +1202,18 @@
 			    && category.equalsIgnoreCase("Unused Properties")) {
 				((VizMapperProperty) curProp).setEditable(true);
 
-				VisualPropertyType type = (VisualPropertyType) ((VizMapperProperty) curProp)
+				VisualProperty vp = (VisualProperty) ((VizMapperProperty) curProp)
 				                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             .getHiddenObject();
 				visualPropertySheetPanel.removeProperty(curProp);
 
 				final VizMapperProperty newProp = new VizMapperProperty();
 				final VizMapperProperty mapProp = new VizMapperProperty();
 
-				newProp.setDisplayName(type.getName());
-				newProp.setHiddenObject(type);
+				newProp.setDisplayName(vp.getName());
+				newProp.setHiddenObject(vp);
 				newProp.setValue("Please select a value!");
 
-				if (type.isNodeProp()) {
+				if (vp.isNodeProp()) {
 					newProp.setCategory(NODE_VISUAL_MAPPING);
 					editorReg.registerEditor(newProp, nodeAttrEditor);
 				} else {
@@ -1313,7 +1229,7 @@
 				mapProp.setParentProperty(newProp);
 				visualPropertySheetPanel.addProperty(0, newProp);
 
-				expandLastSelectedItem(type.getName());
+				expandLastSelectedItem(vp.getName());
 
 				visualPropertySheetPanel.getTable().scrollRectToVisible(new Rectangle(0, 0, 10, 10));
 				visualPropertySheetPanel.repaint();
@@ -1323,13 +1239,13 @@
 				/*
 				 * Single left-click
 				 */
-				VisualPropertyType type = null;
+				VisualProperty type = null;
 
 				if ((curProp.getParentProperty() == null)
-				    && ((VizMapperProperty) curProp).getHiddenObject() instanceof VisualPropertyType)
-					type = (VisualPropertyType) ((VizMapperProperty) curProp).getHiddenObject();
+				    && ((VizMapperProperty) curProp).getHiddenObject() instanceof VisualProperty)
+					type = (VisualProperty) ((VizMapperProperty) curProp).getHiddenObject();
 				else if (curProp.getParentProperty() != null)
-					type = (VisualPropertyType) ((VizMapperProperty) curProp.getParentProperty()) .getHiddenObject();
+					type = (VisualProperty) ((VizMapperProperty) curProp.getParentProperty()) .getHiddenObject();
 				else
 
 					return;
@@ -1337,11 +1253,7 @@
 				final ObjectMapping selectedMapping;
 				Calculator calc = null;
 
-				if (type.isNodeProp()) {
-					calc = vmm.getVisualStyle().getNodeAppearanceCalculator().getCalculator(type);
-				} else {
-					calc = vmm.getVisualStyle().getEdgeAppearanceCalculator().getCalculator(type);
-				}
+				calc = vmm.getVisualStyle().getCalculator(type);
 
 				if (calc == null) {
 					return;
@@ -1384,15 +1296,16 @@
 		for (Property item : visualPropertySheetPanel.getProperties())
 			visualPropertySheetPanel.removeProperty(item);
 
+		/*
 		final NodeAppearanceCalculator nac = Cytoscape.getVisualMappingManager().getVisualStyle()
 		                                              .getNodeAppearanceCalculator();
 
 		final EdgeAppearanceCalculator eac = Cytoscape.getVisualMappingManager().getVisualStyle()
 		                                              .getEdgeAppearanceCalculator();
+		 */
+		final List<Calculator> ncList = Cytoscape.getVisualMappingManager().getVisualStyle().getNodeCalculators();
+		final List<Calculator> ecList = Cytoscape.getVisualMappingManager().getVisualStyle().getEdgeCalculators();
 
-		final List<Calculator> nacList = nac.getCalculators();
-		final List<Calculator> eacList = eac.getCalculators();
-
 		editorReg.registerDefaults();
 
 		/*
@@ -1400,42 +1313,55 @@
 		 */
 		List<Property> propRecord = new ArrayList<Property>();
 
-		setPropertyFromCalculator(nacList, NODE_VISUAL_MAPPING, propRecord);
-		setPropertyFromCalculator(eacList, EDGE_VISUAL_MAPPING, propRecord);
+		setPropertyFromCalculator(ncList, NODE_VISUAL_MAPPING, propRecord);
+		setPropertyFromCalculator(ecList, EDGE_VISUAL_MAPPING, propRecord);
 
+		/* Finally, build unused list */
+		setUnused(propRecord);
+
 		// Save it for later use.
 		propertyMap.put(vmm.getVisualStyle().getName(), propRecord);
-
-		/*
-		 * Finally, build unused list
-		 */
-		setUnused(propRecord);
 	}
 
 	/*
-	 * Add unused visual properties to the property sheet
+	 * Add unused visual properties (as VizMapperProperties) to propList
 	 *
 	 */
 	private void setUnused(List<Property> propList) {
-		buildList();
-		Collections.sort(noMapping);
-
-		for (VisualPropertyType type : noMapping) {
-			VizMapperProperty prop = new VizMapperProperty();
-			prop.setCategory(CATEGORY_UNUSED);
-			prop.setDisplayName(type.getName());
-			prop.setHiddenObject(type);
-			prop.setValue("Double-Click to create...");
-			// prop.setEditable(false);
-			visualPropertySheetPanel.addProperty(prop);
-			propList.add(prop);
+		VisualStyle vs = vmm.getVisualStyle();
+		for (VisualProperty vp : byNameSortedVisualProperties(VisualPropertyCatalog.collectionOfVisualProperties())) {
+			if (vs.getCalculator(vp) == null) {
+				VizMapperProperty prop = new VizMapperProperty();
+				prop.setCategory(CATEGORY_UNUSED);
+				prop.setDisplayName(vp.getName());
+				prop.setHiddenObject(vp);
+				prop.setValue("Double-Click to create...");
+				visualPropertySheetPanel.addProperty(prop);
+				propList.add(prop);
+			}
 		}
 	}
-
+	
+	/* Returns a sorted list of the visual properties
+	 * Needed because VisualProperties themselves are not Comparable,
+	 * (forcing them to be comparable would bloat the API and) 
+	 */
+	private List<VisualProperty> byNameSortedVisualProperties(Collection <VisualProperty>input){ // FIXME: I bet this could be done more java-style (i.e. better)
+		List <String> vpNames = new ArrayList<String>();
+		for (VisualProperty vp:input){
+			vpNames.add(vp.getName());
+		}
+		Collections.sort(vpNames);
+		List <VisualProperty> result = new ArrayList<VisualProperty>(input.size());
+		for (String name: vpNames){
+			result.add(VisualPropertyCatalog.getVisualProperty(name));
+		}
+		return result;
+	}
 	/*
 	 * Set value, title, and renderer for each property in the category.
 	 */
-	private final void setDiscreteProps(VisualPropertyType type, Map discMapping,
+	private final void setDiscreteProps(VisualProperty type, Map discMapping,
 	                                    Set<Object> attrKeys, PropertyEditor editor,
 	                                    TableCellRenderer rend, DefaultProperty parent) {
 		if (attrKeys == null)
@@ -1481,7 +1407,7 @@
 	 */
 	private final void buildProperty(Calculator calc, VizMapperProperty calculatorTypeProp,
 	                                 String rootCategory) {
-		final VisualPropertyType type = calc.getVisualPropertyType();
+		final VisualProperty type = calc.getVisualProperty();
 		/*
 		 * Set one calculator
 		 */
@@ -1489,7 +1415,7 @@
 		// calculatorTypeProp.setType(String.class);
 		calculatorTypeProp.setDisplayName(type.getName());
 		calculatorTypeProp.setHiddenObject(type);
-
+		System.out.println("Build one property for one visual property.");
 		/*
 		 * Mapping 0 is always currently used mapping.
 		 */
@@ -1529,7 +1455,7 @@
 			final Iterator it;
 			final int nodeOrEdge;
 
-			if (calc.getVisualPropertyType().isNodeProp()) {
+			if (calc.getVisualProperty().isNodeProp()) {
 				attr = Cytoscape.getNodeAttributes();
 				it = Cytoscape.getCurrentNetwork().nodesIterator();
 				editorReg.registerEditor(calculatorTypeProp, nodeAttrEditor);
@@ -1547,100 +1473,24 @@
 			if ((firstMap.getClass() == DiscreteMapping.class) && (attrName != null)) {
 				final Map discMapping = ((DiscreteMapping) firstMap).getAll();
 				final Set<Object> attrSet = loadKeys(attrName, attr, firstMap, nodeOrEdge);
+				Class dataTypeClass = type.getDataType();
 
-				switch (type) {
-					/*
-					 * Color calculators
-					 */
-					case NODE_FILL_COLOR:
-					case NODE_BORDER_COLOR:
-					case EDGE_COLOR:
-					case EDGE_SRCARROW_COLOR:
-					case EDGE_TGTARROW_COLOR:
-					case NODE_LABEL_COLOR:
-					case EDGE_LABEL_COLOR:
-						setDiscreteProps(type, discMapping, attrSet, colorCellEditor,
-						                 collorCellRenderer, calculatorTypeProp);
-
-						break;
-
-					case NODE_LINE_STYLE:
-					case EDGE_LINE_STYLE:
-						setDiscreteProps(type, discMapping, attrSet, lineCellEditor,
-						                 lineCellRenderer, calculatorTypeProp);
-
-						break;
-
-					/*
-					 * Shape property
-					 */
-					case NODE_SHAPE:
-						setDiscreteProps(type, discMapping, attrSet, shapeCellEditor,
-						                 shapeCellRenderer, calculatorTypeProp);
-
-						break;
-
-					/*
-					 * Arrow Head Shapes
-					 */
-					case EDGE_SRCARROW_SHAPE:
-					case EDGE_TGTARROW_SHAPE:
-						setDiscreteProps(type, discMapping, attrSet, arrowCellEditor,
-						                 arrowShapeCellRenderer, calculatorTypeProp);
-
-						break;
-
-					case NODE_LABEL:
-					case EDGE_LABEL:
-					case NODE_TOOLTIP:
-					case EDGE_TOOLTIP:
-						setDiscreteProps(type, discMapping, attrSet, stringCellEditor,
-						                 defCellRenderer, calculatorTypeProp);
-
-						break;
-
-					/*
-					 * Font props
-					 */
-					case NODE_FONT_FACE:
-					case EDGE_FONT_FACE:
-						setDiscreteProps(type, discMapping, attrSet, fontCellEditor,
-						                 fontCellRenderer, calculatorTypeProp);
-
-						break;
-
-					/*
-					 * Size-related props
-					 */
-					case NODE_FONT_SIZE:
-					case EDGE_FONT_SIZE:
-					case NODE_SIZE:
-					case NODE_WIDTH:
-					case NODE_HEIGHT:
-					case NODE_LINE_WIDTH:
-					case EDGE_LINE_WIDTH:
-					case NODE_OPACITY:
-					case EDGE_OPACITY:
-					case NODE_LABEL_OPACITY:
-					case EDGE_LABEL_OPACITY:
-					case NODE_BORDER_OPACITY:
-						setDiscreteProps(type, discMapping, attrSet, numberCellEditor,
-						                 defCellRenderer, calculatorTypeProp);
-
-						break;
-
-					/*
-					 * Node Label Position. Needs special editor
-					 */
-					case NODE_LABEL_POSITION:
-						setDiscreteProps(type, discMapping, attrSet, labelPositionEditor,
-						                 labelPositionRenderer, calculatorTypeProp);
-
-						break;
-
-					default:
-						break;
+				if (dataTypeClass.isAssignableFrom(DiscreteValue.class)){ // FIXME: these should be Enum-like instead!! (or Discrete or something)
+					setDiscreteProps(type, discMapping, attrSet, buildCellEditor(type), new ShapeCellRenderer(type), calculatorTypeProp);
+				} else if (dataTypeClass.isAssignableFrom(LabelPosition.class)){
+					setDiscreteProps(type, discMapping, attrSet, labelPositionEditor, labelPositionRenderer, calculatorTypeProp);
+				} else if (dataTypeClass.isAssignableFrom(Number.class)){
+					setDiscreteProps(type, discMapping, attrSet, numberCellEditor, defCellRenderer, calculatorTypeProp);
+				} else if (dataTypeClass.isAssignableFrom(Font.class)){
+					setDiscreteProps(type, discMapping, attrSet, fontCellEditor, fontCellRenderer, calculatorTypeProp);
+				} else if (dataTypeClass.isAssignableFrom(String.class)){
+					setDiscreteProps(type, discMapping, attrSet, stringCellEditor, defCellRenderer, calculatorTypeProp);
+				} else if (dataTypeClass.isAssignableFrom(Color.class)){
+					setDiscreteProps(type, discMapping, attrSet, colorCellEditor, collorCellRenderer, calculatorTypeProp);
+				} else {
+					System.out.println("unknown datatype:"+dataTypeClass);
 				}
+
 			} else if ((firstMap.getClass() == ContinuousMapping.class) && (attrName != null)) {
 				int wi = this.visualPropertySheetPanel.getTable().getCellRect(0, 1, true).width;
 
@@ -1652,7 +1502,7 @@
 
 				final Class dataType = type.getDataType();
 				final ImageIcon icon = ContinuousMappingEditorPanel.getIcon(wi, 70,
-				                                                            (VisualPropertyType) type);
+				                                                            (VisualProperty) type);
 
 				if (dataType == Color.class) {
 					/*
@@ -1712,10 +1562,23 @@
 		visualPropertySheetPanel.setRendererFactory(rendReg);
 		visualPropertySheetPanel.setEditorFactory(editorReg);
 	}
-
+	private CyComboBoxPropertyEditor buildCellEditor(VisualProperty vp){
+		final List<Icon> iconList = new ArrayList<Icon>();
+		final List<Object> values = new ArrayList<Object>();
+		final Map<Object, Icon> iconSet = vp.getIconSet();
+		
+		for (Object val: iconSet.values()){
+			iconList.add(iconSet.get(val));
+			values.add(val);
+		}
+		CyComboBoxPropertyEditor editor = new CyComboBoxPropertyEditor();
+		editor.setAvailableValues(values.toArray());
+		editor.setAvailableIcons(iconList.toArray(new Icon[0]));
+		return editor;
+	}
 	private void setPropertyFromCalculator(List<Calculator> calcList, String rootCategory,
 	                                       List<Property> propRecord) {
-		VisualPropertyType type = null;
+		VisualProperty type = null;
 
 		for (Calculator calc : calcList) {
 			final VizMapperProperty calculatorTypeProp = new VizMapperProperty();
@@ -1725,7 +1588,7 @@
 
 			if ((editor == null)
 			    && (calculatorTypeProp.getCategory().equals("Unused Properties") == false)) {
-				type = (VisualPropertyType) calculatorTypeProp.getHiddenObject();
+				type = (VisualProperty) calculatorTypeProp.getHiddenObject();
 
 				if (type.isNodeProp()) {
 					editorReg.registerEditor(calculatorTypeProp, nodeAttrEditor);
@@ -1845,15 +1708,15 @@
 	 */
 	public void initializeTableState() {
 		propertyMap = new HashMap<String, List<Property>>();
-		editorWindowManager = new HashMap<VisualPropertyType, JDialog>();
+		editorWindowManager = new HashMap<VisualProperty, JDialog>();
 		defaultImageManager = new HashMap<String, Image>();
 	}
 
-	private void manageWindow(final String status, VisualPropertyType vpt, Object source) {
+	private void manageWindow(final String status, VisualProperty vpt, Object source) {
 		if (status.equals(ContinuousMappingEditorPanel.EDITOR_WINDOW_OPENED)) {
 			this.editorWindowManager.put(vpt, (JDialog) source);
 		} else if (status.equals(ContinuousMappingEditorPanel.EDITOR_WINDOW_CLOSED)) {
-			final VisualPropertyType type = vpt;
+			final VisualProperty type = vpt;
 
 			/*
 			 * Update icon
@@ -1897,17 +1760,17 @@
 	}
 
 	private void closeEditorWindow() {
-		Set<VisualPropertyType> typeSet = editorWindowManager.keySet();
-		Set<VisualPropertyType> keySet = new HashSet<VisualPropertyType>();
+		Set<VisualProperty> typeSet = editorWindowManager.keySet();
+		Set<VisualProperty> keySet = new HashSet<VisualProperty>();
 
-		for (VisualPropertyType vpt : typeSet) {
+		for (VisualProperty vpt : typeSet) {
 			JDialog window = editorWindowManager.get(vpt);
 			manageWindow(ContinuousMappingEditorPanel.EDITOR_WINDOW_CLOSED, vpt, null);
 			window.dispose();
 			keySet.add(vpt);
 		}
 
-		for (VisualPropertyType type : keySet)
+		for (VisualProperty type : keySet)
 			editorWindowManager.remove(type);
 	}
 
@@ -1918,6 +1781,7 @@
 	 *            DOCUMENT ME!
 	 */
 	public void propertyChange(PropertyChangeEvent e) {
+		//System.out.println("==================GLOBAL Signal: " + e.getPropertyName() + ", SRC = " + e.getSource().toString());
 		// Set ignore flag.
 		if (e.getPropertyName().equals(Integer.toString(Cytoscape.SESSION_OPENED))) {
 			ignore = true;
@@ -1932,10 +1796,10 @@
 		 */
 		if (e.getPropertyName().equals(ContinuousMappingEditorPanel.EDITOR_WINDOW_OPENED)
 		    || e.getPropertyName().equals(ContinuousMappingEditorPanel.EDITOR_WINDOW_CLOSED)) {
-			manageWindow(e.getPropertyName(), (VisualPropertyType) e.getNewValue(), e.getSource());
+			manageWindow(e.getPropertyName(), (VisualProperty) e.getNewValue(), e.getSource());
 
 			if (e.getPropertyName().equals(ContinuousMappingEditorPanel.EDITOR_WINDOW_CLOSED))
-				editorWindowManager.remove((VisualPropertyType) e.getNewValue());
+				editorWindowManager.remove((VisualProperty) e.getNewValue());
 
 			return;
 		}
@@ -1956,8 +1820,7 @@
 		} else if (e.getPropertyName().equals(Cytoscape.SESSION_LOADED)
 		           || e.getPropertyName().equals(Cytoscape.VIZMAP_LOADED)) {
 			final String vsName = vmm.getVisualStyle().getName();
-			System.out.println("got VIZMAP_LOADED");
-
+			
 			lastVSName = null;
 			initVizmapperGUI();
 			switchVS(vsName);
@@ -1992,7 +1855,7 @@
 		 **********************************************************************/
 		if (e.getPropertyName().equalsIgnoreCase("value") == false)
 			return;
-
+		
 		if (e.getNewValue().equals(e.getOldValue()))
 			return;
 
@@ -2008,7 +1871,7 @@
 		Item selectedItem = (Item) visualPropertySheetPanel.getTable().getValueAt(selected, 0);
 		VizMapperProperty prop = (VizMapperProperty) selectedItem.getProperty();
 
-		VisualPropertyType type = null;
+		VisualProperty type = null;
 		String ctrAttrName = null;
 
 		VizMapperProperty typeRootProp = null;
@@ -2017,30 +1880,34 @@
 			/*
 			 * This is a controlling attr name change signal.
 			 */
+			//System.out.println("This is a controlling attr name change signal.");
 			typeRootProp = (VizMapperProperty) prop;
-			type = (VisualPropertyType) ((VizMapperProperty) prop).getHiddenObject();
+			type = (VisualProperty) ((VizMapperProperty) prop).getHiddenObject();
 			ctrAttrName = (String) e.getNewValue();
 		} else if ((prop.getParentProperty() == null) && (e.getNewValue() == null)) {
 			/*
 			 * Empty cell selected. no need to change anything.
 			 */
+			//System.out.println("Empty cell selected. no need to change anything.");
 			return;
 		} else {
+			System.out.println("something else");
 			typeRootProp = (VizMapperProperty) prop.getParentProperty();
 
 			if (prop.getParentProperty() == null)
 				return;
 
-			type = (VisualPropertyType) ((VizMapperProperty) prop.getParentProperty())
+			type = (VisualProperty) ((VizMapperProperty) prop.getParentProperty())
 			                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             .getHiddenObject();
 		}
 
 		/*
 		 * Mapping type changed
 		 */
+		//System.out.println("Mapping type changed");
 		if (prop.getHiddenObject() instanceof ObjectMapping
 		    || prop.getDisplayName().equals("Mapping Type")) {
-			System.out.println("Mapping type changed: " + prop.getHiddenObject());
+			//System.out.println("Mapping type changed: " + prop.getHiddenObject());
 
 			if (e.getNewValue() == null)
 				return;
@@ -2081,7 +1948,6 @@
 				return;
 
 			switchMapping(prop, e.getNewValue().toString(), prop.getParentProperty().getValue());
-
 			/*
 			 * restore expanded props.
 			 */
@@ -2097,11 +1963,7 @@
 		ObjectMapping mapping;
 		final Calculator curCalc;
 
-		if (type.isNodeProp()) {
-			curCalc = vmm.getVisualStyle().getNodeAppearanceCalculator().getCalculator(type);
-		} else {
-			curCalc = vmm.getVisualStyle().getEdgeAppearanceCalculator().getCalculator(type);
-		}
+		curCalc = vmm.getVisualStyle().getCalculator(type);
 
 		if (curCalc == null) {
 			return;
@@ -2170,11 +2032,9 @@
 			final VizMapperProperty newRootProp = new VizMapperProperty();
 
 			if (type.isNodeProp())
-				buildProperty(vmm.getVisualStyle().getNodeAppearanceCalculator().getCalculator(type),
-				              newRootProp, NODE_VISUAL_MAPPING);
+				buildProperty(vmm.getVisualStyle().getCalculator(type), newRootProp, NODE_VISUAL_MAPPING);
 			else
-				buildProperty(vmm.getVisualStyle().getEdgeAppearanceCalculator().getCalculator(type),
-				              newRootProp, EDGE_VISUAL_MAPPING);
+				buildProperty(vmm.getVisualStyle().getCalculator(type), newRootProp, EDGE_VISUAL_MAPPING);
 
 			removeProperty(typeRootProp);
 
@@ -2297,21 +2157,15 @@
 		if (attrName == null) {
 			return;
 		}
-
-		final VisualPropertyType type = (VisualPropertyType) ((VizMapperProperty) prop .getParentProperty())
+		final VisualProperty type = (VisualProperty) ((VizMapperProperty) prop .getParentProperty())
 		                                .getHiddenObject();
 		final String newCalcName = vmm.getVisualStyle().getName() + "-" + type.getName() + "-"
 		                           + newMapName;
-
 		// Extract target calculator
 		Calculator newCalc = vmm.getCalculatorCatalog().getCalculator(type, newCalcName);
-
 		Calculator oldCalc = null;
 
-		if (type.isNodeProp())
-			oldCalc = vmm.getVisualStyle().getNodeAppearanceCalculator().getCalculator(type);
-		else
-			oldCalc = vmm.getVisualStyle().getEdgeAppearanceCalculator().getCalculator(type);
+		oldCalc = vmm.getVisualStyle().getCalculator(type);
 
 		/*
 		 * If not exist, create new one.
@@ -2321,14 +2175,9 @@
 			newCalc.getMapping(0).setControllingAttributeName((String) attrName, null, true);
 			vmm.getCalculatorCatalog().addCalculator(newCalc);
 		}
-
 		newCalc.getMapping(0).setControllingAttributeName((String) attrName, null, true);
 
-		if (type.isNodeProp()) {
-			vmm.getVisualStyle().getNodeAppearanceCalculator().setCalculator(newCalc);
-		} else
-			vmm.getVisualStyle().getEdgeAppearanceCalculator().setCalculator(newCalc);
-
+		vmm.getVisualStyle().setCalculator(newCalc);
 		/*
 		 * If old calc is not standard name, rename it.
 		 */
@@ -2343,9 +2192,7 @@
 				oldMappingTypeName = "Passthrough Mapper";
 			else
 				oldMappingTypeName = null;
-
 			final String oldCalcName = type.getName() + "-" + oldMappingTypeName;
-
 			if (vmm.getCalculatorCatalog().getCalculator(type, oldCalcName) == null) {
 				final Calculator newC = getNewCalculator(type, oldMappingTypeName, oldCalcName);
 				newC.getMapping(0).setControllingAttributeName((String) attrName, null, false);
@@ -2359,11 +2206,9 @@
 		final VizMapperProperty newRootProp = new VizMapperProperty();
 
 		if (type.isNodeProp())
-			buildProperty(vmm.getVisualStyle().getNodeAppearanceCalculator().getCalculator(type),
-			              newRootProp, NODE_VISUAL_MAPPING);
+			buildProperty(vmm.getVisualStyle().getCalculator(type), newRootProp, NODE_VISUAL_MAPPING);
 		else
-			buildProperty(vmm.getVisualStyle().getEdgeAppearanceCalculator().getCalculator(type),
-			              newRootProp, EDGE_VISUAL_MAPPING);
+			buildProperty(vmm.getVisualStyle().getCalculator(type), newRootProp, EDGE_VISUAL_MAPPING);
 
 		expandLastSelectedItem(type.getName());
 
@@ -2400,9 +2245,8 @@
 		}
 	}
 
-	private Calculator getNewCalculator(final VisualPropertyType type, final String newMappingName,
+	private Calculator getNewCalculator(final VisualProperty type, final String newMappingName,
 	                                    final String newCalcName) {
-		System.out.println("Mapper = " + newMappingName);
 
 		final CalculatorCatalog catalog = vmm.getCalculatorCatalog();
 
@@ -2433,7 +2277,7 @@
 		else
 			mapType = ObjectMapping.EDGE_MAPPING;
 
-		final Object defaultObj = type.getDefault(vmm.getVisualStyle());
+		final Object defaultObj = vmm.getVisualStyle().getDefaultValue(type);
 
 		System.out.println("defobj = " + defaultObj.getClass() + ", Type = " + type.getName());
 
@@ -2444,7 +2288,7 @@
 			mapper = (ObjectMapping) mapperCon.newInstance(invokeArgs);
 		} catch (Exception exc) {
 			System.err.println("Error creating mapping");
-
+			exc.printStackTrace();
 			return null;
 		}
 
@@ -2461,33 +2305,6 @@
 		vsNameComboBox.setSelectedItem(vsName);
 	}
 
-	private void buildList() {
-		noMapping = new ArrayList<VisualPropertyType>();
-
-		final VisualStyle vs = vmm.getVisualStyle();
-		final NodeAppearanceCalculator nac = vs.getNodeAppearanceCalculator();
-		final EdgeAppearanceCalculator eac = vs.getEdgeAppearanceCalculator();
-
-		ObjectMapping mapping = null;
-
-		for (VisualPropertyType type : VisualPropertyType.values()) {
-			Calculator calc = nac.getCalculator(type);
-
-			if (calc == null) {
-				calc = eac.getCalculator(type);
-
-				if (calc != null)
-					mapping = calc.getMapping(0);
-			} else
-				mapping = calc.getMapping(0);
-
-			if ((mapping == null) && type.isAllowed())
-				noMapping.add(type);
-
-			mapping = null;
-		}
-	}
-
 	/*
 	 * Actions for option menu
 	 */
@@ -2529,17 +2346,12 @@
 			final VisualStyle newStyle = new VisualStyle(name);
 			final List<Calculator> calcs = new ArrayList<Calculator>(vmm.getCalculatorCatalog()
 			                                                            .getCalculators());
-			final Calculator dummy = calcs.get(0);
-			newStyle.getNodeAppearanceCalculator().setCalculator(dummy);
-
 			// add it to the catalog
 			vmm.getCalculatorCatalog().addVisualStyle(newStyle);
 			// Apply the new style
 			vmm.setVisualStyle(newStyle);
 			vmm.setVisualStyleForView(Cytoscape.getCurrentNetworkView(), newStyle);
 
-			removeMapping(dummy.getVisualPropertyType());
-
 			final JPanel defPanel = DefaultAppearenceBuilder.getDefaultView(name);
 			final GraphView view = (GraphView) ((DefaultViewPanel) defPanel).getView();
 			final Dimension panelSize = defaultAppearencePanel.getSize();
@@ -2698,6 +2510,7 @@
 				clone = (VisualStyle) currentStyle.clone();
 			} catch (CloneNotSupportedException exc) {
 				System.err.println("Clone not supported exception!");
+				exc.printStackTrace();
 			}
 
 			final String newName = getStyleName(clone);
@@ -2739,7 +2552,7 @@
 			Property curProp = item.getProperty();
 
 			if (curProp instanceof VizMapperProperty) {
-				final VisualPropertyType type = (VisualPropertyType) ((VizMapperProperty) curProp).getHiddenObject();
+				final VisualProperty type = (VisualProperty) ((VizMapperProperty) curProp).getHiddenObject();
 
 				if (type == null)
 					return;
@@ -2761,19 +2574,13 @@
 						editorWindowManager.remove(type);
 					}
 
-					if (type.isNodeProp()) {
-						vmm.getVisualStyle().getNodeAppearanceCalculator().removeCalculator(type);
-					} else {
-						vmm.getVisualStyle().getEdgeAppearanceCalculator().removeCalculator(type);
-					}
+					vmm.getVisualStyle().removeCalculator(type);
 
 					Cytoscape.redrawGraph(Cytoscape.getCurrentNetworkView());
 
 					/*
 					 * Finally, move the visual property to "unused list"
 					 */
-					noMapping.add(type);
-
 					VizMapperProperty prop = new VizMapperProperty();
 					prop.setCategory(CATEGORY_UNUSED);
 					prop.setDisplayName(type.getName());
@@ -2792,49 +2599,6 @@
 		}
 	}
 
-	private void removeMapping(final VisualPropertyType type) {
-		if (type.isNodeProp()) {
-			vmm.getVisualStyle().getNodeAppearanceCalculator().removeCalculator(type);
-		} else {
-			vmm.getVisualStyle().getEdgeAppearanceCalculator().removeCalculator(type);
-		}
-
-		Cytoscape.redrawGraph(Cytoscape.getCurrentNetworkView());
-
-		final Property[] props = visualPropertySheetPanel.getProperties();
-		Property toBeRemoved = null;
-
-		for (Property p : props) {
-			if (p.getDisplayName().equals(type.getName())) {
-				toBeRemoved = p;
-
-				break;
-			}
-		}
-
-		visualPropertySheetPanel.removeProperty(toBeRemoved);
-
-		removeProperty(toBeRemoved);
-
-		/*
-		 * Finally, move the visual property to "unused list"
-		 */
-		noMapping.add(type);
-
-		VizMapperProperty prop = new VizMapperProperty();
-		prop.setCategory(CATEGORY_UNUSED);
-		prop.setDisplayName(type.getName());
-		prop.setHiddenObject(type);
-		prop.setValue("Double-Click to create...");
-		visualPropertySheetPanel.addProperty(prop);
-
-		if (propertyMap.get(vmm.getVisualStyle().getName()) != null) {
-			propertyMap.get(vmm.getVisualStyle().getName()).add(prop);
-		}
-
-		visualPropertySheetPanel.repaint();
-	}
-
 	/**
 	 * Edit all selected cells at once.
 	 *
@@ -2863,7 +2627,7 @@
 			return;
 		}
 
-		final VisualPropertyType type = (VisualPropertyType) ((VizMapperProperty) prop .getParentProperty())
+		final VisualProperty type = (VisualProperty) ((VizMapperProperty) prop .getParentProperty())
 		                                .getHiddenObject();
 
 		/*
@@ -2872,13 +2636,10 @@
 		final ObjectMapping mapping;
 		final CyAttributes attr;
 
+		mapping = vmm.getVisualStyle().getCalculator(type).getMapping(0);
 		if (type.isNodeProp()) {
-			mapping = vmm.getVisualStyle().getNodeAppearanceCalculator().getCalculator(type)
-			             .getMapping(0);
 			attr = Cytoscape.getNodeAttributes();
 		} else {
-			mapping = vmm.getVisualStyle().getEdgeAppearanceCalculator().getCalculator(type)
-			             .getMapping(0);
 			attr = Cytoscape.getEdgeAttributes();
 		}
 
@@ -2980,8 +2741,8 @@
 			final VizMapperProperty prop = (VizMapperProperty) item.getProperty();
 			final Object hidden = prop.getHiddenObject();
 
-			if (hidden instanceof VisualPropertyType) {
-				final VisualPropertyType type = (VisualPropertyType) hidden;
+			if (hidden instanceof VisualProperty) {
+				final VisualProperty type = (VisualProperty) hidden;
 
 				final Map valueMap = new HashMap();
 				final long seed = System.currentTimeMillis();
@@ -2992,15 +2753,12 @@
 				final CyAttributes attr;
 				final int nOre;
 
+				oMap = vmm.getVisualStyle().getCalculator(type).getMapping(0);
 				if (type.isNodeProp()) {
 					attr = Cytoscape.getNodeAttributes();
-					oMap = vmm.getVisualStyle().getNodeAppearanceCalculator().getCalculator(type)
-					          .getMapping(0);
 					nOre = ObjectMapping.NODE_MAPPING;
 				} else {
 					attr = Cytoscape.getEdgeAttributes();
-					oMap = vmm.getVisualStyle().getEdgeAppearanceCalculator().getCalculator(type)
-					          .getMapping(0);
 					nOre = ObjectMapping.EDGE_MAPPING;
 				}
 
@@ -3080,15 +2838,11 @@
 				final VizMapperProperty newRootProp = new VizMapperProperty();
 
 				if (type.isNodeProp())
-					buildProperty(vmm.getVisualStyle().getNodeAppearanceCalculator()
-					                 .getCalculator(type), newRootProp, NODE_VISUAL_MAPPING);
+					buildProperty(vmm.getVisualStyle().getCalculator(type), newRootProp, NODE_VISUAL_MAPPING);
 				else
-					buildProperty(vmm.getVisualStyle().getEdgeAppearanceCalculator()
-					                 .getCalculator(type), newRootProp, EDGE_VISUAL_MAPPING);
+					buildProperty(vmm.getVisualStyle().getCalculator(type), newRootProp, EDGE_VISUAL_MAPPING);
 
 				removeProperty(prop);
-				System.out.println("asdf pre vs name"); 
-				System.out.println("asdf vs name" + vmm.getVisualStyle().getName());
 				propertyMap.get(vmm.getVisualStyle().getName()).add(newRootProp);
 
 				expandLastSelectedItem(type.getName());
@@ -3120,23 +2874,20 @@
 			final VizMapperProperty prop = (VizMapperProperty) item.getProperty();
 			final Object hidden = prop.getHiddenObject();
 
-			if (hidden instanceof VisualPropertyType) {
-				final VisualPropertyType type = (VisualPropertyType) hidden;
+			if (hidden instanceof VisualProperty) {
+				final VisualProperty type = (VisualProperty) hidden;
 
 				final Map valueMap = new HashMap();
 				final ObjectMapping oMap;
 				final CyAttributes attr;
 				final int nOre;
 
+				oMap = vmm.getVisualStyle().getCalculator(type).getMapping(0);
 				if (type.isNodeProp()) {
 					attr = Cytoscape.getNodeAttributes();
-					oMap = vmm.getVisualStyle().getNodeAppearanceCalculator().getCalculator(type)
-					          .getMapping(0);
 					nOre = ObjectMapping.NODE_MAPPING;
 				} else {
 					attr = Cytoscape.getEdgeAttributes();
-					oMap = vmm.getVisualStyle().getEdgeAppearanceCalculator().getCalculator(type)
-					          .getMapping(0);
 					nOre = ObjectMapping.EDGE_MAPPING;
 				}
 
@@ -3189,11 +2940,9 @@
 				final VizMapperProperty newRootProp = new VizMapperProperty();
 
 				if (type.isNodeProp())
-					buildProperty(vmm.getVisualStyle().getNodeAppearanceCalculator()
-					                 .getCalculator(type), newRootProp, NODE_VISUAL_MAPPING);
+					buildProperty(vmm.getVisualStyle().getCalculator(type), newRootProp, NODE_VISUAL_MAPPING);
 				else
-					buildProperty(vmm.getVisualStyle().getEdgeAppearanceCalculator()
-					                 .getCalculator(type), newRootProp, EDGE_VISUAL_MAPPING);
+					buildProperty(vmm.getVisualStyle().getCalculator(type), newRootProp, EDGE_VISUAL_MAPPING);
 
 				removeProperty(prop);
 				propertyMap.get(vmm.getVisualStyle().getName()).add(newRootProp);
@@ -3227,21 +2976,18 @@
 			final VizMapperProperty prop = (VizMapperProperty) item.getProperty();
 			final Object hidden = prop.getHiddenObject();
 
-			if (hidden instanceof VisualPropertyType) {
-				final VisualPropertyType type = (VisualPropertyType) hidden;
+			if (hidden instanceof VisualProperty) {
+				final VisualProperty type = (VisualProperty) hidden;
 
 				final Map valueMap = new HashMap();
 				final ObjectMapping oMap;
 				final CyAttributes attr;
 
+				oMap = vmm.getVisualStyle().getCalculator(type).getMapping(0);
 				if (type.isNodeProp()) {
 					attr = Cytoscape.getNodeAttributes();
-					oMap = vmm.getVisualStyle().getNodeAppearanceCalculator().getCalculator(type)
-					          .getMapping(0);
 				} else {
 					attr = Cytoscape.getEdgeAttributes();
-					oMap = vmm.getVisualStyle().getEdgeAppearanceCalculator().getCalculator(type)
-					          .getMapping(0);
 				}
 
 				if ((oMap instanceof DiscreteMapping) == false)
@@ -3249,8 +2995,7 @@
 
 				dm = (DiscreteMapping) oMap;
 
-				final Calculator nodeLabelCalc = vmm.getVisualStyle().getNodeAppearanceCalculator()
-				                                    .getCalculator(VisualPropertyType.NODE_LABEL);
+				final Calculator nodeLabelCalc = vmm.getVisualStyle().getCalculator(VisualPropertyCatalog.getVisualProperty("NODE_LABEL"));
 
 				if (nodeLabelCalc == null) {
 					return;
@@ -3261,15 +3006,15 @@
 
 				// final Set<Object> attrSet =
 				// loadKeys(oMap.getControllingAttributeName(), attr, oMap);
+				/* FIXME
 				if (vmm.getVisualStyle().getNodeAppearanceCalculator().getNodeSizeLocked()) {
 					return;
 				}
-
+				*/
 				DiscreteMapping wm = null;
 
-				if ((type == NODE_WIDTH)) {
-					wm = (DiscreteMapping) vmm.getVisualStyle().getNodeAppearanceCalculator()
-					                          .getCalculator(NODE_WIDTH).getMapping(0);
+				if ((type.getName().equals("NODE_WIDTH"))) {
+					wm = (DiscreteMapping) vmm.getVisualStyle().getCalculator(VisualPropertyCatalog.getVisualProperty("NODE_WIDTH")).getMapping(0);
 
 					wm.setControllingAttributeName(ctrAttrName, Cytoscape.getCurrentNetwork(), false);
 
@@ -3286,13 +3031,8 @@
 						                    ObjectMapping.NODE_MAPPING);
 					}
 
-					Integer height = ((Number) (vmm.getVisualStyle().getNodeAppearanceCalculator()
-					                               .getDefaultAppearance().get(NODE_FONT_SIZE))) .intValue();
-					vmm.getVisualStyle().getNodeAppearanceCalculator().getDefaultAppearance()
-					   .set(NODE_HEIGHT, height * 2.5);
-
-					Integer fontSize = ((Number) vmm.getVisualStyle().getNodeAppearanceCalculator()
-					                                .getDefaultAppearance().get(NODE_FONT_SIZE)) .intValue();
+					Integer height = ((Number) vmm.getVisualStyle().getDefaultValue(VisualPropertyCatalog.getVisualProperty("NODE_FONT_SIZE")) ).intValue();
+					Integer fontSize = ((Number) vmm.getVisualStyle().getDefaultValue(VisualPropertyCatalog.getVisualProperty("NODE_FONT_SIZE"))) .intValue();
 					int strLen;
 
 					String labelString = null;
@@ -3363,9 +3103,8 @@
 							}
 						}
 					}
-				} else if ((type == NODE_HEIGHT)) {
-					wm = (DiscreteMapping) vmm.getVisualStyle().getNodeAppearanceCalculator()
-					                          .getCalculator(NODE_HEIGHT).getMapping(0);
+				} else if ((type.getName().equals("NODE_HEIGHT"))) {
+					wm = (DiscreteMapping) vmm.getVisualStyle().getCalculator(VisualPropertyCatalog.getVisualProperty("NODE_HEIGHT")).getMapping(0);
 
 					wm.setControllingAttributeName(ctrAttrName, Cytoscape.getCurrentNetwork(), false);
 
@@ -3382,8 +3121,7 @@
 						                    ObjectMapping.NODE_MAPPING);
 					}
 
-					Integer fontSize = ((Number) vmm.getVisualStyle().getNodeAppearanceCalculator()
-					                                .getDefaultAppearance().get(NODE_FONT_SIZE)) .intValue();
+					Integer fontSize = ((Number) vmm.getVisualStyle().getDefaultValue(VisualPropertyCatalog.getVisualProperty("NODE_FONT_SIZE"))).intValue();
 					int strLen;
 
 					String labelString = null;
@@ -3441,11 +3179,9 @@
 				final VizMapperProperty newRootProp = new VizMapperProperty();
 
 				if (type.isNodeProp())
-					buildProperty(vmm.getVisualStyle().getNodeAppearanceCalculator()
-					                 .getCalculator(type), newRootProp, NODE_VISUAL_MAPPING);
+					buildProperty(vmm.getVisualStyle().getCalculator(type), newRootProp, NODE_VISUAL_MAPPING);
 				else
-					buildProperty(vmm.getVisualStyle().getEdgeAppearanceCalculator()
-					                 .getCalculator(type), newRootProp, EDGE_VISUAL_MAPPING);
+					buildProperty(vmm.getVisualStyle().getCalculator(type), newRootProp, EDGE_VISUAL_MAPPING);
 
 				removeProperty(prop);
 				propertyMap.get(vmm.getVisualStyle().getName()).add(newRootProp);
@@ -3487,8 +3223,8 @@
 			final VizMapperProperty prop = (VizMapperProperty) item.getProperty();
 			final Object hidden = prop.getHiddenObject();
 
-			if (hidden instanceof VisualPropertyType) {
-				final VisualPropertyType type = (VisualPropertyType) hidden;
+			if (hidden instanceof VisualProperty) {
+				final VisualProperty type = (VisualProperty) hidden;
 
 				final Map valueMap = new HashMap();
 				final ObjectMapping oMap;
@@ -3496,15 +3232,12 @@
 				final CyAttributes attr;
 				final int nOre;
 
+				oMap = vmm.getVisualStyle().getCalculator(type).getMapping(0);
 				if (type.isNodeProp()) {
 					attr = Cytoscape.getNodeAttributes();
-					oMap = vmm.getVisualStyle().getNodeAppearanceCalculator().getCalculator(type)
-					          .getMapping(0);
 					nOre = ObjectMapping.NODE_MAPPING;
 				} else {
 					attr = Cytoscape.getEdgeAttributes();
-					oMap = vmm.getVisualStyle().getEdgeAppearanceCalculator().getCalculator(type)
-					          .getMapping(0);
 					nOre = ObjectMapping.EDGE_MAPPING;
 				}
 
@@ -3551,11 +3284,9 @@
 				final VizMapperProperty newRootProp = new VizMapperProperty();
 
 				if (type.isNodeProp())
-					buildProperty(vmm.getVisualStyle().getNodeAppearanceCalculator()
-					                 .getCalculator(type), newRootProp, NODE_VISUAL_MAPPING);
+					buildProperty(vmm.getVisualStyle().getCalculator(type), newRootProp, NODE_VISUAL_MAPPING);
 				else
-					buildProperty(vmm.getVisualStyle().getEdgeAppearanceCalculator()
-					                 .getCalculator(type), newRootProp, EDGE_VISUAL_MAPPING);
+					buildProperty(vmm.getVisualStyle().getCalculator(type), newRootProp, EDGE_VISUAL_MAPPING);
 
 				removeProperty(prop);
 				propertyMap.get(vmm.getVisualStyle().getName()).add(newRootProp);
@@ -3622,7 +3353,7 @@
 
 		VizMapperProperty prop = ((VizMapperProperty) curProp);
 
-		if (prop.getHiddenObject() instanceof VisualPropertyType
+		if (prop.getHiddenObject() instanceof VisualProperty
 		    && (prop.getDisplayName().contains("Mapping Type") == false)
 		    && (prop.getValue() != null)
 		    && (prop.getValue().toString().startsWith("Please select") == false)) {
@@ -3640,7 +3371,7 @@
 				}
 			}
 
-			VisualPropertyType type = ((VisualPropertyType) prop.getHiddenObject());
+			VisualProperty type = ((VisualProperty) prop.getHiddenObject());
 
 			Class dataType = type.getDataType();
 
@@ -3655,7 +3386,7 @@
 				series.setEnabled(true);
 			}
 
-			if ((type == VisualPropertyType.NODE_WIDTH) || (type == VisualPropertyType.NODE_HEIGHT)) {
+			if (type.getName().equals("NODE_WIDTH") || type.getName().equals("NODE_HEIGHT")) {
 				fit.setEnabled(true);
 			}
 		}
@@ -3697,6 +3428,7 @@
 	 *            DOCUMENT ME!
 	 */
 	public void stateChanged(ChangeEvent e) {
+		System.out.println("vizmappermainpanel: statechanged"+e);
 		final String selectedName = (String) vsNameComboBox.getSelectedItem();
 		final String currentName = vmm.getVisualStyle().getName();
 		
Index: application/src/main/java/cytoscape/visual/ui/EditorDisplayer.java
===================================================================
--- application/src/main/java/cytoscape/visual/ui/EditorDisplayer.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/visual/ui/EditorDisplayer.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -41,17 +41,16 @@
 import java.awt.Font;
 import java.awt.Frame;
 
-import javax.swing.JColorChooser;
 import javax.swing.JDialog;
 import javax.swing.JOptionPane;
 
 import cytoscape.Cytoscape;
 import cytoscape.util.CyColorChooser;
-import org.cytoscape.vizmap.ArrowShape;
+
+import org.cytoscape.view.DiscreteValue;
+import org.cytoscape.view.VisualProperty;
 import org.cytoscape.vizmap.LabelPosition;
-import org.cytoscape.vizmap.LineStyle;
-import org.cytoscape.vizmap.NodeShape;
-import org.cytoscape.vizmap.VisualPropertyType;
+
 import cytoscape.visual.ui.editors.continuous.C2CMappingEditor;
 import cytoscape.visual.ui.editors.continuous.C2DMappingEditor;
 import cytoscape.visual.ui.editors.continuous.GradientEditorPanel;
@@ -82,26 +81,20 @@
 	                new Object[] { Cytoscape.getDesktop(), "Please enter new text value:" },
 	                String.class), 
 	DISCRETE_SHAPE(ValueSelectDialog.class, "showDialog",
-	               new Class[] { VisualPropertyType.class, JDialog.class },
-	               new Object[] { VisualPropertyType.NODE_SHAPE, null }, NodeShape.class), 
-	DISCRETE_ARROW_SHAPE(ValueSelectDialog.class, "showDialog",
-	                     new Class[] { VisualPropertyType.class, JDialog.class },
-	                     new Object[] { VisualPropertyType.EDGE_SRCARROW_SHAPE, null }, ArrowShape.class), 
-	DISCRETE_LINE_STYLE(ValueSelectDialog.class, "showDialog",
-	                   new Class[] { VisualPropertyType.class, JDialog.class },
-	                   new Object[] { VisualPropertyType.EDGE_LINE_STYLE, null }, LineStyle.class), 
+	               new Class[] { VisualProperty.class, JDialog.class },
+	               new Object[] { null, null }, DiscreteValue.class), 
 	DISCRETE_LABEL_POSITION(PopupLabelPositionChooser.class, "showDialog",
 	                        new Class[] { Frame.class, LabelPosition.class },
 	                        new Object[] { Cytoscape.getDesktop(), null }, LabelPosition.class), 
 	CONTINUOUS_COLOR(GradientEditorPanel.class, "showDialog",
-	                 new Class[] { int.class, int.class, String.class, VisualPropertyType.class },
+	                 new Class[] { int.class, int.class, String.class, VisualProperty.class },
 	                 new Object[] { 450, 180, "Gradient Editor", null }, Color.class), 
 	CONTINUOUS_CONTINUOUS(C2CMappingEditor.class, "showDialog",
-	                      new Class[] { int.class, int.class, String.class, VisualPropertyType.class },
+	                      new Class[] { int.class, int.class, String.class, VisualProperty.class },
 	                      new Object[] { 450, 250, "Continuous-Continuous Editor", null },
 	                      Number.class), 
 	CONTINUOUS_DISCRETE(C2DMappingEditor.class, "showDialog",
-	                    new Class[] { int.class, int.class, String.class, VisualPropertyType.class },
+	                    new Class[] { int.class, int.class, String.class, VisualProperty.class },
 	                    new Object[] { 450, 200, "Continuous-Discrete Editor", null }, Object.class);
 	private Class chooserClass;
 	private String command;
@@ -182,22 +175,30 @@
 	 *
 	 * @return DOCUMENT ME!
 	 */
-	public static EditorDisplayer getEditor(final VisualPropertyType type, final EditorType editor) {
+	public static EditorDisplayer getEditor(final VisualProperty type, final EditorType editor) {
 		final Class dataType = type.getDataType();
 		for (EditorDisplayer command : values()) {
 			if ((dataType == command.getCompatibleClass())
 			    && (((editor == EditorType.CONTINUOUS)
 			        && command.toString().startsWith(EditorType.CONTINUOUS.name()))
 			       || ((editor == EditorType.DISCRETE)
-			          && command.toString().startsWith(EditorType.DISCRETE.name()))))
+			          && command.toString().startsWith(EditorType.DISCRETE.name())))){
+				if (dataType == DiscreteValue.class){
+					// FIXME: could this be done better?
+					// hack: have to set the parameter correctly:
+					command.parameters[0]=type;
+				}
 				return command;
+				
+			}
+				
 		}
 
 		
 		/*
 		 * if not found in the loop above, this might be a C2DEditor.
 		 */
-		
+		System.out.println("returning default");
 		return EditorDisplayer.CONTINUOUS_DISCRETE;
 	}
 }
Index: application/src/main/java/cytoscape/visual/ui/NodeBypass.java
===================================================================
--- application/src/main/java/cytoscape/visual/ui/NodeBypass.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/visual/ui/NodeBypass.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -46,7 +46,8 @@
 import javax.swing.JMenuItem;
 
 import cytoscape.Cytoscape;
-import org.cytoscape.vizmap.VisualPropertyType;
+import org.cytoscape.view.VisualProperty;
+import org.cytoscape.view.VisualPropertyCatalog;
 
 
 class NodeBypass extends VizMapBypass {
@@ -60,7 +61,7 @@
 		// horrible, horrible hack
 		BypassHack.setCurrentObject(n);
 
-		for (VisualPropertyType type : VisualPropertyType.getNodeVisualPropertyList())
+		for (VisualProperty type : VisualPropertyCatalog.getNodeVisualPropertyList())
 			addMenuItem(menu, type);
 
 		menu.addSeparator();
@@ -73,8 +74,8 @@
 	protected List<String> getBypassNames() {
 		List<String> l = new ArrayList<String>();
 
-		for (VisualPropertyType type : VisualPropertyType.getNodeVisualPropertyList())
-			l.add(type.getBypassAttrName());
+		for (VisualProperty type : VisualPropertyCatalog.getNodeVisualPropertyList())
+			l.add(type.getName());
 
 		return l;
 	}
Index: application/src/main/java/cytoscape/visual/ui/PopupLabelPositionChooser.java
===================================================================
--- application/src/main/java/cytoscape/visual/ui/PopupLabelPositionChooser.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/visual/ui/PopupLabelPositionChooser.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -39,7 +39,6 @@
 import cytoscape.Cytoscape;
 
 import org.cytoscape.vizmap.ObjectToString;
-import org.cytoscape.vizmap.VisualPropertyType;
 import org.cytoscape.vizmap.LabelPosition;
 import org.cytoscape.vizmap.LabelPlacerGraphic;
 
@@ -177,8 +176,7 @@
 			GraphObject go = BypassHack.getCurrentObject();
 			if ( go != null ) {
 				String val = ObjectToString.getStringValue(newlp);
-				Cytoscape.getNodeAttributes().setAttribute(go.getIdentifier(), 
-				                   VisualPropertyType.NODE_LABEL_POSITION.getBypassAttrName(), val);
+				Cytoscape.getNodeAttributes().setAttribute(go.getIdentifier(), "NODE_LABEL_POSITION", val);
 				Cytoscape.redrawGraph(Cytoscape.getVisualMappingManager().getNetworkView());
 			}
 		}
Index: application/src/main/java/cytoscape/visual/ui/LegendDialog.java
===================================================================
--- application/src/main/java/cytoscape/visual/ui/LegendDialog.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/visual/ui/LegendDialog.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -3,16 +3,13 @@
  */
 package cytoscape.visual.ui;
 
-import org.cytoscape.vizmap.EdgeAppearanceCalculator;
-import org.cytoscape.vizmap.NodeAppearanceCalculator;
-import org.cytoscape.vizmap.VisualPropertyType;
 import org.cytoscape.vizmap.VisualStyle;
-
 import org.cytoscape.vizmap.calculators.Calculator;
-
 import org.cytoscape.vizmap.mappings.ObjectMapping;
 import org.cytoscape.vizmap.mappings.PassThroughMapping;
 
+import org.cytoscape.view.VisualProperty;
+
 import org.freehep.util.export.ExportDialog;
 
 import java.awt.Color;
@@ -23,6 +20,7 @@
 import java.awt.event.ActionEvent;
 import java.awt.event.ActionListener;
 
+import java.util.ArrayList;
 import java.util.List;
 
 import javax.swing.BoxLayout;
@@ -84,11 +82,12 @@
 	public static JPanel generateLegendPanel(VisualStyle visualStyle) {
 		final JPanel legend = new JPanel();
 
+		/*
 		final NodeAppearanceCalculator nac = visualStyle.getNodeAppearanceCalculator();
 		final List<Calculator> nodeCalcs = nac.getCalculators();
 		final EdgeAppearanceCalculator eac = visualStyle.getEdgeAppearanceCalculator();
 		final List<Calculator> edgeCalcs = eac.getCalculators();
-
+		 */
 		ObjectMapping om;
 
 		/*
@@ -101,22 +100,25 @@
 		                                  "Visual Legend for " + visualStyle.getName(),
 		                                  TitledBorder.DEFAULT_JUSTIFICATION, TitledBorder.CENTER,
 		                                  new Font("SansSerif", Font.BOLD, 16), Color.DARK_GRAY));
-
-		for (Calculator calc : nodeCalcs) {
+		ArrayList<Calculator> nodeCalculators = new ArrayList<Calculator>();
+		ArrayList<Calculator> edgeCalculators = new ArrayList<Calculator>();
+		
+		for (Calculator calc : visualStyle.getNodeCalculators()) {
 			// AAARGH
+			/* FIXME
 			if (nac.getNodeSizeLocked()) {
-				if (calc.getVisualPropertyType() == VisualPropertyType.NODE_WIDTH)
+				if (calc.getVisualProperty().getName().equals("NODE_WIDTH"))
 					continue;
-				else if (calc.getVisualPropertyType() == VisualPropertyType.NODE_HEIGHT)
+				else if (calc.getVisualProperty().getName().equals("NODE_HEIGHT"))
 					continue;
 			} else {
-				if (calc.getVisualPropertyType() == VisualPropertyType.NODE_SIZE)
+				if (calc.getVisualProperty().getName().equals("NODE_SIZE"))
 					continue;
 			}
-
+			 */
 			om = calc.getMapping(0);
 
-			JPanel mleg = om.getLegend(calc.getVisualPropertyType());
+			JPanel mleg = om.getLegend(calc.getVisualProperty());
 
 			// Add passthrough mappings to the top since they don't
 			// display anything besides the title.
@@ -131,10 +133,10 @@
 
 		int top = legend.getComponentCount();
 
-		for (Calculator calc : edgeCalcs) {
+		for (Calculator calc : visualStyle.getEdgeCalculators()) {
 			om = calc.getMapping(0);
 
-			JPanel mleg = om.getLegend(calc.getVisualPropertyType());
+			JPanel mleg = om.getLegend(calc.getVisualProperty());
 
 			// Add passthrough mappings to the top since they don't
 			// display anything besides the title.
Index: application/src/main/java/cytoscape/visual/ui/EditorFactory.java
===================================================================
--- application/src/main/java/cytoscape/visual/ui/EditorFactory.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/visual/ui/EditorFactory.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -39,14 +39,14 @@
 import cytoscape.visual.ui.EditorDisplayer.EditorType;
 import cytoscape.visual.ui.editors.continuous.ContinuousMappingEditorPanel;
 
-import org.cytoscape.vizmap.VisualPropertyType;
+import org.cytoscape.view.VisualProperty;
 
 import java.lang.reflect.*;
 
 
 public class EditorFactory {
 
-	private static Object showEditor(EditorDisplayer action, VisualPropertyType type)
+	private static Object showEditor(EditorDisplayer action, VisualProperty type)
 	    throws IllegalArgumentException, IllegalAccessException, InvocationTargetException,
 	               SecurityException, NoSuchMethodException {
 		Method method = action.getActionClass()
@@ -59,7 +59,7 @@
 		if ((ret != null) && ret instanceof ContinuousMappingEditorPanel)
 			return ret;
 		
-		else if ((ret != null) && type == VisualPropertyType.EDGE_LINE_WIDTH) {
+		else if ((ret != null) && type.getName().equals("EDGE_LINE_WIDTH")) {
 			try {
 				ret = Float.valueOf(((String)ret));
 			} catch (NumberFormatException e){
@@ -76,13 +76,13 @@
 		}
 		
 		// If size, it should be greater than 0.  Otherwise, 1 will be set.
-		if((type.name()).toUpperCase().endsWith("WIDTH") || (type.name()).toUpperCase().endsWith("SIZE")) {
+		if((type.getName()).toUpperCase().endsWith("WIDTH") || (type.getName()).toUpperCase().endsWith("SIZE")) {
 			if(((Number)ret).doubleValue() < 0) {
 				ret = 1f;
 			}
 		}
 		
-		if((type.name()).toUpperCase().endsWith("OPACITY")) {
+		if((type.getName()).toUpperCase().endsWith("OPACITY")) {
 			if (((Number)ret).doubleValue() > 255) {
 				ret = 255d;
 			} else if(((Number)ret).doubleValue() < 0) {
@@ -101,7 +101,7 @@
 	 *
 	 * @throws Exception DOCUMENT ME!
 	 */
-	public static Object showDiscreteEditor(VisualPropertyType type) throws Exception {
+	public static Object showDiscreteEditor(VisualProperty type) throws Exception {
 		return showEditor(EditorDisplayer.getEditor(type, EditorType.DISCRETE), type);
 	}
 	
@@ -114,7 +114,7 @@
 	 * </p>
 	 * @throws Exception DOCUMENT ME!
 	 */
-	public static Object showContinuousEditor(VisualPropertyType type) throws Exception {
+	public static Object showContinuousEditor(VisualProperty type) throws Exception {
 		final EditorDisplayer editor = EditorDisplayer.getEditor(type, EditorType.CONTINUOUS);
 
 		if (editor == EditorDisplayer.CONTINUOUS_COLOR)
Index: application/src/main/java/cytoscape/visual/ui/DefaultAppearenceBuilder.java
===================================================================
--- application/src/main/java/cytoscape/visual/ui/DefaultAppearenceBuilder.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/visual/ui/DefaultAppearenceBuilder.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -37,10 +37,8 @@
 import cytoscape.Cytoscape;
 
 import cytoscape.util.CyColorChooser;
-import org.cytoscape.vizmap.GlobalAppearanceCalculator;
-import org.cytoscape.vizmap.NodeAppearanceCalculator;
-import org.cytoscape.vizmap.VisualPropertyType;
-import static org.cytoscape.vizmap.VisualPropertyType.*;
+import org.cytoscape.view.VisualProperty;
+import org.cytoscape.view.VisualPropertyCatalog;
 
 import org.cytoscape.vizmap.icon.VisualPropertyIcon;
 
@@ -99,17 +97,11 @@
  */
 public class DefaultAppearenceBuilder extends JDialog {
 	private final static long serialVersionUID = 1202339876675416L;
-	private static final Set<VisualPropertyType> EDGE_PROPS;
-	private static final Set<VisualPropertyType> NODE_PROPS;
 	private static DefaultAppearenceBuilder dab = null;
-	private final NodeAppearanceCalculator nac = Cytoscape.getVisualMappingManager().getVisualStyle()
-	                                                      .getNodeAppearanceCalculator();
+	
+	//private final NodeAppearanceCalculator nac = Cytoscape.getVisualMappingManager().getVisualStyle()
+	//                                                      .getNodeAppearanceCalculator();
 
-	static {
-		EDGE_PROPS = new TreeSet<VisualPropertyType>(VisualPropertyType.getEdgeVisualPropertyList());
-		NODE_PROPS = new TreeSet<VisualPropertyType>(VisualPropertyType.getNodeVisualPropertyList());
-	}
-
 	/**
 	 * Creates a new DefaultAppearenceBuilder object.
 	 *
@@ -141,7 +133,7 @@
 		dab.setLocationRelativeTo(parent);
 		dab.setSize(900, 400);
 		dab.lockSize();
-		dab.lockNodeSizeCheckBox.setSelected(dab.nac.getNodeSizeLocked());
+		dab.lockNodeSizeCheckBox.setSelected(false); // FIXME: dab.nac.getNodeSizeLocked());
 		dab.mainView.updateView();
 		dab.setLocationRelativeTo(Cytoscape.getDesktop());
 		dab.setVisible(true);
@@ -158,9 +150,8 @@
 		if(dab == null)
 			dab = new DefaultAppearenceBuilder(Cytoscape.getDesktop(), true);
 		Cytoscape.getVisualMappingManager().setVisualStyle(vsName);
-		dab.mainView.updateBackgroungColor(Cytoscape.getVisualMappingManager().getVisualStyle()
-		                                            .getGlobalAppearanceCalculator()
-		                                            .getDefaultBackgroundColor());
+		dab.mainView.updateBackgroungColor((Color) Cytoscape.getVisualMappingManager().getVisualStyle().getGlobalProperty("backgroundColor"));
+		                                            
 		dab.mainView.updateView();
 
 		return dab.getPanel();
@@ -260,7 +251,7 @@
 		lockNodeSizeCheckBox.setText("Lock Node Width/Height");
 		lockNodeSizeCheckBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
 		lockNodeSizeCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));
-		lockNodeSizeCheckBox.setSelected(nac.getNodeSizeLocked());
+		lockNodeSizeCheckBox.setSelected(false);//FIXME: nac.getNodeSizeLocked());
 		lockNodeSizeCheckBox.addActionListener(new ActionListener() {
 				public void actionPerformed(ActionEvent arg0) {
 					lockSize();
@@ -358,10 +349,10 @@
 					list = edgeList;
 				}
 
-				newValue = VizMapperMainPanel.showValueSelectDialog((VisualPropertyType) list
+				newValue = VizMapperMainPanel.showValueSelectDialog((VisualProperty) list
 				                                                                                                                                                                                                                                                                                                                                                              .getSelectedValue(),
 				                                                    this);
-				VizMapperMainPanel.apply(newValue, (VisualPropertyType) list.getSelectedValue());
+				VizMapperMainPanel.apply(newValue, (VisualProperty) list.getSelectedValue());
 			} catch (Exception e1) {
 				e1.printStackTrace();
 			}
@@ -378,9 +369,10 @@
 			final String selected = (String) globalList.getSelectedValue();
 			Color newColor = CyColorChooser.showDialog(this, "Choose new color.", Color.white);
 
+			//FIXME: here the string 'selected' will contin the global property to set!!
+			System.out.println("FIXME: not setting global property:"+selected);
 			try {
-				Cytoscape.getVisualMappingManager().getVisualStyle().getGlobalAppearanceCalculator()
-				         .setDefaultColor(selected, newColor);
+				Cytoscape.getVisualMappingManager().getVisualStyle().setGlobalProperty("defaultColor", newColor);
 			} catch (Exception e1) {
 				e1.printStackTrace();
 			}
@@ -389,7 +381,7 @@
 			Cytoscape.redrawGraph(Cytoscape.getVisualMappingManager().getNetworkView());
 
 			if (selected.equals("Background Color")) {
-				Cytoscape.getVisualMappingManager().applyGlobalAppearances();
+				//FIXME: Cytoscape.getVisualMappingManager().getVisualStyle().apply(mainView);
 				mainView.updateBackgroungColor(newColor);
 			}
 
@@ -433,20 +425,23 @@
 		DefaultListModel model = new DefaultListModel();
 		nodeList.setModel(model);
 
-		for (VisualPropertyType type : NODE_PROPS) {
-			final VisualPropertyIcon nodeIcon = (VisualPropertyIcon) (type.getVisualProperty()
-			                                                              .getDefaultIcon());
-			nodeIcon.setLeftPadding(15);
-			model.addElement(type);
-			nodeIcons.add(nodeIcon);
+		for (VisualProperty type : VisualPropertyCatalog.getNodeVisualPropertyList()) {
+			final VisualPropertyIcon nodeIcon = (VisualPropertyIcon) (type.getDefaultIcon());
+			if (nodeIcon != null){
+				nodeIcon.setLeftPadding(15);
+				model.addElement(type);
+				nodeIcons.add(nodeIcon);
+			} else {
+				System.out.println("warning: default Icon for VisualProperty is null: "+type);
+				System.out.println("VisualProperty name: "+type.getName());
+			}
 		}
 
 		DefaultListModel eModel = new DefaultListModel();
 		edgeList.setModel(eModel);
 
-		for (VisualPropertyType type : EDGE_PROPS) {
-			final VisualPropertyIcon edgeIcon = (VisualPropertyIcon) (type.getVisualProperty()
-			                                                              .getDefaultIcon());
+		for (VisualProperty type : VisualPropertyCatalog.getEdgeVisualPropertyList()) {
+			final VisualPropertyIcon edgeIcon = (VisualPropertyIcon) (type.getDefaultIcon());
 
 			if (edgeIcon != null) {
 				edgeIcon.setLeftPadding(15);
@@ -455,11 +450,11 @@
 			}
 		}
 
-		GlobalAppearanceCalculator gac = Cytoscape.getVisualMappingManager().getVisualStyle()
-		                                          .getGlobalAppearanceCalculator();
+		//GlobalAppearanceCalculator gac = Cytoscape.getVisualMappingManager().getVisualStyle()
+		//                                          .getGlobalAppearanceCalculator();
 		DefaultListModel gModel = new DefaultListModel();
 		globalList.setModel(gModel);
-
+		/* FIXME FIXME FIXME 
 		for (String name : gac.getGlobalAppearanceNames()) {
 			try {
 				globalIcons.add(new GlobalIcon(name, gac.getDefaultColor(name)));
@@ -469,7 +464,7 @@
 
 			gModel.addElement(name);
 		}
-
+		 */
 		nodeList.setCellRenderer(new VisualPropCellRenderer(nodeIcons));
 		edgeList.setCellRenderer(new VisualPropCellRenderer(edgeIcons));
 		globalList.setCellRenderer(new VisualPropCellRenderer(globalIcons));
@@ -479,18 +474,19 @@
 	}
 
 	private void lockSize() {
+		/* FIXME: punted
 		if (lockNodeSizeCheckBox.isSelected()) {
-			NODE_PROPS.remove(NODE_WIDTH);
-			NODE_PROPS.remove(NODE_HEIGHT);
-			NODE_PROPS.add(NODE_SIZE);
-			nac.setNodeSizeLocked(true);
+			NODE_PROPS.remove(VisualPropertyCatalog.getVisualProperty("NODE_WIDTH"));
+			NODE_PROPS.remove(VisualPropertyCatalog.getVisualProperty("NODE_HEIGHT"));
+			NODE_PROPS.add(VisualPropertyCatalog.getVisualProperty("NODE_SIZE"));
+			//FIXME nac.setNodeSizeLocked(true);
 		} else {
-			NODE_PROPS.add(NODE_WIDTH);
-			NODE_PROPS.add(NODE_HEIGHT);
-			NODE_PROPS.remove(NODE_SIZE);
-			nac.setNodeSizeLocked(false);
+			NODE_PROPS.add(VisualPropertyCatalog.getVisualProperty("NODE_WIDTH"));
+			NODE_PROPS.add(VisualPropertyCatalog.getVisualProperty("NODE_HEIGHT"));
+			NODE_PROPS.remove(VisualPropertyCatalog.getVisualProperty("NODE_SIZE"));
+			//FIXME nac.setNodeSizeLocked(false);
 		}
-
+		 */
 		buildList();
 		mainView.updateView();
 		repaint();
@@ -526,10 +522,9 @@
 			this.setVerticalAlignment(SwingConstants.CENTER);
 			this.setIconTextGap(55);
 
-			if (value instanceof VisualPropertyType
-			    && (((VisualPropertyType) value).getDataType() == String.class)) {
-				final Object defVal = ((VisualPropertyType) value).getDefault(Cytoscape.getVisualMappingManager()
-				                                                                       .getVisualStyle());
+			if (value instanceof VisualProperty
+			    && (((VisualProperty) value).getDataType() == String.class)) {
+				final Object defVal = Cytoscape.getVisualMappingManager().getVisualStyle().getDefaultValue((VisualProperty)value); 
 
 				if (defVal != null) {
 					this.setToolTipText((String) defVal);
Index: application/src/main/java/cytoscape/visual/ui/EdgeBypass.java
===================================================================
--- application/src/main/java/cytoscape/visual/ui/EdgeBypass.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/visual/ui/EdgeBypass.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -41,7 +41,8 @@
 import org.cytoscape.attributes.CyAttributes;
 
 import org.cytoscape.vizmap.VisualMappingManager;
-import org.cytoscape.vizmap.VisualPropertyType;
+import org.cytoscape.view.VisualProperty;
+import org.cytoscape.view.VisualPropertyCatalog;
 
 import org.cytoscape.Edge;
 
@@ -66,7 +67,7 @@
 		// horrible, horrible hack
 		BypassHack.setCurrentObject( e );
 
-		for ( VisualPropertyType type : VisualPropertyType.getEdgeVisualPropertyList() ) 
+		for ( VisualProperty type : VisualPropertyCatalog.getEdgeVisualPropertyList() ) 
 			addMenuItem(menu, type);
 
         addResetAllMenuItem(menu);
@@ -77,8 +78,8 @@
     protected List<String> getBypassNames() {
 		List<String> l = new ArrayList<String>();
 
-		for ( VisualPropertyType type : VisualPropertyType.getEdgeVisualPropertyList() )
-			l.add( type.getBypassAttrName() );
+		for ( VisualProperty type : VisualPropertyCatalog.getEdgeVisualPropertyList() )
+			l.add( type.getName() );
 		
 		return l;
     }
Index: application/src/main/java/cytoscape/visual/ui/VizMapBypass.java
===================================================================
--- application/src/main/java/cytoscape/visual/ui/VizMapBypass.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/visual/ui/VizMapBypass.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -50,7 +50,7 @@
 import cytoscape.Cytoscape;
 import org.cytoscape.attributes.CyAttributes;
 import org.cytoscape.vizmap.VisualMappingManager;
-import org.cytoscape.vizmap.VisualPropertyType;
+import org.cytoscape.view.VisualProperty;
 import org.cytoscape.vizmap.ObjectToString;
 
 
@@ -84,14 +84,14 @@
 		menu.add(jmi);
 	}
 
-	protected void addResetMenuItem(JMenu menu, final VisualPropertyType type) {
+	protected void addResetMenuItem(JMenu menu, final VisualProperty type) {
 		JMenuItem jmi = new JMenuItem(new AbstractAction("[ Reset " + type.getName() + " ]") {
 	private final static long serialVersionUID = 1202339876709140L;
 				public void actionPerformed(ActionEvent e) {
 					String id = graphObj.getIdentifier();
 
-					if (attrs.hasAttribute(id, type.getBypassAttrName()))
-						attrs.deleteAttribute(id, type.getBypassAttrName());
+					if (attrs.hasAttribute(id, type.getName()))
+						attrs.deleteAttribute(id, type.getName());
 
 					Cytoscape.redrawGraph(vmm.getNetworkView());
 					BypassHack.finished();
@@ -100,7 +100,7 @@
 		menu.add(jmi);
 	}
 
-	protected void addMenuItem(JMenu menu, final VisualPropertyType type) {
+	protected void addMenuItem(JMenu menu, final VisualProperty type) {
 		final JMenuItem jmi = new JCheckBoxMenuItem(new AbstractAction(type.getName()) {
 	private final static long serialVersionUID = 1202339876717506L;
 				public void actionPerformed(ActionEvent e) {
@@ -117,7 +117,7 @@
 						return;
 
 					String val = ObjectToString.getStringValue(obj);
-					attrs.setAttribute(graphObj.getIdentifier(), type.getBypassAttrName(), val);
+					attrs.setAttribute(graphObj.getIdentifier(), type.getName(), val);
 					Cytoscape.redrawGraph(vmm.getNetworkView());
 					BypassHack.finished();
 				}
@@ -126,18 +126,19 @@
 		menu.add(jmi);
 		
 		// Check node size lock state 
-		if(type.equals(VisualPropertyType.NODE_SIZE)) {
+		/* FIXME FIXME
+		if(type.getName().equals("NODE_SIZE")) {
 			if(Cytoscape.getVisualMappingManager().getVisualStyle().getNodeAppearanceCalculator().getNodeSizeLocked() == false) {
 				jmi.setEnabled(false);
 			}
-		} else if(type.equals(VisualPropertyType.NODE_WIDTH) || type.equals(VisualPropertyType.NODE_HEIGHT)) {
+		} else if(type.getName().equals("NODE_WIDTH") || type.getName().equals("NODE_HEIGHT")) {
 			if(Cytoscape.getVisualMappingManager().getVisualStyle().getNodeAppearanceCalculator().getNodeSizeLocked() == true) {
 				jmi.setEnabled(false);
 			}
 		}
-
+		 */
 		String attrString = attrs.getStringAttribute(graphObj.getIdentifier(),
-		                                             type.getBypassAttrName());
+		                                             type.getName());
 
 		if ((attrString == null) || (attrString.length() == 0))
 			jmi.setSelected(false);
Index: application/src/main/java/cytoscape/visual/ui/editors/discrete/NodeRendererCellRenderer.java
===================================================================
--- application/src/main/java/cytoscape/visual/ui/editors/discrete/NodeRendererCellRenderer.java	(.../trunk)	(revision 0)
+++ application/src/main/java/cytoscape/visual/ui/editors/discrete/NodeRendererCellRenderer.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -0,0 +1,129 @@
+
+/*
+ Copyright (c) 2006, 2007, The Cytoscape Consortium (www.cytoscape.org)
+
+ The Cytoscape Consortium is:
+ - Institute for Systems Biology
+ - University of California San Diego
+ - Memorial Sloan-Kettering Cancer Center
+ - Institut Pasteur
+ - Agilent Technologies
+
+ This library is free software; you can redistribute it and/or modify it
+ under the terms of the GNU Lesser General Public License as published
+ by the Free Software Foundation; either version 2.1 of the License, or
+ any later version.
+
+ This library is distributed in the hope that it will be useful, but
+ WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF
+ MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  The software and
+ documentation provided hereunder is on an "as is" basis, and the
+ Institute for Systems Biology and the Whitehead Institute
+ have no obligations to provide maintenance, support,
+ updates, enhancements or modifications.  In no event shall the
+ Institute for Systems Biology and the Whitehead Institute
+ be liable to any party for direct, indirect, special,
+ incidental or consequential damages, including lost profits, arising
+ out of the use of this software and its documentation, even if the
+ Institute for Systems Biology and the Whitehead Institute
+ have been advised of the possibility of such damage.  See
+ the GNU Lesser General Public License for more details.
+
+ You should have received a copy of the GNU Lesser General Public License
+ along with this library; if not, write to the Free Software Foundation,
+ Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+*/
+
+package cytoscape.visual.ui.editors.discrete;
+
+import com.l2fprod.common.swing.renderer.DefaultCellRenderer;
+
+import org.cytoscape.view.VisualProperty;
+
+import org.cytoscape.vizmap.icon.VisualPropertyIcon;
+
+import java.awt.Component;
+
+import java.util.Map;
+
+import javax.swing.Icon;
+import javax.swing.JTable;
+
+
+/**
+ * DOCUMENT ME!
+ *
+ * @author $author$
+ */
+public class NodeRendererCellRenderer extends DefaultCellRenderer {
+	private final static long serialVersionUID = 1202339868999601L;
+	private final Map<Object, Icon> icons;
+	private VisualProperty type;
+
+	/**
+	 * Creates a new NodeRendererCellRenderer object.
+	 *
+	 * @param type DOCUMENT ME!
+	 */
+	public NodeRendererCellRenderer(VisualProperty type) {
+		this.type = type;
+		icons = type.getIconSet();
+	}
+
+	/**
+	     * DOCUMENT ME!
+	     *
+	     * @param table
+	     *            DOCUMENT ME!
+	     * @param value
+	     *            DOCUMENT ME!
+	     * @param isSelected
+	     *            DOCUMENT ME!
+	     * @param hasFocus
+	     *            DOCUMENT ME!
+	     * @param row
+	     *            DOCUMENT ME!
+	     * @param column
+	     *            DOCUMENT ME!
+	     *
+	     * @return DOCUMENT ME!
+	     */
+	public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected,
+	                                               boolean hasFocus, int row, int column) {
+		if (isSelected) {
+			setBackground(table.getSelectionBackground());
+			setForeground(table.getSelectionForeground());
+		} else {
+			setBackground(table.getBackground());
+			setForeground(table.getForeground());
+		}
+
+		if (value != null) {
+			final VisualPropertyIcon shapeIcon = (VisualPropertyIcon) icons.get(value);
+
+			if (shapeIcon != null) {
+				if (type.getName().equals("EDGE_SRCARROW_SHAPE")
+				    || type.getName().equals("EDGE_TGTARROW_SHAPE")) {
+					shapeIcon.setIconHeight(16);
+					shapeIcon.setIconWidth(40);
+					shapeIcon.setBottomPadding(-6);
+				} else {
+					shapeIcon.setIconHeight(16);
+					shapeIcon.setIconWidth(16);
+				}
+
+				this.setIcon(shapeIcon);
+			}
+
+			this.setIconTextGap(10);
+			this.setText(value.toString());
+			System.out.println("icon: setting text:"+value.toString());
+		} else {
+			System.out.println("icon: setting null");
+			this.setIcon(null);
+			this.setText(null);
+		}
+
+		return this;
+	}
+}
Index: application/src/main/java/cytoscape/visual/ui/editors/discrete/ShapeCellRenderer.java
===================================================================
--- application/src/main/java/cytoscape/visual/ui/editors/discrete/ShapeCellRenderer.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/visual/ui/editors/discrete/ShapeCellRenderer.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -38,7 +38,7 @@
 
 import com.l2fprod.common.swing.renderer.DefaultCellRenderer;
 
-import org.cytoscape.vizmap.VisualPropertyType;
+import org.cytoscape.view.VisualProperty;
 
 import org.cytoscape.vizmap.icon.VisualPropertyIcon;
 
@@ -58,16 +58,16 @@
 public class ShapeCellRenderer extends DefaultCellRenderer {
 	private final static long serialVersionUID = 1202339868999601L;
 	private final Map<Object, Icon> icons;
-	private VisualPropertyType type;
+	private VisualProperty type;
 
 	/**
 	 * Creates a new ShapeCellRenderer object.
 	 *
 	 * @param type DOCUMENT ME!
 	 */
-	public ShapeCellRenderer(VisualPropertyType type) {
+	public ShapeCellRenderer(VisualProperty type) {
 		this.type = type;
-		icons = type.getVisualProperty().getIconSet();
+		icons = type.getIconSet();
 	}
 
 	/**
@@ -102,8 +102,8 @@
 			final VisualPropertyIcon shapeIcon = (VisualPropertyIcon) icons.get(value);
 
 			if (shapeIcon != null) {
-				if (type.equals(VisualPropertyType.EDGE_SRCARROW_SHAPE)
-				    || type.equals(VisualPropertyType.EDGE_TGTARROW_SHAPE)) {
+				if (type.getName().equals("EDGE_SRCARROW_SHAPE")
+				    || type.getName().equals("EDGE_TGTARROW_SHAPE")) {
 					shapeIcon.setIconHeight(16);
 					shapeIcon.setIconWidth(40);
 					shapeIcon.setBottomPadding(-6);
Index: application/src/main/java/cytoscape/visual/ui/editors/discrete/LabelPositionCellRenderer.java
===================================================================
--- application/src/main/java/cytoscape/visual/ui/editors/discrete/LabelPositionCellRenderer.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/visual/ui/editors/discrete/LabelPositionCellRenderer.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -39,9 +39,10 @@
 import com.l2fprod.common.swing.renderer.DefaultCellRenderer; 
 
 import org.cytoscape.vizmap.LabelPosition; 
-import org.cytoscape.vizmap.VisualPropertyType;
-import org.cytoscape.vizmap.VisualProperty;
 
+import org.cytoscape.view.VisualProperty;
+import org.cytoscape.view.VisualPropertyCatalog;
+
 import java.awt.Component;
 
 import javax.swing.JLabel;
@@ -80,8 +81,8 @@
 
 		if ((value != null) && value instanceof LabelPosition) {
 			final LabelPosition lp = (LabelPosition) value;
-			final VisualProperty prop = VisualPropertyType.NODE_LABEL_POSITION
-			                                   .getVisualProperty();
+			final VisualProperty prop = VisualPropertyCatalog.getVisualProperty("NODE_LABEL_POSITION");
+
 			label.setIcon(prop.getIcon(lp));
 			label.setVerticalAlignment(SwingConstants.CENTER);
 			label.setHorizontalAlignment(SwingConstants.CENTER);
Index: application/src/main/java/cytoscape/visual/ui/editors/continuous/EditorValueRangeTracer.java
===================================================================
--- application/src/main/java/cytoscape/visual/ui/editors/continuous/EditorValueRangeTracer.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/visual/ui/editors/continuous/EditorValueRangeTracer.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -34,7 +34,8 @@
 */
 package cytoscape.visual.ui.editors.continuous;
 
-import org.cytoscape.vizmap.VisualPropertyType;
+import org.cytoscape.view.VisualProperty;
+import org.cytoscape.view.VisualPropertyCatalog;
 
 import java.util.HashMap;
 import java.util.Map;
@@ -80,12 +81,12 @@
 		}
 	}
 
-	private Map<VisualPropertyType, Range> rangeMap;
+	private Map<VisualProperty, Range> rangeMap;
 
 	private EditorValueRangeTracer() {
-		rangeMap = new HashMap<VisualPropertyType, Range>();
+		rangeMap = new HashMap<VisualProperty, Range>();
 
-		for (VisualPropertyType v : VisualPropertyType.values()) {
+		for (VisualProperty v : VisualPropertyCatalog.collectionOfVisualProperties()) {
 			Range r = new Range(0d, 0d);
 			rangeMap.put(v, r);
 		}
@@ -107,7 +108,7 @@
 	 *
 	 * @return  DOCUMENT ME!
 	 */
-	public Double getRange(VisualPropertyType t) {
+	public Double getRange(VisualProperty t) {
 		return rangeMap.get(t).getRange();
 	}
 
@@ -118,7 +119,7 @@
 	 *
 	 * @return  DOCUMENT ME!
 	 */
-	public Double getMin(VisualPropertyType t) {
+	public Double getMin(VisualProperty t) {
 		return rangeMap.get(t).getMin();
 	}
 
@@ -129,7 +130,7 @@
 	 *
 	 * @return  DOCUMENT ME!
 	 */
-	public Double getMax(VisualPropertyType t) {
+	public Double getMax(VisualProperty t) {
 		return rangeMap.get(t).getMax();
 	}
 
@@ -139,7 +140,7 @@
 	 * @param t DOCUMENT ME!
 	 * @param min DOCUMENT ME!
 	 */
-	public void setMin(VisualPropertyType t, Double min) {
+	public void setMin(VisualProperty t, Double min) {
 		rangeMap.get(t).setMin(min);
 	}
 
@@ -149,7 +150,7 @@
 	 * @param t DOCUMENT ME!
 	 * @param max DOCUMENT ME!
 	 */
-	public void setMax(VisualPropertyType t, Double max) {
+	public void setMax(VisualProperty t, Double max) {
 		rangeMap.get(t).setMax(max);
 	}
 }
Index: application/src/main/java/cytoscape/visual/ui/editors/continuous/ContinuousTrackRenderer.java
===================================================================
--- application/src/main/java/cytoscape/visual/ui/editors/continuous/ContinuousTrackRenderer.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/visual/ui/editors/continuous/ContinuousTrackRenderer.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -37,7 +37,7 @@
 import cytoscape.Cytoscape;
 import cytoscape.CytoscapeInit;
 
-import org.cytoscape.vizmap.VisualPropertyType;
+import org.cytoscape.view.VisualProperty;
 
 import org.cytoscape.vizmap.mappings.BoundaryRangeValues;
 import org.cytoscape.vizmap.mappings.ContinuousMapping;
@@ -111,7 +111,7 @@
 	private Map<Integer, Point> verticesList;
 	private int selectedIdx;
 	private Point dragOrigin;
-	private VisualPropertyType type;
+	private VisualProperty type;
 	private ContinuousMapping cMapping;
 	private String title;
 	private Number below;
@@ -128,19 +128,15 @@
 	 * @param below  DOCUMENT ME!
 	 * @param above  DOCUMENT ME!
 	 */
-	public ContinuousTrackRenderer(VisualPropertyType type, Number below, Number above) {
+	public ContinuousTrackRenderer(VisualProperty type, Number below, Number above) {
 		this.below = below;
 		this.above = above;
 		this.type = type;
 
 		if (type.isNodeProp())
-			cMapping = (ContinuousMapping) Cytoscape.getVisualMappingManager().getVisualStyle()
-			                                        .getNodeAppearanceCalculator()
-			                                        .getCalculator(type).getMapping(0);
+			cMapping = (ContinuousMapping) Cytoscape.getVisualMappingManager().getVisualStyle().getCalculator(type).getMapping(0);
 		else
-			cMapping = (ContinuousMapping) Cytoscape.getVisualMappingManager().getVisualStyle()
-			                                        .getEdgeAppearanceCalculator()
-			                                        .getCalculator(type).getMapping(0);
+			cMapping = (ContinuousMapping) Cytoscape.getVisualMappingManager().getVisualStyle().getCalculator(type).getMapping(0);
 
 		title = cMapping.getControllingAttributeName();
 
Index: application/src/main/java/cytoscape/visual/ui/editors/continuous/GradientEditorPanel.java
===================================================================
--- application/src/main/java/cytoscape/visual/ui/editors/continuous/GradientEditorPanel.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/visual/ui/editors/continuous/GradientEditorPanel.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -38,7 +38,7 @@
 
 import cytoscape.util.CyColorChooser;
 
-import org.cytoscape.vizmap.VisualPropertyType;
+import org.cytoscape.view.VisualProperty;
 
 import org.cytoscape.vizmap.mappings.BoundaryRangeValues;
 import org.cytoscape.vizmap.mappings.ContinuousMapping;
@@ -79,7 +79,7 @@
 	 * @param type
 	 *            DOCUMENT ME!
 	 */
-	public GradientEditorPanel(VisualPropertyType type) {
+	public GradientEditorPanel(VisualProperty type) {
 		super(type);
 		iconPanel.setVisible(false);
 		initSlider();
@@ -99,7 +99,7 @@
 	 * @param type DOCUMENT ME!
 	 */
 	public static Object showDialog(final int width, final int height, final String title,
-	                                VisualPropertyType type) {
+	                                VisualProperty type) {
 		editor = new GradientEditorPanel(type);
 		editor.setSize(new Dimension(width, height));
 		editor.setTitle(title);
@@ -121,7 +121,7 @@
 	 * @return  DOCUMENT ME!
 	 */
 	public static ImageIcon getLegend(final int width, final int height,
-	                                  final VisualPropertyType type) {
+	                                  final VisualProperty type) {
 		editor = new GradientEditorPanel(type);
 
 		CyGradientTrackRenderer rend = (CyGradientTrackRenderer) editor.slider
@@ -137,7 +137,7 @@
 	 * @return  DOCUMENT ME!
 	 */
 	public static ImageIcon getIcon(final int iconWidth, final int iconHeight,
-	                                VisualPropertyType type) {
+	                                VisualProperty type) {
 		editor = new GradientEditorPanel(type);
 
 		CyGradientTrackRenderer rend = (CyGradientTrackRenderer) editor.slider.getTrackRenderer();
Index: application/src/main/java/cytoscape/visual/ui/editors/continuous/YValueLegendPanel.java
===================================================================
--- application/src/main/java/cytoscape/visual/ui/editors/continuous/YValueLegendPanel.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/visual/ui/editors/continuous/YValueLegendPanel.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -13,9 +13,8 @@
 import javax.swing.JPanel;
 import javax.swing.SwingUtilities;
 
-import org.cytoscape.vizmap.VisualPropertyType;
+import org.cytoscape.view.VisualProperty;
 
-
 /**
  * DOCUMENT ME!
  *
@@ -23,14 +22,14 @@
   */
 public class YValueLegendPanel extends JPanel {
 	private final static long serialVersionUID = 1202339877453677L;
-    private VisualPropertyType type;
+    private VisualProperty type;
 
     /**
      * Creates a new IconPanel object.
      *
      * @param type DOCUMENT ME!
      */
-    public YValueLegendPanel(VisualPropertyType type) {
+    public YValueLegendPanel(VisualProperty type) {
         this.type = type;
         this.setPreferredSize(new Dimension());
     }
Index: application/src/main/java/cytoscape/visual/ui/editors/continuous/CyGradientTrackRenderer.java
===================================================================
--- application/src/main/java/cytoscape/visual/ui/editors/continuous/CyGradientTrackRenderer.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/visual/ui/editors/continuous/CyGradientTrackRenderer.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -34,7 +34,7 @@
 */
 package cytoscape.visual.ui.editors.continuous;
 
-import org.cytoscape.vizmap.VisualPropertyType;
+import org.cytoscape.view.VisualProperty;
 
 import org.jdesktop.swingx.JXMultiThumbSlider;
 import org.jdesktop.swingx.multislider.Thumb;
@@ -81,7 +81,7 @@
 	private Color below;
 	private Color above;
 	private String attrName;
-	private VisualPropertyType type;
+	private VisualProperty type;
 
 	/**
 	 * Creates a new GradientTrackRenderer object.
@@ -89,7 +89,7 @@
 	 * @param gradientPicker
 	 *            DOCUMENT ME!
 	 */
-	public CyGradientTrackRenderer(VisualPropertyType type, Color below, Color above, String title) {
+	public CyGradientTrackRenderer(VisualProperty type, Color below, Color above, String title) {
 		//checker_paint = ColorUtil.getCheckerPaint();
 		this.below = below;
 		this.above = above;
Index: application/src/main/java/cytoscape/visual/ui/editors/continuous/BelowAndAbovePanel.java
===================================================================
--- application/src/main/java/cytoscape/visual/ui/editors/continuous/BelowAndAbovePanel.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/visual/ui/editors/continuous/BelowAndAbovePanel.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -3,8 +3,9 @@
 import cytoscape.Cytoscape;
 
 import cytoscape.util.CyColorChooser;
-import org.cytoscape.vizmap.VisualPropertyType;
 
+import org.cytoscape.view.VisualProperty;
+
 import org.cytoscape.vizmap.mappings.BoundaryRangeValues;
 import org.cytoscape.vizmap.mappings.ContinuousMapping;
 
@@ -29,7 +30,7 @@
  */
 public class BelowAndAbovePanel extends JPanel {
 	private final static long serialVersionUID = 1202339876961477L;
-    private VisualPropertyType type;
+    private VisualProperty type;
     private Color boxColor;
     private boolean below;
     private Object value;
@@ -48,7 +49,7 @@
      * @param below
      *            DOCUMENT ME!
      */
-    public BelowAndAbovePanel(VisualPropertyType type, Color color,
+    public BelowAndAbovePanel(VisualProperty type, Color color,
         boolean below) {
         this.boxColor = color;
         this.below = below;
@@ -68,7 +69,7 @@
      * @param type DOCUMENT ME!
      * @param below DOCUMENT ME!
      */
-    public BelowAndAbovePanel(VisualPropertyType type, boolean below) {
+    public BelowAndAbovePanel(VisualProperty type, boolean below) {
         this(type, Color.DARK_GRAY, below);
     }
 
@@ -156,18 +157,7 @@
 
                 final ContinuousMapping cMapping;
 
-                if (type.isNodeProp())
-                    cMapping = (ContinuousMapping) Cytoscape.getVisualMappingManager()
-                                                            .getVisualStyle()
-                                                            .getNodeAppearanceCalculator()
-                                                            .getCalculator(type)
-                                                            .getMapping(0);
-                else
-                    cMapping = (ContinuousMapping) Cytoscape.getVisualMappingManager()
-                                                            .getVisualStyle()
-                                                            .getEdgeAppearanceCalculator()
-                                                            .getCalculator(type)
-                                                            .getMapping(0);
+                cMapping = (ContinuousMapping) Cytoscape.getVisualMappingManager().getVisualStyle().getCalculator(type).getMapping(0);
 
                 BoundaryRangeValues brv;
                 BoundaryRangeValues original;
Index: application/src/main/java/cytoscape/visual/ui/editors/continuous/ContinuousMappingEditorPanel.java
===================================================================
--- application/src/main/java/cytoscape/visual/ui/editors/continuous/ContinuousMappingEditorPanel.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/visual/ui/editors/continuous/ContinuousMappingEditorPanel.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -40,7 +40,7 @@
 import org.cytoscape.attributes.CountedIterator;
 import org.cytoscape.attributes.MultiHashMap;
 
-import org.cytoscape.vizmap.VisualPropertyType;
+import org.cytoscape.view.VisualProperty;
 
 import org.cytoscape.vizmap.calculators.Calculator;
 
@@ -100,7 +100,7 @@
 	 */
 	protected static final String BELOW_VALUE_CHANGED = "BELOW_VALUE_CHANGED";
 	protected static final String ABOVE_VALUE_CHANGED = "ABOVE_VALUE_CHANGED";
-	protected VisualPropertyType type;
+	protected VisualProperty type;
 	protected Calculator calculator;
 	protected ContinuousMapping mapping;
 	protected List<ContinuousMappingPoint> allPoints;
@@ -111,7 +111,7 @@
 	protected double lastSpinnerNumber = 0;
 
 	/** Creates new form ContinuousMapperEditorPanel */
-	public ContinuousMappingEditorPanel(final VisualPropertyType type) {
+	public ContinuousMappingEditorPanel(final VisualProperty type) {
 		this.type = type;
 		initComponents();
 		setVisualPropLabel();
@@ -139,7 +139,7 @@
 	 *
 	 * @return  DOCUMENT ME!
 	 */
-	public static ImageIcon getIcon(final int width, final int height, VisualPropertyType type) {
+	public static ImageIcon getIcon(final int width, final int height, VisualProperty type) {
 		final Class dataType = type.getDataType();
 
 		if (dataType == Color.class) {
@@ -405,14 +405,11 @@
 	private void initRangeValues() {
 		final CyAttributes attr;
 
+		calculator = Cytoscape.getVisualMappingManager().getVisualStyle().getCalculator(type);
 		if (type.isNodeProp()) {
 			attr = Cytoscape.getNodeAttributes();
-			calculator = Cytoscape.getVisualMappingManager().getVisualStyle()
-			                      .getNodeAppearanceCalculator().getCalculator(type);
 		} else {
 			attr = Cytoscape.getEdgeAttributes();
-			calculator = Cytoscape.getVisualMappingManager().getVisualStyle()
-			                      .getEdgeAppearanceCalculator().getCalculator(type);
 		}
 
 		if (calculator == null)
Index: application/src/main/java/cytoscape/visual/ui/editors/continuous/C2CMappingEditor.java
===================================================================
--- application/src/main/java/cytoscape/visual/ui/editors/continuous/C2CMappingEditor.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/visual/ui/editors/continuous/C2CMappingEditor.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -36,7 +36,7 @@
 
 import cytoscape.Cytoscape;
 
-import org.cytoscape.vizmap.VisualPropertyType;
+import org.cytoscape.view.VisualProperty;
 
 import org.cytoscape.vizmap.mappings.BoundaryRangeValues;
 import org.cytoscape.vizmap.mappings.continuous.ContinuousMappingPoint;
@@ -73,7 +73,7 @@
 	 *
 	 * @param type DOCUMENT ME!
 	 */
-	public C2CMappingEditor(VisualPropertyType type) {
+	public C2CMappingEditor(VisualProperty type) {
 		super(type);
 		abovePanel.setVisible(false);
 		belowPanel.setVisible(false);
@@ -96,7 +96,7 @@
 	 * @param type DOCUMENT ME!
 	 */
 	public static Object showDialog(final int width, final int height, final String title,
-	                                VisualPropertyType type) {
+	                                VisualProperty type) {
 		editor = new C2CMappingEditor(type);
 		editor.setSize(new Dimension(width, height));
 		editor.setTitle(title);
@@ -113,7 +113,7 @@
 	 * @return  DOCUMENT ME!
 	 */
 	public static ImageIcon getIcon(final int iconWidth, final int iconHeight,
-	                                VisualPropertyType type) {
+	                                VisualProperty type) {
 		editor = new C2CMappingEditor(type);
 
 		TrackRenderer rend = editor.slider.getTrackRenderer();
@@ -137,7 +137,7 @@
 	 * @return  DOCUMENT ME!
 	 */
 	public static ImageIcon getLegend(final int width, final int height,
-	                                  final VisualPropertyType type) {
+	                                  final VisualProperty type) {
 		editor = new C2CMappingEditor(type);
 
 		final ContinuousTrackRenderer rend = (ContinuousTrackRenderer) editor.slider
@@ -255,8 +255,7 @@
 		 */
 		TriangleThumbRenderer thumbRend = new TriangleThumbRenderer(slider);
 
-		ContinuousTrackRenderer cRend = new ContinuousTrackRenderer(type,
-		                                                            (Number) below, (Number) above);
+		ContinuousTrackRenderer cRend = new ContinuousTrackRenderer(type, (Number) below, (Number) above);
 		cRend.addPropertyChangeListener(this);
 
 		slider.setThumbRenderer(thumbRend);
Index: application/src/main/java/cytoscape/visual/ui/editors/continuous/C2DMappingEditor.java
===================================================================
--- application/src/main/java/cytoscape/visual/ui/editors/continuous/C2DMappingEditor.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/visual/ui/editors/continuous/C2DMappingEditor.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -37,7 +37,7 @@
 import cytoscape.Cytoscape;
 import cytoscape.visual.ui.EditorFactory;
 
-import org.cytoscape.vizmap.VisualPropertyType;
+import org.cytoscape.view.VisualProperty;
 
 import org.cytoscape.vizmap.mappings.BoundaryRangeValues;
 import org.cytoscape.vizmap.mappings.continuous.ContinuousMappingPoint;
@@ -71,7 +71,7 @@
 	 *
 	 * @param type DOCUMENT ME!
 	 */
-	public C2DMappingEditor(VisualPropertyType type) {
+	public C2DMappingEditor(VisualProperty type) {
 		super(type);
 		this.iconPanel.setVisible(false);
 		this.belowPanel.setVisible(false);
@@ -90,7 +90,7 @@
 	 * @return  DOCUMENT ME!
 	 */
 	public static Object showDialog(final int width, final int height, final String title,
-	                                VisualPropertyType type) {
+	                                VisualProperty type) {
 		editor = new C2DMappingEditor(type);
 		editor.setSize(new Dimension(width, height));
 		editor.setTitle(title);
@@ -107,7 +107,7 @@
 	 * @return  DOCUMENT ME!
 	 */
 	public static ImageIcon getIcon(final int iconWidth, final int iconHeight,
-	                                VisualPropertyType type) {
+	                                VisualProperty type) {
 		editor = new C2DMappingEditor(type);
 
 		if (editor.slider.getTrackRenderer() instanceof DiscreteTrackRenderer == false) {
@@ -130,7 +130,7 @@
 	 * @return  DOCUMENT ME!
 	 */
 	public static ImageIcon getLegend(final int width, final int height,
-	                                  final VisualPropertyType type) {
+	                                  final VisualProperty type) {
 		editor = new C2DMappingEditor(type);
 
 		if (editor.slider.getTrackRenderer() instanceof DiscreteTrackRenderer == false) {
@@ -146,8 +146,8 @@
 	@Override
 	protected void addButtonActionPerformed(ActionEvent evt) {
 		BoundaryRangeValues newRange;
-		Object defValue = Cytoscape.getVisualMappingManager().getVisualStyle()
-		                           .getNodeAppearanceCalculator().getDefaultAppearance().get(type);
+		
+		Object defValue = Cytoscape.getVisualMappingManager().getVisualStyle().getDefaultValue(type);
 		final double maxValue = EditorValueRangeTracer.getTracer().getMax(type);
 
 		if (mapping.getPointCount() == 0) {
@@ -321,9 +321,7 @@
 			below = allPoints.get(0).getRange().lesserValue;
 			above = allPoints.get(allPoints.size() - 1).getRange().greaterValue;
 		} else {
-			Object defaultVal = Cytoscape.getVisualMappingManager().getVisualStyle()
-			                             .getNodeAppearanceCalculator().getDefaultAppearance()
-			                             .get(type);
+			Object defaultVal = Cytoscape.getVisualMappingManager().getVisualStyle().getDefaultValue(type);
 			below = defaultVal;
 			above = defaultVal;
 		}
Index: application/src/main/java/cytoscape/visual/ui/editors/continuous/DiscreteTrackRenderer.java
===================================================================
--- application/src/main/java/cytoscape/visual/ui/editors/continuous/DiscreteTrackRenderer.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/visual/ui/editors/continuous/DiscreteTrackRenderer.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -56,15 +56,16 @@
 import org.jdesktop.swingx.multislider.Thumb;
 
 import cytoscape.Cytoscape;
+
 import org.cytoscape.vizmap.LabelPosition;
-import org.cytoscape.vizmap.LineStyle;
-import org.cytoscape.vizmap.NodeShape;
-import org.cytoscape.vizmap.VisualPropertyType;
 import org.cytoscape.vizmap.mappings.ContinuousMapping;
 import org.cytoscape.vizmap.mappings.continuous.ContinuousMappingPoint;
 import org.cytoscape.vizmap.icon.VisualPropertyIcon;
 //import cytoscape.visual.ui.LabelPlacerGraphic;
 
+import org.cytoscape.view.DiscreteValue;
+import org.cytoscape.view.VisualProperty;
+import org.cytoscape.view.VisualPropertyCatalog;
 
 /**
  * DOCUMENT ME!
@@ -90,7 +91,7 @@
 //	private double maxValue;
 	private Object below;
 	private Object above;
-	private VisualPropertyType type;
+	private VisualProperty type;
 	private String title;
 
 	// Mainly for Icons
@@ -110,7 +111,7 @@
 	 * @param below  DOCUMENT ME!
 	 * @param above  DOCUMENT ME!
 	 */
-	public DiscreteTrackRenderer(VisualPropertyType type,
+	public DiscreteTrackRenderer(VisualProperty type,
 	                             Object below, Object above) {
 
 		this.below = below;
@@ -119,12 +120,10 @@
 		this.type = type;
 
 		if (type.isNodeProp())
-			title = Cytoscape.getVisualMappingManager().getVisualStyle()
-			                 .getNodeAppearanceCalculator().getCalculator(type).getMapping(0)
+			title = Cytoscape.getVisualMappingManager().getVisualStyle().getCalculator(type).getMapping(0)
 			                 .getControllingAttributeName();
 		else
-			title = Cytoscape.getVisualMappingManager().getVisualStyle()
-			                 .getEdgeAppearanceCalculator().getCalculator(type).getMapping(0)
+			title = Cytoscape.getVisualMappingManager().getVisualStyle().getCalculator(type).getMapping(0)
 			                 .getControllingAttributeName();
 
 		this.setBackground(Color.white);
@@ -540,7 +539,7 @@
 	private static List buildIconArray(int size) {
 		List<ImageIcon> icons = new ArrayList<ImageIcon>();
 
-		Map iconMap = NodeShape.getIconSet();
+		Map iconMap = VisualPropertyCatalog.getVisualProperty("NODE_SHAPE").getIconSet();
 
 		Object[] keys = iconMap.keySet().toArray();
 
@@ -575,88 +574,37 @@
 		g.setColor(ICON_COLOR);
 		g.setStroke(STROKE2);
 
-		switch (type) {
-			case NODE_SHAPE:
-
-				final VisualPropertyIcon icon = (VisualPropertyIcon) type.getVisualProperty()
-				                                                         .getIconSet().get(key);
+		Class dataTypeClass = type.getDataType();
+		if (dataTypeClass.isAssignableFrom(DiscreteValue.class)){
+			final VisualPropertyIcon icon = ((VisualPropertyIcon) type.getIconSet().get(key));
+			if(icon != null) {
 				icon.setIconHeight(size);
 				icon.setIconWidth(size);
-				g.fill(icon.getShape());
-
-				break;
-
-			case EDGE_SRCARROW_SHAPE:
-			case EDGE_TGTARROW_SHAPE:
-
-				final VisualPropertyIcon arrowIcon = ((VisualPropertyIcon) type.getVisualProperty()
-				                                                         .getIconSet().get(key));
-				if(arrowIcon == null) {
-					break;
-				}
-				final int newSize = size;
-				arrowIcon.setIconHeight(newSize);
-				arrowIcon.setIconWidth(((Number)(newSize*2.5)).intValue());
 				
-				g.translate(-newSize, 0);
-				arrowIcon.paintIcon(this, g, x, y);
-				g.translate(newSize, 0);
+				//g.translate(-newSize, 0);
+				icon.paintIcon(this, g, x, y);
+				//g.translate(newSize, 0);
+			}
+		} else if (dataTypeClass.isAssignableFrom(Font.class)){
+			final Font font = (Font) key;
+			final String fontName = font.getFontName();
+			g.setFont(new Font(fontName, font.getStyle(), size));
+			g.drawString("A", 0, size);
 
-				break;
+			final int smallFontSize = ((Number) (size * 0.25)).intValue();
+			g.setFont(new Font(fontName, font.getStyle(), smallFontSize));
 
-			case NODE_FONT_FACE:
-			case EDGE_FONT_FACE:
-
-				final Font font = (Font) key;
-				final String fontName = font.getFontName();
-				g.setFont(new Font(fontName, font.getStyle(), size));
-				g.drawString("A", 0, size);
-
-				final int smallFontSize = ((Number) (size * 0.25)).intValue();
-				g.setFont(new Font(fontName, font.getStyle(), smallFontSize));
-
-				int stringWidth = SwingUtilities.computeStringWidth(g.getFontMetrics(), fontName);
-				g.drawString(fontName, (size / 2) - (stringWidth / 2), size + smallFontSize + 2);
-
-				break;
-
-			case NODE_LINE_STYLE:
-			case EDGE_LINE_STYLE:
-
-				final Stroke stroke = ((LineStyle) key).getStroke(2.0f);
-				final int newSize2 = (int) (size * 1.5);
-				g.translate(0, -size * 0.25);
-				g.setColor(Color.DARK_GRAY);
-				g.drawRect(0, 0, size, newSize2);
-				g.setStroke(stroke);
-				g.setColor(ICON_COLOR);
-				g.drawLine(size - 1, 1, 1, newSize2 - 1);
-				g.translate(0, size * 0.25);
-
-				break;
-
-// TODO
-//			case NODE_LABEL_POSITION:
-//
-//				final LabelPlacerGraphic lp = new LabelPlacerGraphic((LabelPosition) key,
-//				                                                     (int) (size * 1.5), false);
-//				lp.paint(g);
-//
-//				break;
-
-			case NODE_LABEL:
-			case NODE_TOOLTIP:
-			case EDGE_LABEL:
-			case EDGE_TOOLTIP:
-				if(key != null) {
-					g.drawString(key.toString(), 0, g.getFont().getSize()*2);
-				}
-				break;
-
-			default:
-				break;
+			int stringWidth = SwingUtilities.computeStringWidth(g.getFontMetrics(), fontName);
+			g.drawString(fontName, (size / 2) - (stringWidth / 2), size + smallFontSize + 2);
+		} else if (dataTypeClass.isAssignableFrom(LabelPosition.class)){
+			// TODO: this was commented out as "TODO" in original (pre-pluggable-renderers refactor) code
+		} else if (dataTypeClass.isAssignableFrom(String.class)){
+			if(key != null) {
+				g.drawString(key.toString(), 0, g.getFont().getSize()*2);
+			}
+		} else {
+			System.out.println("unknown data type:"+dataTypeClass);
 		}
-
 		g.translate(-x, -y);
 	}
 
Index: application/src/main/java/cytoscape/visual/ui/ValueSelectDialog.java
===================================================================
--- application/src/main/java/cytoscape/visual/ui/ValueSelectDialog.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/visual/ui/ValueSelectDialog.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -34,8 +34,6 @@
 */
 package cytoscape.visual.ui;
 
-import static org.cytoscape.vizmap.VisualPropertyType.*;
-
 import java.awt.Color;
 import java.awt.Component;
 import java.awt.Dimension;
@@ -58,11 +56,11 @@
 import org.jdesktop.swingx.painter.gradient.BasicGradientPainter;
 
 import cytoscape.Cytoscape;
-import org.cytoscape.vizmap.NodeShape;
-import org.cytoscape.vizmap.VisualPropertyType;
 import org.cytoscape.vizmap.icon.VisualPropertyIcon;
 
+import org.cytoscape.view.VisualProperty;
 
+
 /**
  *
  * @author kono
@@ -70,7 +68,7 @@
 public class ValueSelectDialog extends JDialog {
 	private final static long serialVersionUID = 1202339876950593L;
 	
-	private final VisualPropertyType type;
+	private final VisualProperty type;
 	private Map shapeMap;
 	private List<Object> orderedKeyList;
 	
@@ -85,23 +83,23 @@
 	 * @param parent
 	 * @return
 	 */
-	public static Object showDialog(VisualPropertyType type, JDialog parent) {
+	public static Object showDialog(VisualProperty type, JDialog parent) {
 	
 		final ValueSelectDialog dialog = new ValueSelectDialog(type, parent, true);
 		dialog.setVisible(true);
 		return dialog.getValue();
 	}
 
-	private ValueSelectDialog(VisualPropertyType type, JDialog parent, boolean modal) {
+	private ValueSelectDialog(VisualProperty type, JDialog parent, boolean modal) {
 		super(Cytoscape.getDesktop(), modal);
 		this.type = type;
-		shapeMap = this.type.getVisualProperty().getIconSet();
+		shapeMap = this.type.getIconSet();
 		initComponents();
 
 		setList();
 		
-		// get original value and sete the selected item.
-		originalValue = Cytoscape.getVisualMappingManager().getVisualStyle().getNodeAppearanceCalculator().getDefaultAppearance().get(type);
+		// get original value and set the selected item.
+		originalValue = Cytoscape.getVisualMappingManager().getVisualStyle().getDefaultValue(type); 
 	}
 
 	/**
@@ -241,14 +239,15 @@
 		for (Object key : shapeMap.keySet()) {
 			icon = (VisualPropertyIcon) shapeMap.get(key);
 
-			if(type == EDGE_SRCARROW_SHAPE || type == EDGE_TGTARROW_SHAPE) {
+			if(type.getName().equals("EDGE_SRCARROW_SHAPE") || type.getName().equals("EDGE_TGTARROW_SHAPE")) {
 				icon.setIconWidth(icon.getIconWidth()*3);
 			}
-			if(type.equals(NODE_SHAPE) && ((NodeShape)key).isSupported() == false) {
+			/* FIXME: handle this later
+			if(type.getName().equals("NODE_SHAPE") && ((NodeShape)key).isSupported() == false) {
 				// Filter shapes not supported by current rendering engine.
 				// Maybe supported in future versions...
 				continue;
-			}
+			}*/
 			icons.add(icon);
 			orderedKeyList.add(key);
 			model.addElement(icon.getName());
Index: application/src/main/java/cytoscape/ShapeRenderer.java
===================================================================
--- application/src/main/java/cytoscape/ShapeRenderer.java	(.../trunk)	(revision 0)
+++ application/src/main/java/cytoscape/ShapeRenderer.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -0,0 +1,489 @@
+package cytoscape;
+
+//import cytoscape.render.immed.GraphGraphics;
+import java.awt.*;
+import java.awt.geom.*;
+
+import org.cytoscape.view.DiscreteVisualProperty;
+import org.cytoscape.view.NodeView;
+import org.cytoscape.view.VisualProperty;
+import org.cytoscape.view.renderers.NodeRenderer;
+import org.cytoscape.vizmap.LabelPosition;
+import org.cytoscape.vizmap.icon.ArrowIcon;
+import org.cytoscape.vizmap.icon.LineTypeIcon;
+import org.cytoscape.vizmap.icon.NodeIcon;
+import org.cytoscape.vizmap.icon.VisualPropertyIcon;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+import javax.swing.Icon;
+
+import cytoscape.render.immed.GraphGraphics;
+import cytoscape.render.stateful.NodeDetails;
+
+public class ShapeRenderer implements NodeRenderer {
+	public static final int CUSTOM_SHAPE_MAX_VERTICES = 100;
+	private final double[] m_polyCoords = // I need this for extra precision.
+		new double[2 * CUSTOM_SHAPE_MAX_VERTICES];
+	public static final byte SHAPE_RECTANGLE = 0;
+	public static final byte SHAPE_DIAMOND = 1;
+	public static final byte SHAPE_ELLIPSE = 2;
+	public static final byte SHAPE_HEXAGON = 3;
+	public static final byte SHAPE_OCTAGON = 4;
+	public static final byte SHAPE_PARALLELOGRAM = 5;
+	public static final byte SHAPE_ROUNDED_RECTANGLE = 6;
+	public static final byte SHAPE_TRIANGLE = 7;
+	public static final byte SHAPE_VEE = 8;
+	private static final byte s_last_shape = SHAPE_VEE;
+	
+	/*
+	 * A constant for controlling how cubic Bezier curves are drawn; This
+	 * particular constant results in elliptical-looking curves.
+	 */
+	private static final double CURVE_ELLIPTICAL = (4.0d * (Math.sqrt(2.0d) - 1.0d)) / 3.0d;
+	
+	private final GeneralPath m_path2d = new GeneralPath();
+	private final GeneralPath m_path2dPrime = new GeneralPath();
+	private final Ellipse2D.Double m_ellp2d = new Ellipse2D.Double();
+	
+	private final double[] m_ptsBuff = new double[4];
+	private int m_polyNumPoints; // Used with m_polyCoords.
+
+	private String name;
+	
+	public ShapeRenderer(String name){
+		m_path2dPrime.setWindingRule(GeneralPath.WIND_EVEN_ODD);
+		this.name = name;
+	}
+	/**
+	 * Draw a preview image on canvas at given place (using some default NodeDetails that the renderer can make up)
+	 */
+	public void generatePreview(Graphics2D graphics, float[] position){
+		// TODO
+	}
+	// DEFINE VISUALPROPERTIES:
+	/** return array of Integer-s containing first,...last with step size increment */
+	private static Object[] range(int first, int last, int increment){
+		ArrayList result = new ArrayList();
+		for (int i = first; i<=last; i+=increment){
+			result.add(Integer.valueOf(i));
+		}
+		return result.toArray();
+	}
+
+	public static Map<Object, Icon> getNodeIconSet(Object [] values, Map<Byte, Shape>shapes) {
+		Map<Object, Icon> nodeShapeIcons = new HashMap<Object, Icon>();
+		for (int i = 0; i < values.length; i++) {
+			Integer value = (Integer) values[i];
+			Shape shape = shapes.get(new Byte(value.byteValue()));
+			
+			nodeShapeIcons.put(shape, new NodeIcon(shape));
+			
+		}
+		return nodeShapeIcons;
+	}
+	/**
+	 * Return a list of visual attributes this renderer can use
+	 */
+	public Collection<VisualProperty> supportedVisualAttributes(){
+		
+		Set<VisualProperty> visualProperties = new HashSet<VisualProperty>();
+		
+		visualProperties.add(new LegacyVisualProperty("NODE_FILL_COLOR", Color.class, true));
+		visualProperties.add( new LegacyVisualProperty("NODE_BORDER_COLOR", Color.class, true));
+		visualProperties.add( new LegacyVisualProperty("NODE_OPACITY", Number.class, true));
+		visualProperties.add( new LegacyVisualProperty("NODE_BORDER_OPACITY", Number.class, true));
+		visualProperties.add( new LegacyVisualProperty("NODE_LABEL_OPACITY", Number.class, true));
+
+		Object [] range = range(0, 8, 1); 
+		Map<Object, Icon> iconSet = getNodeIconSet(range, GraphGraphics.getNodeShapes()); 
+		visualProperties.add( new DiscreteVisualProperty("NODE_SHAPE", Integer.class, true, range, iconSet));
+		
+		visualProperties.add( new LegacyVisualProperty("NODE_SIZE", Number.class, true));
+		visualProperties.add( new LegacyVisualProperty("NODE_WIDTH", Number.class, true));
+		visualProperties.add( new LegacyVisualProperty("NODE_HEIGHT", Number.class, true));
+		visualProperties.add( new LegacyVisualProperty("NODE_LABEL", String.class, true));
+		visualProperties.add( new LegacyVisualProperty("NODE_FONT_FACE", Font.class, true));
+		visualProperties.add( new LegacyVisualProperty("NODE_FONT_SIZE", Number.class, true));
+		visualProperties.add( new LegacyVisualProperty("NODE_LABEL_COLOR", Color.class, true));
+		visualProperties.add( new LegacyVisualProperty("NODE_TOOLTIP", String.class, true));
+		visualProperties.add( new LegacyVisualProperty("NODE_LABEL_POSITION", LabelPosition.class, true));
+		return visualProperties;
+	}
+
+	/**
+	 * Draws a node with medium to high detail, depending on parameters
+	 * specified. The xMin, yMin, xMax, and yMax parameters specify the extents
+	 * of the node shape (in the node coordinate system), including the border
+	 * width. That is, the drawn border won't extend beyond the extents
+	 * specified.
+	 * <p>
+	 * There is an imposed constraint on borderWidth which, using the
+	 * implemented algorithms, prevents strange-looking borders. The constraint
+	 * is that borderWidth may not exceed the minimum of the node width and node
+	 * height divided by six. In addition, for custom node shapes, this
+	 * requirement may be more constrained, depending on the kinks in the custom
+	 * node shape.
+	 * <p>
+	 * There is a constraint that only applies to SHAPE_ROUNDED_RECTANGLE which
+	 * imposes that the maximum of the width and height be strictly less than
+	 * twice the minimum of the width and height of the node.
+	 * <p>
+	 * This method will not work unless clear() has been called at least once
+	 * previously.
+	 * 
+	 * @param nodeShape
+	 *            the shape of the node to draw (one of the SHAPE_* constants or
+	 *            a custom node shape).
+	 * @param xMin
+	 *            an extent of the node shape to draw, in node coordinate space;
+	 *            the drawn shape will theoretically contain a point that lies
+	 *            on this X coordinate.
+	 * @param yMin
+	 *            an extent of the node shape to draw, in node coordinate space;
+	 *            the drawn shape will theoretically contain a point that lies
+	 *            on this Y coordinate.
+	 * @param xMax
+	 *            an extent of the node shape to draw, in node coordinate space;
+	 *            the drawn shape will theoretically contain a point that lies
+	 *            on this X coordinate.
+	 * @param yMax
+	 *            an extent of the node shape to draw, in node coordinate space;
+	 *            the drawn shape will theoretically contain a point that lies
+	 *            on this Y coordinate.
+	 * @param fillPaint
+	 *            the paint to use when drawing the node area minus the border
+	 *            (the "interior" of the node).
+	 * @param borderWidth
+	 *            the border width, in node coordinate space; if this value is
+	 *            zero, the rendering engine skips over the process of rendering
+	 *            the border, which gives a significant performance boost.
+	 * @param borderPaint
+	 *            if borderWidth is not zero, this paint is used for rendering
+	 *            the node border; otherwise, this parameter is ignored (and may
+	 *            be null).
+	 * @exception IllegalArgumentException
+	 *                if xMin is not less than xMax or if yMin is not less than
+	 *                yMax, if borderWidth is negative or is greater than
+	 *                Math.min(xMax - xMin, yMax - yMin) / 6 (for custom node
+	 *                shapes borderWidth may be even more limited, depending on
+	 *                the specific shape), if nodeShape is
+	 *                SHAPE_ROUNDED_RECTANGLE and the condition max(width,
+	 *                height) < 2 * min(width, height) does not hold, or if
+	 *                nodeShape is neither one of the SHAPE_* constants nor a
+	 *                previously defined custom node shape.
+	 */
+	public void render(Graphics2D m_g2d, NodeDetails nodeDetails, float[] floatBuff1, int node, NodeView nodeView) {
+		System.out.println("rendering by: "+name);
+		
+		// TODO Auto-generated method stub
+		byte nodeShape = nodeDetails.shape(node);
+		float xMin = floatBuff1[0]; 
+		float yMin =  floatBuff1[1];
+		float xMax = floatBuff1[2];
+		float yMax = floatBuff1[3];
+		
+		HashMap <String, Object> attrs = nodeView.getVisualAttributes();
+		Paint fillPaint; 
+		if (nodeView.isSelected()) {
+			fillPaint = (Paint) attrs.get("selectedPaint");
+		} else {
+			fillPaint = (Paint) attrs.get("unselectedPaint");
+		}
+		float borderWidth = ((Double)attrs.get("borderWidth")).floatValue();
+		Paint borderPaint = (Paint) attrs.get("borderPaint");
+		
+		if (borderWidth == 0.0f) {
+			m_g2d.setPaint(fillPaint);
+			m_g2d.fill(getShape(nodeShape, xMin, yMin, xMax, yMax));
+		} else { // There is a border.
+			m_path2dPrime.reset();
+			m_path2dPrime.append(getShape(nodeShape, xMin, yMin, xMax, yMax),
+					false); // Make a copy, essentially.
+
+			final Shape innerShape;
+
+			if (nodeShape == SHAPE_ELLIPSE) {
+				// TODO: Compute a more accurate inner area for ellipse +
+				// border.
+				innerShape = getShape(SHAPE_ELLIPSE, ((double) xMin)
+						+ borderWidth, ((double) yMin) + borderWidth,
+						((double) xMax) - borderWidth, ((double) yMax)
+								- borderWidth);
+			} else if (nodeShape == SHAPE_ROUNDED_RECTANGLE) {
+				computeRoundedRectangle(((double) xMin) + borderWidth,
+						((double) yMin) + borderWidth, ((double) xMax)
+								- borderWidth, ((double) yMax) - borderWidth,
+						(Math.max(((double) xMax) - xMin, ((double) yMax)
+								- yMin) / 4.0d)
+								- borderWidth, m_path2d);
+				innerShape = m_path2d;
+			} else {
+				// A general [possibly non-convex] polygon with certain
+				// restrictions: no two consecutive line segments can be
+				// parallel,
+				// each line segment must have nonzero length, the polygon
+				// cannot
+				// self-intersect, and the polygon must be clockwise
+				// in the node coordinate system.
+				m_path2d.reset();
+
+				final double xNot = m_polyCoords[0];
+				final double yNot = m_polyCoords[1];
+				final double xOne = m_polyCoords[2];
+				final double yOne = m_polyCoords[3];
+				double xPrev = xNot;
+				double yPrev = yNot;
+				double xCurr = xOne;
+				double yCurr = yOne;
+				double xNext = m_polyCoords[4];
+				double yNext = m_polyCoords[5];
+				computeInnerPoint(m_ptsBuff, xPrev, yPrev, xCurr, yCurr, xNext,
+						yNext, borderWidth);
+				m_path2d.moveTo((float) m_ptsBuff[0], (float) m_ptsBuff[1]);
+
+				int i = 6;
+
+				while (true) {
+					if (i == (m_polyNumPoints * 2)) {
+						computeInnerPoint(m_ptsBuff, xCurr, yCurr, xNext,
+								yNext, xNot, yNot, borderWidth);
+						m_path2d.lineTo((float) m_ptsBuff[0],
+								(float) m_ptsBuff[1]);
+						computeInnerPoint(m_ptsBuff, xNext, yNext, xNot, yNot,
+								xOne, yOne, borderWidth);
+						m_path2d.lineTo((float) m_ptsBuff[0],
+								(float) m_ptsBuff[1]);
+						m_path2d.closePath();
+
+						break;
+					} else {
+						xPrev = xCurr;
+						yPrev = yCurr;
+						xCurr = xNext;
+						yCurr = yNext;
+						xNext = m_polyCoords[i++];
+						yNext = m_polyCoords[i++];
+						computeInnerPoint(m_ptsBuff, xPrev, yPrev, xCurr,
+								yCurr, xNext, yNext, borderWidth);
+						m_path2d.lineTo((float) m_ptsBuff[0],
+								(float) m_ptsBuff[1]);
+					}
+				}
+
+				innerShape = m_path2d;
+			}
+
+			m_g2d.setPaint(fillPaint);
+			m_g2d.fill(innerShape);
+
+			// Render the border such that it does not overlap with the fill
+			// region because translucent colors may be used. Don't do
+			// things differently for opaque and translucent colors for the
+			// sake of consistency.
+			
+			m_path2dPrime.append(innerShape, false);
+			m_g2d.setPaint(borderPaint);
+			m_g2d.fill(m_path2dPrime);
+			
+		}
+	}
+	
+	/*
+	 * This method has the side effect of setting m_ellp2d or m_path2d; if
+	 * m_path2d is set (every case but the ellipse and rounded rectangle), then
+	 * m_polyCoords and m_polyNumPoints are also set.
+	 */
+	private final Shape getShape(final byte nodeShape, final double xMin,
+			final double yMin, final double xMax, final double yMax) {
+		switch (nodeShape) {
+		case SHAPE_ELLIPSE:
+			m_ellp2d.setFrame(xMin, yMin, xMax - xMin, yMax - yMin);
+
+			return m_ellp2d;
+
+		case SHAPE_RECTANGLE:
+			m_polyNumPoints = 4;
+			m_polyCoords[0] = xMin;
+			m_polyCoords[1] = yMin;
+			m_polyCoords[2] = xMax;
+			m_polyCoords[3] = yMin;
+			m_polyCoords[4] = xMax;
+			m_polyCoords[5] = yMax;
+			m_polyCoords[6] = xMin;
+			m_polyCoords[7] = yMax;
+
+			break;
+
+		case SHAPE_DIAMOND:
+			m_polyNumPoints = 4;
+			m_polyCoords[0] = (xMin + xMax) / 2.0d;
+			m_polyCoords[1] = yMin;
+			m_polyCoords[2] = xMax;
+			m_polyCoords[3] = (yMin + yMax) / 2.0d;
+			m_polyCoords[4] = (xMin + xMax) / 2.0d;
+			m_polyCoords[5] = yMax;
+			m_polyCoords[6] = xMin;
+			m_polyCoords[7] = (yMin + yMax) / 2.0d;
+
+			break;
+
+		case SHAPE_HEXAGON:
+			m_polyNumPoints = 6;
+			m_polyCoords[0] = ((2.0d * xMin) + xMax) / 3.0d;
+			m_polyCoords[1] = yMin;
+			m_polyCoords[2] = ((2.0d * xMax) + xMin) / 3.0d;
+			m_polyCoords[3] = yMin;
+			m_polyCoords[4] = xMax;
+			m_polyCoords[5] = (yMin + yMax) / 2.0d;
+			m_polyCoords[6] = ((2.0d * xMax) + xMin) / 3.0d;
+			m_polyCoords[7] = yMax;
+			m_polyCoords[8] = ((2.0d * xMin) + xMax) / 3.0d;
+			m_polyCoords[9] = yMax;
+			m_polyCoords[10] = xMin;
+			m_polyCoords[11] = (yMin + yMax) / 2.0d;
+
+			break;
+
+		case SHAPE_OCTAGON:
+			m_polyNumPoints = 8;
+			m_polyCoords[0] = ((2.0d * xMin) + xMax) / 3.0d;
+			m_polyCoords[1] = yMin;
+			m_polyCoords[2] = ((2.0d * xMax) + xMin) / 3.0d;
+			m_polyCoords[3] = yMin;
+			m_polyCoords[4] = xMax;
+			m_polyCoords[5] = ((2.0d * yMin) + yMax) / 3.0d;
+			m_polyCoords[6] = xMax;
+			m_polyCoords[7] = ((2.0d * yMax) + yMin) / 3.0d;
+			m_polyCoords[8] = ((2.0d * xMax) + xMin) / 3.0d;
+			m_polyCoords[9] = yMax;
+			m_polyCoords[10] = ((2.0d * xMin) + xMax) / 3.0d;
+			m_polyCoords[11] = yMax;
+			m_polyCoords[12] = xMin;
+			m_polyCoords[13] = ((2.0d * yMax) + yMin) / 3.0d;
+			m_polyCoords[14] = xMin;
+			m_polyCoords[15] = ((2.0d * yMin) + yMax) / 3.0d;
+
+			break;
+
+		case SHAPE_PARALLELOGRAM:
+			m_polyNumPoints = 4;
+			m_polyCoords[0] = xMin;
+			m_polyCoords[1] = yMin;
+			m_polyCoords[2] = ((2.0d * xMax) + xMin) / 3.0d;
+			m_polyCoords[3] = yMin;
+			m_polyCoords[4] = xMax;
+			m_polyCoords[5] = yMax;
+			m_polyCoords[6] = ((2.0d * xMin) + xMax) / 3.0d;
+			m_polyCoords[7] = yMax;
+
+			break;
+
+		case SHAPE_ROUNDED_RECTANGLE:
+			// A condition that must be satisfied (pertaining to radius) is that
+			// max(width, height) <= 2 * min(width, height).
+			computeRoundedRectangle(xMin, yMin, xMax, yMax, Math.max(xMax
+					- xMin, yMax - yMin) / 4.0d, m_path2d);
+
+			return m_path2d;
+
+		case SHAPE_TRIANGLE:
+			m_polyNumPoints = 3;
+			m_polyCoords[0] = (xMin + xMax) / 2.0d;
+			m_polyCoords[1] = yMin;
+			m_polyCoords[2] = xMax;
+			m_polyCoords[3] = yMax;
+			m_polyCoords[4] = xMin;
+			m_polyCoords[5] = yMax;
+
+			break;
+
+		case SHAPE_VEE:
+			m_polyNumPoints = 4;
+			m_polyCoords[0] = xMin;
+			m_polyCoords[1] = yMin;
+			m_polyCoords[2] = (xMin + xMax) / 2.0d;
+			m_polyCoords[3] = ((2.0d * yMin) + yMax) / 3.0d;
+			m_polyCoords[4] = xMax;
+			m_polyCoords[5] = yMin;
+			m_polyCoords[6] = (xMin + xMax) / 2.0d;
+			m_polyCoords[7] = yMax;
+
+			break;
+
+		}
+
+		m_path2d.reset();
+
+		m_path2d.moveTo((float) m_polyCoords[0], (float) m_polyCoords[1]);
+
+		for (int i = 2; i < (m_polyNumPoints * 2);)
+			m_path2d.lineTo((float) m_polyCoords[i++],
+					(float) m_polyCoords[i++]);
+
+		m_path2d.closePath();
+
+		return m_path2d;
+	}
+	
+	private final static void computeRoundedRectangle(final double xMin,
+			final double yMin, final double xMax, final double yMax,
+			final double radius, final GeneralPath path2d) {
+		path2d.reset();
+		path2d.moveTo((float) (xMax - radius), (float) yMin);
+		path2d.curveTo((float) (((CURVE_ELLIPTICAL - 1.0d) * radius) + xMax),
+				(float) yMin, (float) xMax,
+				(float) (((1.0d - CURVE_ELLIPTICAL) * radius) + yMin),
+				(float) xMax, (float) (radius + yMin));
+		path2d.lineTo((float) xMax, (float) (yMax - radius));
+		path2d.curveTo((float) xMax,
+				(float) (((CURVE_ELLIPTICAL - 1.0d) * radius) + yMax),
+				(float) (((CURVE_ELLIPTICAL - 1.0d) * radius) + xMax),
+				(float) yMax, (float) (xMax - radius), (float) yMax);
+		path2d.lineTo((float) (radius + xMin), (float) yMax);
+		path2d.curveTo((float) (((1.0d - CURVE_ELLIPTICAL) * radius) + xMin),
+				(float) yMax, (float) xMin,
+				(float) (((CURVE_ELLIPTICAL - 1.0d) * radius) + yMax),
+				(float) xMin, (float) (yMax - radius));
+		path2d.lineTo((float) xMin, (float) (radius + yMin));
+		path2d.curveTo((float) xMin,
+				(float) (((1.0d - CURVE_ELLIPTICAL) * radius) + yMin),
+				(float) (((1.0d - CURVE_ELLIPTICAL) * radius) + xMin),
+				(float) yMin, (float) (radius + xMin), (float) yMin);
+		path2d.closePath();
+	}
+	/*
+	 * This method is used to construct an inner shape for node border.
+	 * output[0] is the x return value and output[1] is the y return value. The
+	 * line prev->curr cannot be parallel to curr->next.
+	 */
+	private final static void computeInnerPoint(final double[] output,
+			final double xPrev, final double yPrev, final double xCurr,
+			final double yCurr, final double xNext, final double yNext,
+			final double borderWidth) {
+		final double segX1 = xCurr - xPrev;
+		final double segY1 = yCurr - yPrev;
+		final double segLength1 = Math.sqrt((segX1 * segX1) + (segY1 * segY1));
+		final double segX2 = xNext - xCurr;
+		final double segY2 = yNext - yCurr;
+		final double segLength2 = Math.sqrt((segX2 * segX2) + (segY2 * segY2));
+		final double segX2Normal = segX2 / segLength2;
+		final double segY2Normal = segY2 / segLength2;
+		final double xNextPrime = (segX2Normal * segLength1) + xPrev;
+		final double yNextPrime = (segY2Normal * segLength1) + yPrev;
+		final double segPrimeX = xNextPrime - xCurr;
+		final double segPrimeY = yNextPrime - yCurr;
+		final double distancePrimeToSeg1 = (((segX1 * yNextPrime)
+				- (segY1 * xNextPrime) + (xPrev * yCurr)) - (xCurr * yPrev))
+				/ segLength1;
+		final double multFactor = borderWidth / distancePrimeToSeg1;
+		output[0] = (multFactor * segPrimeX) + xCurr;
+		output[1] = (multFactor * segPrimeY) + yCurr;
+	}
+
+}

Property changes on: application/src/main/java/cytoscape/ShapeRenderer.java
___________________________________________________________________
Added: svn:mergeinfo

Index: application/src/main/java/cytoscape/data/writers/XGMMLWriter.java
===================================================================
--- application/src/main/java/cytoscape/data/writers/XGMMLWriter.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/data/writers/XGMMLWriter.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -53,8 +53,6 @@
 
 import org.cytoscape.view.GraphView;
 
-import org.cytoscape.vizmap.LineStyle;
-
 import org.cytoscape.view.Bend;
 import org.cytoscape.view.EdgeView;
 import org.cytoscape.view.NodeView;
@@ -716,7 +714,8 @@
 			writeAttributePair("cy:targetArrowColor", paint2string(edgeView.getTargetEdgeEndPaint()));
 
 			writeAttributePair("cy:edgeLabelFont", encodeFont(edgeView.getLabel().getFont()));
-			writeAttributePair("cy:edgeLineType", LineStyle.extractLineStyle(edgeView.getStroke()).toString());
+			// FIXME: write IO later
+			//writeAttributePair("cy:edgeLineType", LineStyle.extractLineStyle(edgeView.getStroke()).toString());
 			// Set curved or not
 			if (edgeView.getLineType() == EdgeView.CURVED_LINES) {
 				writeAttributePair("cy:curved", "CURVED_LINES");
Index: application/src/main/java/cytoscape/data/readers/GMLReader.java
===================================================================
--- application/src/main/java/cytoscape/data/readers/GMLReader.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/data/readers/GMLReader.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -55,20 +55,11 @@
 import cytoscape.util.PercentUtil;
 import cytoscape.util.FileUtil;
 
-import org.cytoscape.vizmap.ArrowShape;
 import org.cytoscape.vizmap.CalculatorCatalog;
-import org.cytoscape.vizmap.EdgeAppearanceCalculator;
-import org.cytoscape.vizmap.GlobalAppearanceCalculator;
-import org.cytoscape.vizmap.NodeAppearanceCalculator;
-import org.cytoscape.vizmap.NodeShape;
 import org.cytoscape.vizmap.VisualMappingManager;
-import org.cytoscape.vizmap.LineStyle;
 import org.cytoscape.vizmap.VisualStyle;
-import org.cytoscape.vizmap.VisualPropertyType;
-
 import org.cytoscape.vizmap.calculators.Calculator;
 import org.cytoscape.vizmap.calculators.BasicCalculator;
-
 import org.cytoscape.vizmap.mappings.DiscreteMapping;
 import org.cytoscape.vizmap.mappings.ObjectMapping;
 import org.cytoscape.vizmap.mappings.PassThroughMapping;
@@ -80,6 +71,7 @@
 import org.cytoscape.view.EdgeView;
 import org.cytoscape.view.GraphView;
 import org.cytoscape.view.NodeView;
+import org.cytoscape.view.VisualProperty;
 
 import java.awt.Color;
 import java.awt.geom.Point2D;
@@ -206,9 +198,6 @@
 	Map<String,Double> nodeH;
 
 	// Hashes for node & edge attributes
-	Map<String,NodeShape> nodeShape;
-
-	// Hashes for node & edge attributes
 	Map<String,String> nodeCol;
 
 	// Hashes for node & edge attributes
@@ -955,19 +944,15 @@
 
 			if (keyVal.key.equals(X) || keyVal.key.equals(Y)) {
 				// Do nothing.
+				/* FIXME: comment out IO code during pluggable-renderers refactor. Will have to fix this later
 			} else if (keyVal.key.equals(H)) {
 				graphStyle.addProperty(nodeName, VisualPropertyType.NODE_HEIGHT, ""+keyVal.value);
 			} else if (keyVal.key.equals(W)) {
 				graphStyle.addProperty(nodeName, VisualPropertyType.NODE_WIDTH, ""+keyVal.value);
-			} else if (keyVal.key.equals(FILL)) {
-				graphStyle.addProperty(nodeName, VisualPropertyType.NODE_FILL_COLOR, ""+keyVal.value);
-			} else if (keyVal.key.equals(OUTLINE)) {
-				graphStyle.addProperty(nodeName, VisualPropertyType.NODE_BORDER_COLOR, ""+keyVal.value);
-			} else if (keyVal.key.equals(WIDTH)) {
-				graphStyle.addProperty(nodeName, VisualPropertyType.NODE_LINE_WIDTH, ""+keyVal.value);
 			} else if (keyVal.key.equals(TYPE)) {
 				String type = (String) keyVal.value;
 				graphStyle.addProperty(nodeName, VisualPropertyType.NODE_SHAPE,type);
+				*/
 			}
 		}
 	}
@@ -991,6 +976,7 @@
 				// with arbitrary number of anchors.
 				// Current version of CS does not support this, so ignore this
 				// at this point of time...
+				/* FIXME: comment out IO code during pluggable-renderers refactor. Will have to fix this later
 			} else if (keyVal.key.equals(WIDTH)) {
 				graphStyle.addProperty(edgeName, VisualPropertyType.EDGE_LINE_WIDTH, new String(keyVal.value.toString()));
 			} else if (keyVal.key.equals(FILL)) {
@@ -1017,7 +1003,7 @@
 				}
 				else {// none
 				}
-				
+				*/
 			} else if (keyVal.key.equals(TYPE)) {
 				value = (String) keyVal.value;
 
@@ -1034,6 +1020,7 @@
 		}
 		
 		// make the arrow color the same as edge
+		/* FIXME: comment out IO code during pluggable-renderers refactor. Will have to fix this later
 		if (isArrow) {
 			if (arrowShape.equals(ARROW_FIRST)) {
 				graphStyle.addProperty(edgeName, VisualPropertyType.EDGE_SRCARROW_COLOR, edgeFill);				
@@ -1046,6 +1033,7 @@
 				graphStyle.addProperty(edgeName, VisualPropertyType.EDGE_TGTARROW_COLOR, edgeFill);
 			}
 		}
+		*/
 	}
 
 	/**
Index: application/src/main/java/cytoscape/data/readers/XGMMLReader.java
===================================================================
--- application/src/main/java/cytoscape/data/readers/XGMMLReader.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/data/readers/XGMMLReader.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -86,9 +86,7 @@
 import cytoscape.util.FileUtil;
 import cytoscape.util.PercentUtil;
 import org.cytoscape.view.GraphView;
-import org.cytoscape.vizmap.LineStyle;
-import org.cytoscape.vizmap.ArrowShape;
-import org.cytoscape.vizmap.VisualPropertyType;
+import org.cytoscape.view.VisualProperty;
 import org.cytoscape.vizmap.VisualMappingManager;
 
 import java.lang.management.ManagementFactory;
@@ -459,6 +457,7 @@
 		nodeView.setXPosition(x);
 		nodeView.setYPosition(y);
 
+		/* FIXME: comment out IO code during pluggable-renderers refactor. Will have to fix this later
 		if (buildStyle && h != 0.0) {
 			// nodeView.setHeight(h);
 			graphStyle.addProperty(nodeID, VisualPropertyType.NODE_HEIGHT, ""+h);
@@ -467,63 +466,26 @@
 			// nodeView.setWidth(w);
 			graphStyle.addProperty(nodeID, VisualPropertyType.NODE_WIDTH, ""+w);
 		}
-
+		 */
 		CyAttributes nodeAttributes = Cytoscape.getNodeAttributes();
 
-		// Set color
-		if (buildStyle && XGMMLParser.getAttribute(graphics,"fill") != null) {
-			String fillColor = XGMMLParser.getAttribute(graphics, "fill");
-			graphStyle.addProperty(nodeID, VisualPropertyType.NODE_FILL_COLOR, fillColor);
-			// nodeView.setUnselectedPaint(fillColor);
-		}
 
-		// Set border line color
-		if (buildStyle && XGMMLParser.getAttribute(graphics,"outline") != null) {
-			String outlineColor = XGMMLParser.getAttribute(graphics, "outline");
-			// nodeView.setBorderPaint(outlineColor);
-			graphStyle.addProperty(nodeID, VisualPropertyType.NODE_BORDER_COLOR, outlineColor);
-		}
-
-		// Set border line width
-		if (buildStyle && XGMMLParser.getAttribute(graphics,"width") != null) {
-			String lineWidth = XGMMLParser.getAttribute(graphics,"width");
-			// nodeView.setBorderWidth(lineWidth);
-			graphStyle.addProperty(nodeID, VisualPropertyType.NODE_LINE_WIDTH, lineWidth);
-		}
-
-		if (buildStyle && XGMMLParser.getAttributeNS(graphics,"nodeTransparency",CY_NAMESPACE) != null) {
-			String opString = XGMMLParser.getAttributeNS(graphics,"nodeTransparency", CY_NAMESPACE);
-			float opacity = (float)Double.parseDouble(opString)*255;
-			// Opacity is saved as a float from 0-1, but internally we use 0-255
-			// nodeView.setTransparency(opacity);
-			graphStyle.addProperty(nodeID, VisualPropertyType.NODE_OPACITY, ""+opacity);
-		}
-
-		if (buildStyle && XGMMLParser.getAttributeNS(graphics, "opacity", CY_NAMESPACE) != null) {
-			String opString = XGMMLParser.getAttributeNS(graphics,"opacity", CY_NAMESPACE);
-			float opacity = (float)Double.parseDouble(opString);
-			// nodeView.setTransparency(opacity);
-			graphStyle.addProperty(nodeID, VisualPropertyType.NODE_OPACITY, opString);
-		}
-
 		// These are saved in the exported XGMML, but it's not clear how they get set
+		/* FIXME: comment out IO code during pluggable-renderers refactor. Will have to fix this later
 		if (buildStyle && XGMMLParser.getAttributeNS(graphics,"nodeLabelFont", CY_NAMESPACE) != null) {
 			String nodeLabelFont = XGMMLParser.getAttributeNS(graphics,"nodeLabelFont", CY_NAMESPACE);
 			graphStyle.addProperty(nodeID, VisualPropertyType.NODE_FONT_FACE, nodeLabelFont);
 		}
-
-		if (buildStyle && XGMMLParser.getAttributeNS(graphics,"borderLineType", CY_NAMESPACE) != null) {
-			String borderLineType = XGMMLParser.getAttributeNS(graphics,"borderLineType", CY_NAMESPACE);
-			graphStyle.addProperty(nodeID, VisualPropertyType.NODE_LINE_STYLE, borderLineType);
-		}
-
+		 */
 		String type = XGMMLParser.getAttribute(graphics,"type");
+		/* FIXME: comment out IO code during pluggable-renderers refactor. Will have to fix this later
 		if (buildStyle && type != null) {
 			if (type.equals("rhombus"))
 				graphStyle.addProperty(nodeID, VisualPropertyType.NODE_SHAPE,"parallelogram");
 			else
 				graphStyle.addProperty(nodeID, VisualPropertyType.NODE_SHAPE,type);
 		}
+		*/
 	}
 
 	/**
@@ -573,7 +535,7 @@
 	*/
 		CyAttributes edgeAttributes = Cytoscape.getEdgeAttributes();
 		String edgeID = edgeView.getEdge().getIdentifier();
-
+		/* FIXME: comment out IO code during pluggable-renderers refactor. Will have to fix this later
 		if (buildStyle && XGMMLParser.getAttribute(graphics,"width") != null) {
 			String lineWidth = XGMMLParser.getAttribute(graphics,"width");
 			// edgeView.setStrokeWidth(lineWidth);
@@ -618,7 +580,7 @@
 			String value = XGMMLParser.getAttributeNS(graphics, "edgeLineType", CY_NAMESPACE);
 			graphStyle.addProperty(edgeID, VisualPropertyType.EDGE_LINE_STYLE, value);
 		}
-
+		 */
 		if (XGMMLParser.getAttributeNS(graphics,"curved", CY_NAMESPACE) != null) {
 			String value = XGMMLParser.getAttributeNS(graphics, "curved", CY_NAMESPACE);
 			if (value.equals("STRAIGHT_LINES")) {
@@ -627,7 +589,7 @@
 				edgeView.setLineType(EdgeView.CURVED_LINES);
 			}
 		}
-
+		 
 	 	if (XGMMLParser.getAttribute(graphics,"edgeHandleList") != null) {
 			// System.out.println("See edgeHandleList");
 			String handles[] = XGMMLParser.getAttribute(graphics, "edgeHandleList").split(";");
@@ -706,6 +668,6 @@
 		if (center != null)
 			view.setCenter(center.getX(), center.getY());
 
-		Cytoscape.getVisualMappingManager().applyAppearances();
+		Cytoscape.getVisualMappingManager().getVisualStyle().apply(view);
 	}
 }
Index: application/src/main/java/cytoscape/data/readers/VisualStyleBuilder.java
===================================================================
--- application/src/main/java/cytoscape/data/readers/VisualStyleBuilder.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/data/readers/VisualStyleBuilder.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -38,6 +38,7 @@
 
 import cytoscape.Cytoscape;
 import org.cytoscape.attributes.CyAttributes;
+import org.cytoscape.view.VisualProperty;
 import org.cytoscape.vizmap.*;
 import org.cytoscape.vizmap.calculators.*;
 import org.cytoscape.vizmap.mappings.*;
@@ -54,8 +55,8 @@
  */
 public class VisualStyleBuilder {
 
-	Map<VisualPropertyType,Map<Object,Object>> valueMaps;
-	Map<VisualPropertyType,Map<Object,Integer>> counts;
+	Map<VisualProperty,Map<Object,Object>> valueMaps;
+	Map<VisualProperty,Map<Object,Integer>> counts;
 	String name;
 	private boolean nodeSizeLocked = true;
 
@@ -71,8 +72,8 @@
 		// because visual style parsing breaks with '.' in the names
 		this.name = name.replaceAll("\\.","_");
 
-		valueMaps = new EnumMap<VisualPropertyType,Map<Object,Object>>(VisualPropertyType.class);
-		counts = new EnumMap<VisualPropertyType,Map<Object,Integer>>(VisualPropertyType.class);
+		valueMaps = new HashMap<VisualProperty,Map<Object,Object>>();
+		counts = new HashMap<VisualProperty,Map<Object,Integer>>();
 	}
 
 	/**
@@ -89,26 +90,27 @@
 	 * Actually build the style using the provided properties
 	 */
 	public void buildStyle() {
+		
+		// FIXME FIXME: how much is this the same as copying a visualstyle (currentStyle)?
+		// if similar enough, should use something like that! 
+		
 		// First, get our current style information. 
 		VisualMappingManager vm = Cytoscape.getVisualMappingManager();
 		VisualStyle currentStyle = vm.getVisualStyle();
-		NodeAppearanceCalculator nac = new NodeAppearanceCalculator(currentStyle.getNodeAppearanceCalculator());
-		EdgeAppearanceCalculator eac = new EdgeAppearanceCalculator(currentStyle.getEdgeAppearanceCalculator());
-		GlobalAppearanceCalculator gac = new GlobalAppearanceCalculator(currentStyle.getGlobalAppearanceCalculator());
 
-		nac.setNodeSizeLocked(nodeSizeLocked);
+		//FIXME nac.setNodeSizeLocked(nodeSizeLocked); 
 
 		processCounts();
+		HashMap <VisualProperty, Calculator>calculators = new HashMap<VisualProperty, Calculator>();
+		for ( VisualProperty type : valueMaps.keySet() ) {
 
-		for ( VisualPropertyType type : valueMaps.keySet() ) {
-
 			Map<Object,Object> valMap = valueMaps.get(type);
 			// If there is more than one value specified for a given
 			// visual property, or if only a subset of nodes/edges
 			// have a property then create a mapping and calculator.
 			if ( createMapping(type) ) {
  
-				DiscreteMapping dm = new DiscreteMapping( type.getVisualProperty().getDefaultAppearanceObject(), 
+				DiscreteMapping dm = new DiscreteMapping( type.getDefaultAppearanceObject(), 
 					                                  getAttrName(type), 
 					                                  type.isNodeProp() ?  
 					                                  ObjectMapping.NODE_MAPPING : ObjectMapping.EDGE_MAPPING );
@@ -118,14 +120,12 @@
 
 				Calculator calc = new BasicCalculator("VisualStyleBuilder-" + getAttrName(type), dm, type);
 
-				if ( type.isNodeProp() )
-					nac.setCalculator( calc );
-				else
-					eac.setCalculator( calc );
+				calculators.put(type,calc);
 
 				// Otherwise, set the default appearance value for the visual style
 				// and then remove the attribute that was created.
 			} else {
+				/* FIXME: -- refactor per-vs default setting
 				if ( type.isNodeProp() ) {
 					for ( Object key : valMap.keySet() ) 
 						nac.getDefaultAppearance().set( type, valMap.get(key) );
@@ -135,6 +135,7 @@
 						eac.getDefaultAppearance().set( type, valMap.get(key) );
 					Cytoscape.getEdgeAttributes().deleteAttribute(getAttrName(type));
 				}
+				*/
 			}
 		}
 
@@ -143,7 +144,7 @@
 
 		String styleName = name + " style";
 
-		VisualStyle graphStyle = new VisualStyle(styleName, nac, eac, gac);
+		VisualStyle graphStyle = new VisualStyle(styleName, calculators, currentStyle.copyGlobalVisualProperties());
 
 		// Remove this in case we've already loaded this network once
 		catalog.removeVisualStyle(styleName);
@@ -153,7 +154,7 @@
 		vizmapper.setVisualStyle(graphStyle);
 	}
 
-	private String getAttrName(VisualPropertyType type) {
+	private String getAttrName(VisualProperty type) {
 		return "vizmap:"+name + " " + type.toString();
 	}
 
@@ -165,9 +166,9 @@
 	 * @param type the type of the property
 	 * @param desc the property value
 	 */
-	public void addProperty(String id, VisualPropertyType type, String desc) {
+	public void addProperty(String id, VisualProperty type, String desc) {
 		CyAttributes attrs;
-		Object value = type.getValueParser().parseStringValue(desc);
+		Object value = ValueParserCatalog.getValueParser(type).parseStringValue(desc);
 		if (value == null)
 			return;
 		if ( type.isNodeProp() )
@@ -210,8 +211,8 @@
 	 * how many nodes and edges there are.
 	 */
 	private void processCounts() {
-		Map<VisualPropertyType,Integer> cm = new EnumMap<VisualPropertyType,Integer>(VisualPropertyType.class);
-		for ( VisualPropertyType vpt : counts.keySet() ) {
+		Map<VisualProperty,Integer> cm = new HashMap<VisualProperty,Integer>();
+		for ( VisualProperty vpt : counts.keySet() ) {
 			int total = 0;
 			for ( Object o : counts.get(vpt).keySet() ) {
 				total += counts.get(vpt).get(o);
@@ -222,7 +223,7 @@
 
 		nodeMax = 0;
 		edgeMax = 0;
-		for ( VisualPropertyType vpt : counts.keySet() ) {
+		for ( VisualProperty vpt : counts.keySet() ) {
 			if ( counts.get(vpt).size() == 1 ) {
 				for ( Object o : counts.get(vpt).keySet() ) {
 					if ( vpt.isNodeProp() ) 
@@ -242,7 +243,7 @@
 	 * but only a subset of nodes or edges have that mapping (which is
 	 * to say the property doesn't hold for all nodes or all edges).
 	 */
-	private boolean createMapping(VisualPropertyType vpt) {
+	private boolean createMapping(VisualProperty vpt) {
 		// if there is more than one mapping
 		if ( counts.get(vpt).size() > 1 )
 			return true;
Index: application/src/main/java/cytoscape/Cytoscape.java
===================================================================
--- application/src/main/java/cytoscape/Cytoscape.java	(.../trunk)	(revision 14573)
+++ application/src/main/java/cytoscape/Cytoscape.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -57,21 +57,35 @@
 
 import cytoscape.ding.CyGraphLOD;
 
+import org.cytoscape.view.DependentVisualPropertyCallback;
+import org.cytoscape.view.DiscreteVisualProperty;
+import org.cytoscape.view.EdgeView;
 import org.cytoscape.view.GraphViewFactory;
+import org.cytoscape.view.NodeView;
+import org.cytoscape.view.VisualProperty;
+import org.cytoscape.view.VisualPropertyCatalog;
 
 import cytoscape.init.CyInitParams;
 
 import org.cytoscape.layout.CyLayouts;
 import org.cytoscape.layout.CyLayoutAlgorithm;
 
+import cytoscape.render.immed.GraphGraphics;
 import cytoscape.util.FileUtil;
 
 import org.cytoscape.view.GraphView;
+import org.cytoscape.view.renderers.NodeRenderer;
+import org.cytoscape.view.renderers.Renderer;
+
 import cytoscape.view.CytoscapeDesktop;
 
 import org.cytoscape.vizmap.VisualMappingManager;
 import org.cytoscape.vizmap.VisualStyle;
 import org.cytoscape.vizmap.VMMFactory;
+import org.cytoscape.vizmap.icon.ArrowIcon;
+import org.cytoscape.vizmap.icon.LineTypeIcon;
+import org.cytoscape.vizmap.icon.NodeIcon;
+import org.cytoscape.vizmap.icon.VisualPropertyIcon;
 
 import org.cytoscape.Edge;
 import org.cytoscape.Node;
@@ -79,7 +93,12 @@
 import org.cytoscape.RootGraph;
 import org.cytoscape.RootGraphFactory;
 
-import org.cytoscape.view.GraphView;
+
+import java.awt.BasicStroke;
+import java.awt.Color;
+import java.awt.Font;
+import java.awt.Shape;
+import java.awt.Stroke;
 import java.beans.PropertyChangeEvent;
 import java.beans.PropertyChangeSupport;
 
@@ -91,12 +110,14 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.LinkedList;
 
+import javax.swing.Icon;
 import javax.swing.JOptionPane;
 import javax.swing.event.SwingPropertyChangeSupport;
 
@@ -1935,11 +1956,116 @@
 	 */
 	public static void redrawGraph(GraphView view) {
 		VMMFactory.getVisualMappingManager().setNetworkView(view);
-		VMMFactory.getVisualMappingManager().applyAppearances();
+		VMMFactory.getVisualMappingManager().getVisualStyle().apply(view);
 		view.updateView();
 	}
 
 	public static VisualMappingManager getVisualMappingManager() {
 		return VMMFactory.getVisualMappingManager();
 	}
+
+
+	/** return array of Integer-s containing first,...last with step size increment */
+	private static Object[] range(int first, int last, int increment){
+		ArrayList result = new ArrayList();
+		for (int i = first; i<=last; i+=increment){
+			result.add(Integer.valueOf(i));
+		}
+		return result.toArray();
+	}
+
+	public static Map<Object, Icon> getArrowIconSet(Object [] values, Map<Byte, Shape>shapes) {
+		Map<Object, Icon> arrowShapeIcons = new HashMap<Object, Icon>();
+
+		for (int i = 0; i < values.length; i++) {
+			Integer value = (Integer) values[i];
+			Shape shape = shapes.get(new Byte(value.byteValue()));
+			ArrowIcon icon = new ArrowIcon(shape, 
+			                               VisualPropertyIcon.DEFAULT_ICON_SIZE, 
+			                               VisualPropertyIcon.DEFAULT_ICON_SIZE,
+			                               "someShape" /* FIXME: user-friendly string! */);
+			arrowShapeIcons.put(shape, icon);
+		}
+
+		return arrowShapeIcons;
+	}
+
+	public static Map<Object, Icon> getLineStyleIconSet(Object [] values) {
+		Map<Object, Icon> arrowShapeIcons = new HashMap<Object, Icon>();
+
+		for (int i = 0; i < values.length; i++) {
+			Stroke value = (Stroke) values[i];
+			arrowShapeIcons.put(value, new LineTypeIcon(value));
+		}
+
+		return arrowShapeIcons;
+	}
+
+	
+	public static Map<Object, Icon> getRendererIconSet(Object [] values) {
+		Map<Object, Icon> rendererIcons = new HashMap<Object, Icon>();
+		for (int i = 0; i < values.length; i++) {
+			NodeRenderer value = (NodeRenderer) values[i];
+			
+			rendererIcons.put(value, new NodeIcon()); // FIXME FIXME: do property icons!
+		}
+		return rendererIcons;
+	}
+
+
+	/** For the duration of pluggable VisualProperties refactor: add legacy VisualProperties */
+	public static void defineHardcodedVisualProperties(){
+		Object [] range = new Object[]{new TrivialRenderer("trivialrenderer"), new ShapeRenderer("shaperenderer")};
+		Map<Object, Icon> iconSet = getRendererIconSet(range);
+		
+		VisualPropertyCatalog.addVisualProperty(new DiscreteVisualProperty("NODE_RENDERER", NodeRenderer.class, true, range, iconSet,
+			new DependentVisualPropertyCallback(){
+				public Set<VisualProperty> changed(Collection<NodeView> nodeviews, Collection<EdgeView> edgeviews, Collection<VisualProperty> current_vps){
+					Set <NodeRenderer> renderers = new HashSet();
+					for (NodeView nv: nodeviews){
+						renderers.add(nv.getRenderer());
+					}
+					Set <VisualProperty> visualProperties = new HashSet();
+					for (Renderer renderer: renderers){
+						visualProperties.addAll(renderer.supportedVisualAttributes());
+					}
+					Set <VisualProperty> toRemove = new HashSet();
+					for (VisualProperty vp: current_vps){
+						if (vp.getName().startsWith("NODE_")){
+							toRemove.add(vp);
+						}
+					}
+					
+					toRemove.removeAll(visualProperties);
+					return toRemove;
+				}
+		}));
+		
+		
+		VisualPropertyCatalog.addVisualProperty( new LegacyVisualProperty("EDGE_COLOR", Color.class, false));
+		VisualPropertyCatalog.addVisualProperty( new LegacyVisualProperty("EDGE_LABEL", String.class, false));
+		VisualPropertyCatalog.addVisualProperty( new LegacyVisualProperty("EDGE_FONT_FACE", Font.class, false));
+		VisualPropertyCatalog.addVisualProperty( new LegacyVisualProperty("EDGE_FONT_SIZE", Number.class, false));
+		VisualPropertyCatalog.addVisualProperty( new LegacyVisualProperty("EDGE_LABEL_COLOR", Color.class, false));
+		VisualPropertyCatalog.addVisualProperty( new LegacyVisualProperty("EDGE_TOOLTIP", String.class, false));
+		VisualPropertyCatalog.addVisualProperty( new LegacyVisualProperty("EDGE_LINE_WIDTH", Number.class, false));
+
+		range = new Object[]{new BasicStroke(1.0f/*FIXME: width -- is this just a placeholder value? */),
+				new BasicStroke(1.0f /*see above */, BasicStroke.CAP_ROUND, BasicStroke.JOIN_MITER, 10.0f, new float[]{10.0f, 4.0f}, 0.0f)  };
+		iconSet = getLineStyleIconSet(range);
+		VisualPropertyCatalog.addVisualProperty( new DiscreteVisualProperty("EDGE_LINE_STYLE", Stroke.class, false, range, iconSet));
+		
+		range = range(-1, -5, -1); 
+		iconSet = getArrowIconSet(range, GraphGraphics.getArrowShapes()); 
+		VisualPropertyCatalog.addVisualProperty( new DiscreteVisualProperty("EDGE_SRCARROW_SHAPE", Integer.class, false, range, iconSet));
+		VisualPropertyCatalog.addVisualProperty( new DiscreteVisualProperty("EDGE_TGTARROW_SHAPE", Integer.class, false, range, iconSet));
+		VisualPropertyCatalog.addVisualProperty( new LegacyVisualProperty("EDGE_SRCARROW_COLOR", Color.class, false));
+		VisualPropertyCatalog.addVisualProperty( new LegacyVisualProperty("EDGE_TGTARROW_COLOR", Color.class, false));
+		VisualPropertyCatalog.addVisualProperty( new LegacyVisualProperty("EDGE_OPACITY", Number.class, false));
+		VisualPropertyCatalog.addVisualProperty( new LegacyVisualProperty("EDGE_LABEL_OPACITY", Number.class, false));
+		VisualPropertyCatalog.addVisualProperty( new LegacyVisualProperty("EDGE_SRCARROW_OPACITY", Number.class, false));
+		VisualPropertyCatalog.addVisualProperty( new LegacyVisualProperty("EDGE_TGTARROW_OPACITY", Number.class, false));
+		
+		//VisualPropertyCatalog.addVisualProperty( new LegacyVisualProperty("EDGE_LABEL_POSITION", Number.class, false));
+	}
 }
Index: application/src/main/java/cytoscape/LegacyVisualProperty.java
===================================================================
--- application/src/main/java/cytoscape/LegacyVisualProperty.java	(.../trunk)	(revision 0)
+++ application/src/main/java/cytoscape/LegacyVisualProperty.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -0,0 +1,753 @@
+package cytoscape;
+
+import java.util.Map;
+import java.util.Properties;
+
+import java.awt.Color;
+import java.awt.Graphics2D;
+import java.awt.Paint;
+import java.awt.Font;
+import java.awt.Stroke;
+import java.awt.BasicStroke;
+import java.awt.Component;
+import java.awt.Graphics;
+import java.awt.image.BufferedImage;
+
+import org.cytoscape.vizmap.LabelPosition;
+import org.cytoscape.vizmap.ValueParser;
+import org.cytoscape.vizmap.icon.LineTypeIcon;
+import org.cytoscape.vizmap.icon.NodeIcon;
+import org.cytoscape.vizmap.icon.ArrowIcon;
+import org.cytoscape.vizmap.parsers.ColorParser;
+import org.cytoscape.vizmap.parsers.DoubleParser;
+import org.cytoscape.vizmap.parsers.FontParser;
+import org.cytoscape.vizmap.LabelPlacerGraphic;
+
+import org.cytoscape.view.DependentVisualPropertyCallback;
+import org.cytoscape.view.EdgeView;
+import org.cytoscape.view.NodeView;
+import org.cytoscape.view.Label;
+import org.cytoscape.view.VisualProperty;
+import org.cytoscape.view.VisualPropertyCatalog;
+
+import cytoscape.render.immed.GraphGraphics;
+
+import javax.swing.Icon;
+
+/**
+ * Helper class to define legacy (pre-3.0 cytoscape) VisualProperties
+ */
+public class LegacyVisualProperty implements VisualProperty {
+	private String name;
+	private Class dataType; // Data type
+	private boolean isNodeProp; // indicates whether or not property is for a node or edge
+	
+	public LegacyVisualProperty(final String name, final Class dataType, final boolean isNodeProp) {
+		this.dataType = dataType;
+		this.isNodeProp = isNodeProp;
+		this.name = name;
+	}
+	
+	public void applyToEdgeView(EdgeView ev, Object o) {
+		// FIXME FIXME FIXME: this will be replaced with a simple "ev.setVisualAttribute(o)" -- infact, such a method isn't even needed in VisualProperty
+		// the following is only needed until we refactor the ViewModel layer & rendering
+		if ((o == null) || (ev == null))
+			return;
+		if (name.equals("EDGE_COLOR")){
+			if (!((Color) o).equals(ev.getUnselectedPaint()))
+				ev.setUnselectedPaint((Color) o);
+		} else if (name.equals("EDGE_LABEL")){
+			Label label = ev.getLabel();
+
+			if (!((String) o).equals(label.getText()))
+				label.setText((String) o);
+		} else if (name.equals("EDGE_FONT_FACE")){
+			Label nodelabel = ev.getLabel();
+			if (!((Font) o).equals(nodelabel.getFont()))
+				nodelabel.setFont((Font) o);
+		} else if (name.equals("EDGE_FONT_SIZE")){
+			Label edgelabel = ev.getLabel();
+			Font f = edgelabel.getFont();
+			float newFontSize = ((Number) o).floatValue();
+
+			if (newFontSize != f.getSize2D())
+				edgelabel.setFont(f.deriveFont(newFontSize));
+		} else if (name.equals("EDGE_LABEL_COLOR")){
+			Label edgelabel = ev.getLabel();
+
+			if (!((Color) o).equals(edgelabel.getTextPaint()))
+				edgelabel.setTextPaint((Color) o);
+		} else if (name.equals("EDGE_TOOLTIP")){
+	        if(((String)o).startsWith("<html>")) {
+	            ev.setToolTip((String) o);
+	            return;
+	        }
+
+	        // Setting the tooltip to null is preferred because otherwise a small icon
+	        // indicating the empty tooltip appears.
+	        if (((String)o).equals("")) {
+	            ev.setToolTip(null);
+	            return;
+	        }
+
+	        StringBuilder buf = new StringBuilder();
+	        buf.append("<html><body bgcolor=\"white\"><Div Align=\"center\"><Font Size=\"4\">");
+	        buf.append(((String)o).replaceAll("\\n", "<br>"));
+	        buf.append("</Font></div></body></html>");
+	        ev.setToolTip(buf.toString());
+		} else if (name.equals("EDGE_LINE_WIDTH")){
+			if (ev.getStrokeWidth() != ((Number)o).floatValue()) {
+				final BasicStroke oldValue = (BasicStroke) ev.getStroke();
+				final Stroke newLine = new BasicStroke(((Number)o).floatValue(), oldValue.getEndCap(), oldValue.getLineJoin(),
+						oldValue.getMiterLimit(), oldValue.getDashArray(), oldValue.getDashPhase() );
+			
+				//System.out.println("*** o = " + o + ", new w = " + ev.getStrokeWidth());
+				
+				ev.setStroke(newLine);
+				//System.out.println("Changed w = " + ev.getStrokeWidth());
+			}
+		} else if (name.equals("EDGE_SRCARROW_COLOR")){
+			final Paint newSourceArrowColor = ((Color) o);
+
+			if (newSourceArrowColor != ev.getSourceEdgeEndPaint())
+				ev.setSourceEdgeEndPaint(newSourceArrowColor);
+		} else if (name.equals("EDGE_TGTARROW_COLOR")){
+
+			final Paint newTargetArrowColor = ((Color) o);
+
+			if (newTargetArrowColor != ev.getTargetEdgeEndPaint())
+				ev.setTargetEdgeEndPaint(newTargetArrowColor);
+		} else if (name.equals("EDGE_OPACITY")){
+			Integer tp = ((Color) ev.getUnselectedPaint()).getAlpha();
+			Integer newTp = ((Number) o).intValue();
+
+			if (tp != newTp) {
+				final Color oldPaint = (Color) ev.getUnselectedPaint();
+				ev.setUnselectedPaint(new Color(oldPaint.getRed(), oldPaint.getGreen(),
+				                                oldPaint.getBlue(), newTp));
+			}
+		} else if (name.equals("EDGE_LABEL_OPACITY")){
+			Integer tp = ((Color) ev.getLabel().getTextPaint()).getAlpha();
+			Integer newTp = ((Number) o).intValue();
+
+			if (tp != newTp) {
+				final Color oldPaint = (Color) ev.getLabel().getTextPaint();
+				ev.getLabel().setTextPaint(new Color(oldPaint.getRed(), oldPaint.getGreen(),
+				                                oldPaint.getBlue(), newTp));
+			}
+		} else if (name.equals("EDGE_SRCARROW_OPACITY")){
+			final Color oldPaint = (Color) ev.getSourceEdgeEndPaint();
+			Integer tp = oldPaint.getAlpha();
+			Integer newTp = ((Number) o).intValue();
+
+			if (tp != newTp) {
+				ev.setSourceEdgeEndPaint(new Color(oldPaint.getRed(), oldPaint.getGreen(), 
+				                                   oldPaint.getBlue(), newTp));
+			}
+		} else if (name.equals("EDGE_TGTARROW_OPACITY")){
+			final Color oldPaint = (Color) ev.getTargetEdgeEndPaint();
+			Integer tp = oldPaint.getAlpha();
+			Integer newTp = ((Number) o).intValue();
+
+			if (tp != newTp) {
+				ev.setTargetEdgeEndPaint(new Color(oldPaint.getRed(), oldPaint.getGreen(), 
+				                                   oldPaint.getBlue(), newTp));
+			}
+		} else if (name.equals("EDGE_LABEL_POSITION")){
+			/* this was commented out in EdgeLabelPositionProp.java (??) */
+		} else {
+			System.out.println("unhandled VisualProperty! (apply to EdgeView): "+name);
+		}
+	}
+
+	public void applyToNodeView(NodeView nv, Object o) {
+		if ((o == null) || (nv == null))
+			return;
+		
+		if (name.equals("NODE_FILL_COLOR")){
+			nv.setUnselectedPaint((Paint)o);
+		} else if (name.equals("NODE_BORDER_COLOR")){
+			nv.setBorderPaint((Paint)o);
+		} else if (name.equals("NODE_OPACITY")){ // FIXME
+			// already moved to NodeRenderer-style
+		} else if (name.equals("NODE_BORDER_OPACITY")){ // FIXME
+			// already moved to NodeRenderer-style
+		} else if (name.equals("NODE_LABEL_OPACITY")){
+			Integer tp = ((Color) nv.getLabel().getTextPaint()).getAlpha();
+			Integer newTp = ((Number) o).intValue();
+
+			if (tp != newTp) {
+				final Color oldPaint = (Color) nv.getLabel().getTextPaint();
+				nv.getLabel().setTextPaint(new Color(oldPaint.getRed(), oldPaint.getGreen(),
+				                                oldPaint.getBlue(), newTp));
+			}
+		} else if (name.equals("NODE_SIZE")){
+			double size = ((Number) o).doubleValue();
+			double difference = size - nv.getHeight();
+
+			if (Math.abs(difference) > 0.1)
+				nv.setHeight(size);
+
+			difference = size - nv.getWidth();
+
+			if (Math.abs(difference) > 0.1)
+				nv.setWidth(size);
+		} else if (name.equals("NODE_WIDTH")){
+			double width = ((Number) o).doubleValue();
+			double difference = width - nv.getWidth();
+
+			if (Math.abs(difference) > 0.1)
+				nv.setWidth(width);
+		} else if (name.equals("NODE_HEIGHT")){
+
+			double height = ((Number) o).doubleValue();
+			double difference = height - nv.getHeight();
+
+			if (Math.abs(difference) > 0.1)
+				nv.setHeight(height);
+		} else if (name.equals("NODE_LABEL")){
+			Label nodelabel = nv.getLabel();
+
+			if (!((String) o).equals(nodelabel.getText()))
+				nodelabel.setText((String) o);
+		} else if (name.equals("NODE_FONT_FACE")){
+			Label nodelabel = nv.getLabel();
+
+			if (!((Font) o).equals(nodelabel.getFont()))
+				nodelabel.setFont((Font) o);
+		} else if (name.equals("NODE_BORDER_COLOR")){
+			
+		} else if (name.equals("NODE_FONT_SIZE")){
+			Label nodelabel = nv.getLabel();
+			Font f = nodelabel.getFont();
+			float newFontSize = ((Number) o).floatValue();
+
+			if (newFontSize != f.getSize2D())
+				nodelabel.setFont(f.deriveFont(newFontSize));
+		} else if (name.equals("NODE_LABEL_COLOR")){
+			Label nodelabel = nv.getLabel();
+
+			if (!((Color) o).equals(nodelabel.getTextPaint()))
+				nodelabel.setTextPaint((Color) o);
+		} else if (name.equals("NODE_TOOLTIP")){
+			if(((String)o).startsWith("<html>")) {
+				nv.setToolTip((String) o);
+				return;
+			}
+
+			// Setting the tooltip to null is preferred because otherwise a small icon
+			// indicating the empty tooltip appears.
+			if (((String)o).equals("")) {
+				nv.setToolTip(null);
+				return;
+			}
+			
+			StringBuilder buf = new StringBuilder();
+			buf.append("<html><body bgcolor=\"white\"><Div Align=\"center\"><Font Size=\"4\">");
+			buf.append(((String)o).replaceAll("\\n", "<br>"));
+			buf.append("</Font></div></body></html>");
+			nv.setToolTip(buf.toString());
+		} else if (name.equals("NODE_LABEL_POSITION")){
+			Label nodelabel = nv.getLabel();
+			LabelPosition labelPosition = (LabelPosition) o;
+
+			int newTextAnchor = labelPosition.getLabelAnchor();
+
+			if (nodelabel.getTextAnchor() != newTextAnchor)
+				nodelabel.setTextAnchor(newTextAnchor);
+
+			int newJustify = labelPosition.getJustify();
+
+			if (nodelabel.getJustify() != newJustify)
+				nodelabel.setJustify(newJustify);
+
+			int newNodeAnchor = labelPosition.getTargetAnchor();
+
+			if (nv.getNodeLabelAnchor() != newNodeAnchor)
+				nv.setNodeLabelAnchor(newNodeAnchor);
+
+			double newOffsetX = labelPosition.getOffsetX();
+
+			if (nv.getLabelOffsetX() != newOffsetX)
+				nv.setLabelOffsetX(newOffsetX);
+
+			double newOffsetY = labelPosition.getOffsetY();
+
+			if (nv.getLabelOffsetY() != newOffsetY)
+				nv.setLabelOffsetY(newOffsetY);
+		} else {
+			System.out.println("unhandled VisualProperty! (apply to NodeView): "+name);
+		}
+
+	}
+
+	public Object getDefaultAppearanceObject() {
+		// FIXME FIXME: refactor
+		if (name.equals("NODE_FILL_COLOR")){
+			return Color.orange;
+		} else if (name.equals("NODE_BORDER_COLOR")){
+			return Color.black;
+		} else if (name.equals("NODE_OPACITY")){
+			return Integer.valueOf(255);
+		} else if (name.equals("NODE_BORDER_OPACITY")){
+			return Integer.valueOf(255);
+		} else if (name.equals("NODE_LABEL_OPACITY")){
+			return Integer.valueOf(255);
+		} else if (name.equals("NODE_SIZE")){
+			return new Double(35.0);
+		} else if (name.equals("NODE_WIDTH")){
+			return new Double(70.0);
+		} else if (name.equals("NODE_HEIGHT")){
+			return new Double(30.0);
+		} else if (name.equals("NODE_LABEL")){
+			return "";
+		} else if (name.equals("NODE_FONT_FACE")){
+			return new Font(null, Font.PLAIN, 12);
+		} else if (name.equals("NODE_FONT_SIZE")){
+			return new Float(12.0f);
+		} else if (name.equals("NODE_LABEL_COLOR")){
+			return Color.black;
+		} else if (name.equals("NODE_TOOLTIP")){
+			return "";
+		} else if (name.equals("NODE_LABEL_POSITION")){
+			return new LabelPosition();
+		} else if (name.equals("EDGE_COLOR")){
+			return Color.black;
+		} else if (name.equals("EDGE_LABEL")){
+			return "";
+		} else if (name.equals("EDGE_FONT_FACE")){
+			return new Font("SanSerif", Font.PLAIN, 10);
+		} else if (name.equals("EDGE_FONT_SIZE")){
+			return new Float(10.0f);
+		} else if (name.equals("EDGE_LABEL_COLOR")){
+			return Color.black;
+		} else if (name.equals("EDGE_TOOLTIP")){
+			return ""; 
+		} else if (name.equals("EDGE_LINE_WIDTH")){
+			return new Float(1.0f);
+		} else if (name.equals("EDGE_SRCARROW_COLOR")){
+			return Color.black;
+		} else if (name.equals("EDGE_TGTARROW_COLOR")){
+			return Color.black;
+		} else if (name.equals("EDGE_OPACITY")){
+			return Integer.valueOf(255);
+		} else if (name.equals("EDGE_LABEL_OPACITY")){
+			return Integer.valueOf(255);
+		} else if (name.equals("EDGE_SRCARROW_OPACITY")){
+			return Integer.valueOf(255); 
+		} else if (name.equals("EDGE_TGTARROW_OPACITY")){
+			return Integer.valueOf(255); 
+		} else if (name.equals("EDGE_LABEL_POSITION")){
+			return new LabelPosition();
+		} else {
+			System.out.println("unhandled VisualProperty! ((getDefaultAppearanceObject)): "+name);
+			return null;
+		}
+	}
+
+	public Icon getDefaultIcon() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	public Icon getIcon(final Object value) {
+		// FIXME FIXME refactor
+		
+		if (name.equals("NODE_FILL_COLOR")){
+			// already moved to NodeRenderer-style
+		} else if (name.equals("NODE_BORDER_COLOR")){
+			// already moved to NodeRenderer-style
+		} else if (name.equals("NODE_OPACITY")){
+			// already moved to NodeRenderer-style
+		} else if (name.equals("NODE_BORDER_OPACITY")){
+			// already moved to NodeRenderer-style
+		} else if (name.equals("NODE_LABEL_OPACITY")){
+			final NodeIcon icon = new NodeIcon() {
+				private final static long serialVersionUID = 1202339876356662L;
+						public void paintIcon(Component c, Graphics g, int x, int y) {
+							super.setColor(new Color(10, 10, 10, 0));
+							super.paintIcon(c, g, x, y);
+							g2d.translate(0, -2);
+
+							final Color color = ((Color) getDefaultAppearanceObject()); 
+							g2d.setColor(new Color(color.getRed(), color.getGreen(), color.getBlue(),
+							                       ((Number) value).intValue()));
+							g2d.setStroke(new BasicStroke(2f));
+							g2d.draw(super.newShape);
+							g2d.translate(0, 2);
+
+							g2d.setFont(new Font("SansSerif", Font.BOLD, 24));
+							g2d.setColor(Color.DARK_GRAY);
+							g2d.drawString(value.toString(), c.getX() + 7,
+							               (int) ((c.getHeight() / 2) + 7));
+
+							g2d.setFont(new Font("SansSerif", Font.BOLD, 12));
+						}
+					};
+
+					return icon;
+		} else if (name.equals("NODE_RENDERER")){
+			  return new NodeIcon();
+		} else if (name.equals("NODE_SIZE")){
+			final NodeIcon icon = new NodeIcon() {
+				private final static long serialVersionUID = 1202339876414681L;
+						public void paintIcon(Component c, Graphics g, int x, int y) {
+							super.setColor(new Color(10, 10, 10, 25));
+							super.paintIcon(c, g, x, y);
+							g2d.setFont(new Font("SansSerif", Font.BOLD, 24));
+							g2d.setColor(Color.DARK_GRAY);
+							g2d.drawString(value.toString(), c.getX() + 7,
+							               (int) ((c.getHeight() / 2) + 7));
+							g2d.setFont(new Font("SansSerif", Font.BOLD, 12));
+						}
+					};
+
+					icon.setBottomPadding(-2);
+
+					return icon;
+		} else if (name.equals("NODE_WIDTH")){
+			final NodeIcon icon = new NodeIcon() {
+				private final static long serialVersionUID = 1202339876432876L;
+						public void paintIcon(Component c, Graphics g, int x, int y) {
+							super.setColor(new Color(10, 10, 10, 25));
+							super.paintIcon(c, g, x, y);
+							g2d.setFont(new Font("SansSerif", Font.BOLD, 24));
+							g2d.setColor(Color.DARK_GRAY);
+							g2d.drawString(value.toString(), c.getX() + 7,
+							               (int) ((c.getHeight() / 2) + 7));
+							g2d.setFont(new Font("SansSerif", Font.BOLD, 12));
+						}
+					};
+
+					icon.setBottomPadding(-2);
+
+					return icon;
+		} else if (name.equals("NODE_HEIGHT")){
+			final NodeIcon icon = new NodeIcon() {
+				private final static long serialVersionUID = 1202339876333773L;
+						public void paintIcon(Component c, Graphics g, int x, int y) {
+							super.setColor(new Color(10, 10, 10, 25));
+							super.paintIcon(c, g, x, y);
+							g2d.setFont(new Font("SansSerif", Font.BOLD, 24));
+							g2d.setColor(Color.DARK_GRAY);
+							g2d.drawString(value.toString(), c.getX() + 7,
+							               (int) ((c.getHeight() / 2) + 7));
+							g2d.setFont(new Font("SansSerif", Font.BOLD, 12));
+						}
+					};
+
+					icon.setBottomPadding(-2);
+
+					return icon;
+		} else if (name.equals("NODE_LABEL")){
+			final NodeIcon icon = new NodeIcon() {
+				private final static long serialVersionUID = 1202339876377140L;
+						public void paintIcon(Component c, Graphics g, int x, int y) {
+							super.setColor(new Color(10, 10, 10, 25));
+							super.paintIcon(c, g, x, y);
+							g2d.setFont(new Font("SansSerif", Font.BOLD, 8));
+							g2d.setColor(Color.DARK_GRAY);
+							
+							String defLabel = value.toString();
+							if(defLabel.length()>15) {
+								defLabel = defLabel.substring(0, 14) + "...";
+							}
+							g2d.drawString(defLabel, c.getX() + 7,
+							               (int) ((c.getHeight() / 2)));
+							g2d.setFont(new Font("SansSerif", Font.BOLD, 12));
+						}
+					};
+
+					icon.setBottomPadding(-2);
+
+					return icon;
+		} else if (name.equals("NODE_FONT_FACE")){
+			return new LineTypeIcon() {
+				private final static long serialVersionUID = 1202339875930797L;
+							public void paintIcon(Component c, Graphics g, int x, int y) {
+								super.setColor(new Color(10, 10, 10, 0));
+								super.paintIcon(c, g, x, y);
+								g2d.setFont(new Font("SansSerif", Font.BOLD, 14));
+								g2d.setColor(Color.DARK_GRAY);
+
+								final Font font = (Font) value;
+								g2d.setFont(new Font(font.getFontName(), font.getStyle(), 40));
+								g2d.setColor(new Color(10, 10, 10, 40));
+								g2d.drawString("Font", c.getX() + 15, c.getY() - 10);
+								g2d.setFont(new Font("SansSerif", Font.BOLD, 14));
+							}
+						};
+		} else if (name.equals("NODE_BORDER_COLOR")){
+			// already moved to NodeRenderer-style
+		} else if (name.equals("NODE_FONT_SIZE")){
+			final NodeIcon icon = new NodeIcon() {
+				private final static long serialVersionUID = 1202339876324715L;
+						public void paintIcon(Component c, Graphics g, int x, int y) {
+							super.setColor(new Color(10, 10, 10, 25));
+							super.paintIcon(c, g, x, y);
+
+							g2d.setFont(new Font("SansSerif", Font.BOLD, 24));
+							g2d.setColor(Color.DARK_GRAY);
+							g2d.drawString(value.toString(), c.getX() + 7,
+							               (int) ((c.getHeight() / 2) + 7));
+
+							g2d.setFont(new Font("SansSerif", Font.BOLD, 12));
+						}
+					};
+
+					return icon;
+		} else if (name.equals("NODE_LABEL_COLOR")){
+			final LineTypeIcon icon = new LineTypeIcon();
+			icon.setColor(new Color(10, 10, 10, 0));
+			icon.setText("Font");
+
+			final Color fontColor = (Color) value;
+			final Font defFont = (Font)  VisualPropertyCatalog.getVisualProperty("NODE_FONT_FACE").getDefaultAppearanceObject();
+			icon.setTextFont(new Font(defFont.getFontName(), defFont.getStyle(), 24));
+			icon.setBottomPadding(-7);
+			icon.setTextColor(fontColor);
+
+			return icon;
+		} else if (name.equals("NODE_TOOLTIP")){
+			final NodeIcon icon = new NodeIcon() {
+				private final static long serialVersionUID = 1202339876422546L;
+						public void paintIcon(Component c, Graphics g, int x, int y) {
+							super.setColor(new Color(10, 10, 10, 25));
+							super.paintIcon(c, g, x, y);
+							g2d.setFont(new Font("SansSerif", Font.BOLD, 8));
+							g2d.setColor(Color.DARK_GRAY);
+
+							String defLabel = value.toString();
+
+							if (defLabel.length() > 15) {
+								defLabel = defLabel.substring(0, 14) + "...";
+							}
+
+							g2d.drawString(defLabel, c.getX() + 7, (int) ((c.getHeight() / 2)));
+							g2d.setFont(new Font("SansSerif", Font.BOLD, 12));
+						}
+					};
+
+					icon.setBottomPadding(-2);
+
+					return icon;
+		} else if (name.equals("NODE_LABEL_POSITION")){
+			int size = 55;
+
+			final BufferedImage bi = new BufferedImage(size, size, BufferedImage.TYPE_INT_RGB);
+			Graphics2D g2 = bi.createGraphics();
+
+			LabelPlacerGraphic lp = new LabelPlacerGraphic((LabelPosition) value, size, false);
+			lp.paint(g2);
+
+			NodeIcon icon = new NodeIcon() {
+				private final static long serialVersionUID = 1202339876366750L;
+				public void paintIcon(Component c, Graphics g, int x, int y) {
+					super.setColor(new Color(10, 10, 10, 0));
+					super.paintIcon(c, g, x, y);
+					g2d.drawImage(bi, 10, -5, null);
+				}
+			};
+
+			return icon;
+		} else if (name.equals("EDGE_COLOR")){
+			final LineTypeIcon icon = new LineTypeIcon();
+			icon.setColor((Color) value);
+			icon.setBottomPadding(-7);
+
+			return icon;
+		} else if (name.equals("EDGE_LABEL")){
+			return null;
+		} else if (name.equals("EDGE_FONT_FACE")){
+			return new LineTypeIcon() {
+				private final static long serialVersionUID = 1202339875930797L;
+							public void paintIcon(Component c, Graphics g, int x, int y) {
+								super.setColor(new Color(10, 10, 10, 0));
+								super.paintIcon(c, g, x, y);
+								g2d.setFont(new Font("SansSerif", Font.BOLD, 14));
+								g2d.setColor(Color.DARK_GRAY);
+
+								final Font font = (Font) value;
+								g2d.setFont(new Font(font.getFontName(), font.getStyle(), 40));
+								g2d.setColor(new Color(10, 10, 10, 40));
+								g2d.drawString("Font", c.getX() + 15, c.getY() - 10);
+								g2d.setFont(new Font("SansSerif", Font.BOLD, 14));
+							}
+						};
+		} else if (name.equals("EDGE_FONT_SIZE")){
+			final LineTypeIcon icon = new LineTypeIcon();
+			icon.setColor(new Color(10, 10, 10, 20));
+			icon.setText(value.toString());
+			icon.setBottomPadding(-7);
+
+			return icon;
+		} else if (name.equals("EDGE_LABEL_COLOR")){
+			final NodeIcon icon = new NodeIcon() {
+				private final static long serialVersionUID = 1202339876345568L;
+						public void paintIcon(Component c, Graphics g, int x, int y) {
+							super.setColor(new Color(10, 10, 10, 0));
+							super.paintIcon(c, g, x, y);
+
+							g2d.setColor((Color) value);
+
+							final Font font = (Font) VisualPropertyCatalog.getVisualProperty("NODE_FONT_FACE").getDefaultAppearanceObject(); 
+							g2d.setFont(new Font(font.getFontName(), font.getStyle(), 28));
+							g2d.drawString("Label", 8, (c.getHeight() / 2) + 10);
+							g2d.setFont(new Font("SansSerif", Font.BOLD, 12));
+						}
+					};
+
+					return icon;
+		} else if (name.equals("EDGE_TOOLTIP")){
+			return null;
+		} else if (name.equals("EDGE_LINE_WIDTH")){
+			final LineTypeIcon icon = new LineTypeIcon();
+			icon.setColor(new Color(10, 10, 10, 20));
+			icon.setText(value.toString());
+			icon.setBottomPadding(-7);
+
+			return icon;
+		} else if (name.equals("EDGE_SRCARROW_COLOR")){
+			final Integer arrow = (Integer) VisualPropertyCatalog.getVisualProperty("EDGE_SRCARROW_SHAPE").getDefaultAppearanceObject();
+			final ArrowIcon icon = new ArrowIcon(GraphGraphics.getArrowShapes().get(new Byte(arrow.byteValue())));
+			icon.setColor((Color) value);
+			icon.setLeftPadding(20);
+			icon.setBottomPadding(-6);
+			
+			return icon;
+		} else if (name.equals("EDGE_TGTARROW_COLOR")){
+			final Integer arrowShape = (Integer) VisualPropertyCatalog.getVisualProperty("EDGE_TGTARROW_SHAPE").getDefaultAppearanceObject();
+			final ArrowIcon icon = new ArrowIcon(GraphGraphics.getArrowShapes().get(new Byte(arrowShape.byteValue())));
+			icon.setColor((Color) value);
+			icon.setLeftPadding(20);
+			icon.setBottomPadding(-6);
+
+			return icon;
+		} else if (name.equals("EDGE_OPACITY")){
+			final LineTypeIcon icon = new LineTypeIcon() {
+				private final static long serialVersionUID = 1202339875954385L;
+						public void paintIcon(Component c, Graphics g, int x, int y) {
+							super.setColor(new Color(10, 10, 10, 0));
+							super.paintIcon(c, g, x, y);
+
+							g2d.setFont(new Font("SansSerif", Font.BOLD, 24));
+							g2d.setColor(Color.DARK_GRAY);
+							g2d.drawString(value.toString(),
+							               c.getX() + ((LineTypeIcon.DEFAULT_ICON_SIZE * 3) / 2),
+							               (int) ((c.getHeight() / 2) + 7));
+
+							g2d.setFont(new Font("SansSerif", Font.BOLD, 12));
+						}
+					};
+
+					return icon;
+		} else if (name.equals("EDGE_LABEL_OPACITY")){
+			final LineTypeIcon icon = new LineTypeIcon() {
+				private final static long serialVersionUID = 1202339875942467L;
+						public void paintIcon(Component c, Graphics g, int x, int y) {
+							super.setColor(new Color(10, 10, 10, 0));
+							super.paintIcon(c, g, x, y);
+							g2d.setFont(new Font("SansSerif", Font.BOLD, 24));
+							g2d.setColor(Color.DARK_GRAY);
+							g2d.drawString(value.toString(), c.getX() + LineTypeIcon.DEFAULT_ICON_SIZE*3/2,
+							               (int) ((c.getHeight() / 2) + 7));
+
+							g2d.setFont(new Font("SansSerif", Font.BOLD, 12));
+						}
+					};
+					return icon;
+		} else if (name.equals("EDGE_SRCARROW_OPACITY")){
+			 final LineTypeIcon icon = new LineTypeIcon() {
+					private final static long serialVersionUID = 1202339875970881L;
+				            public void paintIcon(Component c, Graphics g, int x, int y) {
+				                super.setColor(new Color(10, 10, 10, 0));
+				                super.paintIcon(c, g, x, y);
+
+				                g2d.setFont(new Font("SansSerif", Font.BOLD, 24));
+				                g2d.setColor(Color.DARK_GRAY);
+				                g2d.drawString(value.toString(),
+				                               c.getX() + ((LineTypeIcon.DEFAULT_ICON_SIZE * 3) / 2),
+				                               (int) ((c.getHeight() / 2) + 7));
+
+				                g2d.setFont(new Font("SansSerif", Font.BOLD, 12));
+				            }
+				        };
+
+				        return icon;
+		} else if (name.equals("EDGE_TGTARROW_OPACITY")){
+			 final LineTypeIcon icon = new LineTypeIcon() {
+					private final static long serialVersionUID = 1202339876271830L;
+				            public void paintIcon(Component c, Graphics g, int x, int y) {
+				                super.setColor(new Color(10, 10, 10, 0));
+				                super.paintIcon(c, g, x, y);
+
+				                g2d.setFont(new Font("SansSerif", Font.BOLD, 24));
+				                g2d.setColor(Color.DARK_GRAY);
+				                g2d.drawString(value.toString(),
+				                               c.getX() + ((LineTypeIcon.DEFAULT_ICON_SIZE * 3) / 2),
+				                               (int) ((c.getHeight() / 2) + 7));
+
+				                g2d.setFont(new Font("SansSerif", Font.BOLD, 12));
+				            }
+				        };
+
+				        return icon;
+		} else if (name.equals("EDGE_LABEL_POSITION")){
+			return null;
+		} else {
+			System.out.println("unhandled VisualProperty! (getIcon): "+name);
+			return null;
+		}
+		return null;
+	}
+
+	public Map<Object, Icon> getIconSet() {
+		// this method is not applicable to any VisualProperty handled in this class
+		// (it is only used for DiscreteVisualProperty)
+		return null; // default value
+	}
+
+	public Object parseProperty(Properties props, String baseKey) {
+		// FIXME FIXME -- do IO later
+		return null;
+	}
+	public Object parseStringValue(String string){
+		System.out.println("parsing string value: "+string);
+		ValueParser parser=null;
+		if (dataType.isAssignableFrom(String.class)){
+			return string;
+		} else if (dataType.isAssignableFrom(Number.class)){
+			parser = new DoubleParser(); 
+		} else if  (dataType.isAssignableFrom(Color.class)){
+			parser = new ColorParser(); 
+		} else if (dataType.isAssignableFrom(Font.class)){
+			parser = new FontParser(); 
+		}
+		Object o = parser.parseStringValue(string);
+		System.out.println("parsed value: "+o);
+		return o;
+	}
+	
+	public String getName() {
+		return name;
+	}
+	/**
+	 * Returns the data type of this VisualProperty.
+	 * @return 
+	 */
+	public Class getDataType() {
+		return dataType;
+	}
+
+	/**
+	 * Check this visual property is for node or not.
+	 *
+	 * @return true if vp is for node. If false, this is a vp for edge.
+	 */
+	public boolean isNodeProp() {
+		return isNodeProp;
+	}
+	public DependentVisualPropertyCallback dependentVisualPropertyCallback(){
+		return null;
+	}
+}
Index: render.stateful/src/main/java/cytoscape/render/stateful/GraphRenderer.java
===================================================================
--- render.stateful/src/main/java/cytoscape/render/stateful/GraphRenderer.java	(.../trunk)	(revision 14573)
+++ render.stateful/src/main/java/cytoscape/render/stateful/GraphRenderer.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -44,16 +44,18 @@
 import cytoscape.render.immed.EdgeAnchors;
 import cytoscape.render.immed.GraphGraphics;
 
+import org.cytoscape.view.GraphView;
+import org.cytoscape.view.NodeView;
+import org.cytoscape.view.renderers.NodeRenderer;
+
 import cytoscape.util.intr.IntEnumerator;
 import cytoscape.util.intr.IntHash;
 
-import java.awt.Color;
 import java.awt.Font;
 import java.awt.Paint;
-import java.awt.Shape;
+import java.awt.Graphics2D;
 import java.awt.geom.GeneralPath;
 import java.awt.geom.PathIterator;
-import java.util.Iterator;
 
 
 /**
@@ -141,14 +143,14 @@
 	 * @return bits representing the level of detail that was rendered; the
 	 *   return value is a bitwise-or'ed value of the LOD_* constants.
 	 */
-	public final static int renderGraph(final FixedGraph graph, final SpacialIndex2D nodePositions,
+	public final static int renderGraph(final FixedGraph graph, final GraphView graphView, final SpacialIndex2D nodePositions,
 	                                    final GraphLOD lod, final NodeDetails nodeDetails,
 	                                    final EdgeDetails edgeDetails, final IntHash nodeBuff,
 	                                    final GraphGraphics grafx, final Paint bgPaint,
 	                                    final double xCenter, final double yCenter,
 	                                    final double scaleFactor) {
 		nodeBuff.empty(); // Make sure we keep our promise.
-
+		
 		// Define the visible window in node coordinate space.
 		final float xMin;
 
@@ -465,17 +467,8 @@
 
 									if ((anchorSize = edgeDetails.anchorSize(edge, k)) > 0.0f) {
 										anchors.getAnchor(k, floatBuff4, 0);
-										grafx.drawNodeFull(GraphGraphics.SHAPE_RECTANGLE,
-										                   (float) (floatBuff4[0]
-										                   - (anchorSize / 2.0d)),
-										                   (float) (floatBuff4[1]
-										                   - (anchorSize / 2.0d)),
-										                   (float) (floatBuff4[0]
-										                   + (anchorSize / 2.0d)),
-										                   (float) (floatBuff4[1]
-										                   + (anchorSize / 2.0d)),
-										                   edgeDetails.anchorPaint(edge, k), 0.0f,
-										                   null);
+										grafx.drawEdgeAnchor(floatBuff4[0], floatBuff4[1], anchorSize,
+										                   edgeDetails.anchorPaint(edge, k));
 									}
 								}
 							}
@@ -666,93 +659,22 @@
 						                  floatBuff1[3], nodeDetails.colorLowDetail(node));
 				}
 			} else { // High detail.
+				Graphics2D canvas = grafx.getCanvas();
 
 				while (nodeHits.numRemaining() > 0) {
 					final int node = nodeHits.nextExtents(floatBuff1, 0);
 
 					if ((floatBuff1[0] != floatBuff1[2]) && (floatBuff1[1] != floatBuff1[3])) {
-						// Compute visual attributes that do not depend on LOD.
-						final byte shape = nodeDetails.shape(node);
-						final Paint fillPaint = nodeDetails.fillPaint(node);
-
-						// Compute node border information.
-						final float borderWidth;
-						final Paint borderPaint;
-
-						if ((lodBits & LOD_NODE_BORDERS) == 0) { // Not rendering borders.
-							borderWidth = 0.0f;
-							borderPaint = null;
-						} else { // Rendering node borders.
-							borderWidth = nodeDetails.borderWidth(node);
-
-							if (borderWidth == 0.0f)
-								borderPaint = null;
-							else
-								borderPaint = nodeDetails.borderPaint(node);
+						NodeView nodeView = (NodeView) graphView.getNodeView(~node); // need to ~ because nodeHits stores node indices that way
+						NodeRenderer nodeRenderer = nodeView.getRenderer();
+						if (nodeRenderer != null){
+							nodeRenderer.render(canvas, nodeDetails, floatBuff1, node, nodeView);							
+						} else {
+							System.out.println("unable to render: nodeRenderer is null!");
 						}
-
-						// Draw the node.
-						grafx.drawNodeFull(shape, floatBuff1[0], floatBuff1[1], floatBuff1[2],
-						                   floatBuff1[3], fillPaint, borderWidth, borderPaint);
-					}
-
-					// Take care of custom graphic rendering.
-					if ((lodBits & LOD_CUSTOM_GRAPHICS) != 0) {
-					    // NOTE: The following block of code should be removed when the deprecated index-based API
-					    //       methods are removed:
-					    // BEGIN BLOCK TO REMOVE.						
-					    final int graphicCount = nodeDetails.graphicCount(node);
-
-						for (int graphicInx = 0; graphicInx < graphicCount; graphicInx++) {
-							final Shape gShape = nodeDetails.graphicShape(node, graphicInx);
-							final Paint paint = nodeDetails.graphicPaint(node, graphicInx);
-							final byte anchor = nodeDetails.graphicNodeAnchor(node, graphicInx);
-				// Shouldn't these be graphicOffsetVectorX and Y versus labelOffsetVectorX and Y:
-										final float offsetVectorX = nodeDetails.labelOffsetVectorX(node,
-							                                                           graphicInx);
-							final float offsetVectorY = nodeDetails.labelOffsetVectorY(node,
-							                                                           graphicInx);
-							doubleBuff1[0] = floatBuff1[0];
-							doubleBuff1[1] = floatBuff1[1];
-							doubleBuff1[2] = floatBuff1[2];
-							doubleBuff1[3] = floatBuff1[3];
-							lemma_computeAnchor(anchor, doubleBuff1, doubleBuff2);
-							grafx.drawCustomGraphicFull(gShape,
-							                            (float) (doubleBuff2[0] + offsetVectorX),
-							                            (float) (doubleBuff2[1] + offsetVectorY),
-							                            paint);
 						
 					}
-						// END BLOCK TO REMOVE.
 
-						// don't allow our custom graphics to mutate while we iterate over them:
-						synchronized (nodeDetails.customGraphicsLock(node)) {
-						    // This iterator will return CustomGraphics in rendering order:
-						    Iterator<CustomGraphic> dNodeIt = nodeDetails.customGraphics (node);
-						    CustomGraphic cg = null;
-						    // The graphic index used to retrieve non custom graphic info corresponds to the zero-based
-						    // index of the CustomGraphic returned by the iterator:
-						    int graphicInx = 0;
-						    while (dNodeIt.hasNext()) {
-							cg = dNodeIt.next();
-							final float offsetVectorX = nodeDetails.labelOffsetVectorX(node,
-														   graphicInx);
-							final float offsetVectorY = nodeDetails.labelOffsetVectorY(node,
-														   graphicInx);
-							doubleBuff1[0] = floatBuff1[0];
-							doubleBuff1[1] = floatBuff1[1];
-							doubleBuff1[2] = floatBuff1[2];
-							doubleBuff1[3] = floatBuff1[3];
-							lemma_computeAnchor(cg.getAnchor(), doubleBuff1, doubleBuff2);
-							grafx.drawCustomGraphicFull(cg.getShape(),
-										    (float) (doubleBuff2[0] + offsetVectorX),
-										    (float) (doubleBuff2[1] + offsetVectorY),
-										    cg.getPaint());
-							graphicInx++;
-						    }
-						}
-					}
-
 					// Take care of label rendering.
 					if ((lodBits & LOD_NODE_LABELS) != 0) { // Potential label rendering.
 
Index: render.stateful/src/main/java/cytoscape/render/stateful/NodeDetails.java
===================================================================
--- render.stateful/src/main/java/cytoscape/render/stateful/NodeDetails.java	(.../trunk)	(revision 14573)
+++ render.stateful/src/main/java/cytoscape/render/stateful/NodeDetails.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -37,7 +37,6 @@
 package cytoscape.render.stateful;
 
 import cytoscape.render.immed.GraphGraphics;
-import cytoscape.render.stateful.CustomGraphic;
 
 import java.awt.Color;
 import java.awt.Font;
@@ -174,33 +173,6 @@
 	}
 
 	/**
-	 * Returns the paint of the interior of the node shape.  By default this
-	 * method returns Color.red.  It is an error to return null in this method.
-	 */
-	public Paint fillPaint(final int node) {
-		return Color.red;
-	}
-
-	/**
-	 * Returns the border width of the node shape.  By default this method
-	 * returns zero.  Take note of certain constraints specified in
-	 * GraphGraphics.drawNodeFull().
-	 */
-	public float borderWidth(final int node) {
-		return 0.0f;
-	}
-
-	/**
-	 * Returns the paint of the border of the node shape.  By default this method
-	 * returns null.  This return value is ignored if borderWidth(node)
-	 * returns zero; it is an error to return null if borderWidth(node) returns
-	 * a value greater than zero.
-	 */
-	public Paint borderPaint(final int node) {
-		return null;
-	}
-
-	/**
 	 * Returns the number of labels that this node has.  By default this method
 	 * returns zero.
 	 */
@@ -367,40 +339,6 @@
 	}
 
 	/**
-	 * Returns the number of custom graphics that this node has.  By default this
-	 * method returns zero.  A custom graphic extends the concept of node label
-	 * to include any arbitrary filled shape.
-	 */
-	public int graphicCount(final int node) {
-		return 0;
-	}
-
-	/**
-	 * Returns a custom graphic's shape.  This shape will be filled by the
-	 * rendering engine.  By default this method always returns null.  This
-	 * method is only called by the rendering engine if graphicCount(node)
-	 * returns a value greater than zero.  It is an error to return null if
-	 * this method is called by the rendering engine.
-	 * @param graphicInx a value in the range [0, graphicCount(node)-1]
-	 *   indicating which node graphic in question.
-	 */
-	public Shape graphicShape(final int node, final int graphicInx) {
-		return null;
-	}
-
-	/**
-	 * Returns the fill paint of a custom graphic.  By default this
-	 * method always returns null.  This method is only called by the rendering
-	 * engine if graphicCount(node) returns a value greater than zero.  It is
-	 * an error to return null if this method is called by the rendering engine.
-	 * @param graphicInx a value in the range [0, graphicCount(node)-1]
-	 *   indicating which node graphic in question.
-	 */
-	public Paint graphicPaint(final int node, final int graphicInx) {
-		return null;
-	}
-
-	/**
 	 * By returning one of the ANCHOR_* constants, specifies
 	 * where on the node's extents rectangle the graphic anchor point lies.
 	 * The filled shape is rendered at a location which is equal to this
@@ -461,55 +399,6 @@
 	return 0;
     }
 
-    /**
-     * Return a non-null, read-only Iterator over all CustomGraphics contained in this Node.
-     * The Iterator will return each CustomGraphic in draw order.
-     * The Iterator cannot be used to modify the underlying set of CustomGraphics.
-     * NOTE: This method should be abstract, but since it isn't, any real use should override this
-     *       method in a subclass.
-     * @return The CustomGraphics Iterator. If no CustomGraphics are
-     * associated with this Node, an empty Iterator is returned.
-     * @throws UnsupportedOperationException if an attempt is made to use the Iterator's remove() method.
-     * @since Cytoscape 2.6
-     * @see #customGraphicsLock(int)
-     */
-    // Should probably be getCustomGraphics(), but all the methods
-    // seem to have this form.
-    public Iterator<CustomGraphic> customGraphics (final int node) {
-	return new Iterator<CustomGraphic>() {
-	    private Iterator<CustomGraphic> _iterator =  new ArrayList<CustomGraphic>(0).iterator();
-	    public boolean hasNext() {return _iterator.hasNext();}
-	    public CustomGraphic next() {return _iterator.next();}
-	    public void remove() {
-		throw new UnsupportedOperationException();
-	    }
-	};
-    }
-
-    /**
-     * Return the object used for synchronizing custom graphics operations for a given Node.
-     * This is used in conjunction with the customGraphics() Iterator to allow iteration over
-     * the custom graphics without fear of the underlying CustomGraphics mutating.
-     * For example:
-     * <PRE>
-     *    NodeDetails nd = ...;
-     *    synchronized (nd.customGraphicsLock(node)) {
-     *       Iterator<CustomGraphic> dNodeIt = nodeDetails.customGraphics (node);
-     *       CustomGraphic cg = null;
-     *       while (dNodeIt.hasNext()) {
-     *          cg = dNodeIt.next();
-     *          // DO STUFF WITH cg HERE.
-     *       }
-     *    }
-     * </PRE>
-     * NOTE: This method should be abstract, but since it isn't, any real use should override this
-     *       method in a subclass.
-     * @since Cytoscape 2.6
-     */
-    public Object customGraphicsLock(final int node) {
-	return this;
-    }
-
 	/**
 	 * Used to set selected state of given node.
 	 *
Index: render.stateful/src/main/java/cytoscape/render/stateful/CustomGraphic.java
===================================================================
--- render.stateful/src/main/java/cytoscape/render/stateful/CustomGraphic.java	(.../trunk)	(revision 14573)
+++ render.stateful/src/main/java/cytoscape/render/stateful/CustomGraphic.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -1,124 +0,0 @@
-/*
- Copyright (c) 2008, The Cytoscape Consortium (www.cytoscape.org)
-
- The Cytoscape Consortium is:
- - Institute for Systems Biology
- - University of California San Diego
- - Memorial Sloan-Kettering Cancer Center
- - Institut Pasteur
- - Agilent Technologies
-
- This library is free software; you can redistribute it and/or modify it
- under the terms of the GNU Lesser General Public License as published
- by the Free Software Foundation; either version 2.1 of the License, or
- any later version.
-
- This library is distributed in the hope that it will be useful, but
- WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF
- MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  The software and
- documentation provided hereunder is on an "as is" basis, and the
- Institute for Systems Biology and the Whitehead Institute
- have no obligations to provide maintenance, support,
- updates, enhancements or modifications.  In no event shall the
- Institute for Systems Biology and the Whitehead Institute
- be liable to any party for direct, indirect, special,
- incidental or consequential damages, including lost profits, arising
- out of the use of this software and its documentation, even if the
- Institute for Systems Biology and the Whitehead Institute
- have been advised of the possibility of such damage.  See
- the GNU Lesser General Public License for more details.
-
- You should have received a copy of the GNU Lesser General Public License
- along with this library; if not, write to the Free Software Foundation,
- Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
-*/
-
-
-/**
- * Immutable representation of extra graphics associated with a
- * NodeView or EdgeView that are defined by plugins and are
- * independent of visual styles.
- */
-
-package cytoscape.render.stateful;
-
-import java.awt.Paint;
-import java.awt.Shape;
-
-/**
- * Represents all the information needed to define a custom graphic
- * for a given NodeView.
- * <H3>Deprecation Note</H3>
- * The use of CustomGraphic replaces the entire old index-based custom graphic API.
- * This includes all the NodeDetails methods (and their overridden implementations)
- * that refer to custom graphics using indices:
- * <PRE>
- *   public int graphicCount(int node)
- *   public Shape graphicShape(int node, int graphicInx)
- *   public Paint graphicPaint(int node, int graphicInx)
- *   public byte graphicNodeAnchor(int node, int graphicInx)
- * </PRE>
- * <B>To keep things completetly backwards compatible
- * and to avoid introducing bugs, the new API methods are
- * completely independent from the the old API methods.  Thus,
- * a custom graphic added using the new API will not be
- * accessible from the old API and visa versa.</B>
- * <P>The reason for the deprecation is:
- * <OL>
- * <LI>Complexity in managing the indices.
- * <P>In order for multiple plugins to use the old API, each
- * must monitor deletions to custom graphics and update their
- * saved indices, since the indices will shift down as graphics
- * are deleted. This management isn't even possible with the old
- * API because there's no event mechanism to inform plugins when
- * the indices change. Also, each plugin must keep a list of all
- * indices for all graphics added, since the indices may not be
- * contiguous.
- * <LI>There is no way to ensure that an index you want to use
- * will not be used by another plugin by the time you attempt
- * to assign it (thread safety).
- * <P>Using indices forces the need for a locking mechanism to
- * ensure you are guaranteed a unique and correct index
- * independent of any other plugins.
- * </OL>
- * For more information, see <A HREF="http://cbio.mskcc.org/cytoscape/bugs/view.php?id=1500">Mantis Bug 1500</A>.
- * @author Michael L. Creech
- */
-
-public class CustomGraphic {
-    private Shape _shape;
-    private Paint _paint;
-    private byte  _anchor;
-    public CustomGraphic (Shape shape, Paint paint, byte anchor) {
-    	if ((shape == null) || (paint == null))
-    	    throw new IllegalArgumentException("The shape or paint given was null.");
-	if ((anchor < 0) || (anchor > NodeDetails.MAX_ANCHOR_VAL)) {
-    	    throw new IllegalArgumentException("The anchor value " + anchor + " is not in the range 0 <= anchor <= " + NodeDetails.MAX_ANCHOR_VAL + ".");
-	}
-	_shape = shape;
-	_paint = paint;
-	_anchor = anchor;
-    }
-    /**
-     * Return the Shape that makes up this CustomGraphic.
-     */
-    public Shape getShape () {
-	return _shape;
-    }
-    /**
-     * Return the Paint that makes up this CustomGraphic.
-     */
-    public Paint getPaint () {
-	return _paint;
-    }
-
-    /**
-     * Return the anchor for this CustomGraphic.  This specifies where
-     * on the node's extents rectangle the graphic anchor point lies.
-     * The shape is rendered at a location which is equal to this
-     * anchor point plus the offset vector.
-     */
-    public byte getAnchor () {
-	return _anchor;
-    }
-}
Index: render.stateful/pom.xml
===================================================================
--- render.stateful/pom.xml	(.../trunk)	(revision 14573)
+++ render.stateful/pom.xml	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -63,6 +63,12 @@
       <version>1.0-SNAPSHOT</version>
     </dependency>
 
+    <dependency>
+      <groupId>org.cytoscape</groupId>
+      <artifactId>view</artifactId>
+      <version>1.0-SNAPSHOT</version>
+    </dependency>
+
   </dependencies>
 
 </project>
Index: vizmap/osgi.bnd
===================================================================
--- vizmap/osgi.bnd	(.../trunk)	(revision 14573)
+++ vizmap/osgi.bnd	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -2,5 +2,5 @@
 # Use this file to add customized Bnd instructions for the bundle
 #-----------------------------------------------------------------
 
-Export-Package: org.cytoscape.vizmap,org.cytoscape.vizmap.calculators,org.cytoscape.vizmap.mappings,org.cytoscape.vizmap.icon,org.cytoscape.vizmap.mappings.discrete,org.cytoscape.vizmap.mappings.continuous
-Private-Package: org.cytoscape.vizmap.parsers,org.cytoscape.vizmap.properties
+Export-Package: org.cytoscape.vizmap,org.cytoscape.vizmap.calculators,org.cytoscape.vizmap.mappings,org.cytoscape.vizmap.icon,org.cytoscape.vizmap.mappings.discrete,org.cytoscape.vizmap.mappings.continuous,org.cytoscape.vizmap.parsers
+#Private-Package: org.cytoscape.vizmap.parsers,org.cytoscape.vizmap.properties
Index: vizmap/src/main/java/org/cytoscape/vizmap/parsers/NodeShapeParser.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/parsers/NodeShapeParser.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/parsers/NodeShapeParser.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -1,91 +0,0 @@
-/*
-  File: NodeShapeParser.java
-
-  Copyright (c) 2006, The Cytoscape Consortium (www.cytoscape.org)
-
-  The Cytoscape Consortium is:
-  - Institute for Systems Biology
-  - University of California San Diego
-  - Memorial Sloan-Kettering Cancer Center
-  - Institut Pasteur
-  - Agilent Technologies
-
-  This library is free software; you can redistribute it and/or modify it
-  under the terms of the GNU Lesser General Public License as published
-  by the Free Software Foundation; either version 2.1 of the License, or
-  any later version.
-
-  This library is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF
-  MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  The software and
-  documentation provided hereunder is on an "as is" basis, and the
-  Institute for Systems Biology and the Whitehead Institute
-  have no obligations to provide maintenance, support,
-  updates, enhancements or modifications.  In no event shall the
-  Institute for Systems Biology and the Whitehead Institute
-  be liable to any party for direct, indirect, special,
-  incidental or consequential damages, including lost profits, arising
-  out of the use of this software and its documentation, even if the
-  Institute for Systems Biology and the Whitehead Institute
-  have been advised of the possibility of such damage.  See
-  the GNU Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this library; if not, write to the Free Software Foundation,
-  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
-*/
-
-//----------------------------------------------------------------------------
-// $Revision: 12924 $
-// $Date: 2008-02-04 11:10:30 -0800 (Mon, 04 Feb 2008) $
-// $Author: mes $
-//----------------------------------------------------------------------------
-package org.cytoscape.vizmap.parsers;
-
-
-//----------------------------------------------------------------------------
-import org.cytoscape.vizmap.NodeShape;
-import org.cytoscape.vizmap.ValueParser;
-
-
-//----------------------------------------------------------------------------
-/**
- * Parses a String into a yFiles shape, which is represented by a byte
- * identifier. The return value here is a Byte object wrapping the
- * primitive byte identifier.
- */
-public class NodeShapeParser
-    implements ValueParser {
-    /**
-     *  DOCUMENT ME!
-     *
-     * @param value DOCUMENT ME!
-     *
-     * @return  DOCUMENT ME!
-     */
-    public Object parseStringValue(String value) {
-        return parseNodeShapeEnum(value);
-    }
-
-    /**
-     * DOCUMENT ME!
-     *
-     * @param value DOCUMENT ME!
-     *
-     * @return DOCUMENT ME!
-     */
-    public NodeShape parseNodeShapeEnum(String value) {
-        return NodeShape.parseNodeShapeText(value);
-    }
-
-    /**
-     * DOCUMENT ME!
-     *
-     * @param shape DOCUMENT ME!
-     *
-     * @return DOCUMENT ME!
-     */
-    public static boolean isValidShape(NodeShape shape) {
-        return NodeShape.isValidShape(shape);
-    }
-}
Index: vizmap/src/main/java/org/cytoscape/vizmap/parsers/LineStyleParser.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/parsers/LineStyleParser.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/parsers/LineStyleParser.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -1,80 +0,0 @@
-/*
-  File: LineStyleParser.java
-
-  Copyright (c) 2006, The Cytoscape Consortium (www.cytoscape.org)
-
-  The Cytoscape Consortium is:
-  - Institute for Systems Biology
-  - University of California San Diego
-  - Memorial Sloan-Kettering Cancer Center
-  - Institut Pasteur
-  - Agilent Technologies
-
-  This library is free software; you can redistribute it and/or modify it
-  under the terms of the GNU Lesser General Public License as published
-  by the Free Software Foundation; either version 2.1 of the License, or
-  any later version.
-
-  This library is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF
-  MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  The software and
-  documentation provided hereunder is on an "as is" basis, and the
-  Institute for Systems Biology and the Whitehead Institute
-  have no obligations to provide maintenance, support,
-  updates, enhancements or modifications.  In no event shall the
-  Institute for Systems Biology and the Whitehead Institute
-  be liable to any party for direct, indirect, special,
-  incidental or consequential damages, including lost profits, arising
-  out of the use of this software and its documentation, even if the
-  Institute for Systems Biology and the Whitehead Institute
-  have been advised of the possibility of such damage.  See
-  the GNU Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this library; if not, write to the Free Software Foundation,
-  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
-*/
-
-//----------------------------------------------------------------------------
-// $Revision: 10002 $
-// $Date: 2007-04-17 19:05:54 -0700 (Tue, 17 Apr 2007) $
-// $Author: kono $
-//----------------------------------------------------------------------------
-package org.cytoscape.vizmap.parsers;
-
-
-//----------------------------------------------------------------------------
-import org.cytoscape.vizmap.LineStyle;
-import org.cytoscape.vizmap.ValueParser;
-
-
-//----------------------------------------------------------------------------
-/**
- * Parses a String into a yFiles shape, which is represented by a byte
- * identifier. The return value here is a Byte object wrapping the
- * primitive byte identifier.
- */
-public class LineStyleParser
-    implements ValueParser {
-    /**
-     *  DOCUMENT ME!
-     *
-     * @param value DOCUMENT ME!
-     *
-     * @return  DOCUMENT ME!
-     */
-    public Object parseStringValue(String value) {
-        return parseLineStyle(value); 
-    }
-
-    /**
-     *  DOCUMENT ME!
-     *
-     * @param value DOCUMENT ME!
-     *
-     * @return  DOCUMENT ME!
-     */
-    public LineStyle parseLineStyle(String value) {
-        return LineStyle.parse(value); 
-    }
-}
Index: vizmap/src/main/java/org/cytoscape/vizmap/parsers/ArrowShapeParser.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/parsers/ArrowShapeParser.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/parsers/ArrowShapeParser.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -1,29 +0,0 @@
-package org.cytoscape.vizmap.parsers;
-
-import org.cytoscape.vizmap.ArrowShape;
-import org.cytoscape.vizmap.ValueParser;
-
-public class ArrowShapeParser implements ValueParser {
-	
-	/**
-     *  DOCUMENT ME!
-     *
-     * @param value DOCUMENT ME!
-     *
-     * @return  DOCUMENT ME!
-     */
-    public Object parseStringValue(String value) {
-        return parseArrowShape(value); 
-    }
-
-    /**
-     *  DOCUMENT ME!
-     *
-     * @param value DOCUMENT ME!
-     *
-     * @return  DOCUMENT ME!
-     */
-    public ArrowShape parseArrowShape(String value) {
-        return ArrowShape.parseArrowText(value); 
-    }
-}
Index: vizmap/src/main/java/org/cytoscape/vizmap/ObjectToString.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/ObjectToString.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/ObjectToString.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -62,8 +62,6 @@
 			return "";
         else if (o instanceof Color)
             return ColorParser.getRGBText((Color) o);
-        else if (o instanceof NodeShape)
-            return NodeShape.getNodeShapeText((NodeShape) o);
         else if (o instanceof Font)
             return getFontStringValue((Font) o);
         else if (o instanceof Number)
Index: vizmap/src/main/java/org/cytoscape/vizmap/icon/LineTypeIcon.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/icon/LineTypeIcon.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/icon/LineTypeIcon.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -34,11 +34,9 @@
 */
 package org.cytoscape.vizmap.icon;
 
+import org.cytoscape.view.VisualPropertyCatalog;
 import org.cytoscape.vizmap.VMMFactory;
 
-import org.cytoscape.vizmap.VisualPropertyType;
-import org.cytoscape.vizmap.LineStyle;
-
 import java.awt.BasicStroke;
 import java.awt.Color;
 import java.awt.Component;
@@ -70,31 +68,13 @@
 	 * Creates a new LineTypeIcon object.
 	 */
 	public LineTypeIcon() {
-		this((BasicStroke) ((LineStyle) VisualPropertyType.EDGE_LINE_STYLE.getDefault(VMMFactory.getVisualMappingManager()
-		                                                                                    .getVisualStyle()))
-		     .getStroke(2f), DEFAULT_ICON_SIZE * 3, DEFAULT_ICON_SIZE,
-		     ((LineStyle) VisualPropertyType.EDGE_LINE_STYLE
-		      .getDefault(VMMFactory.getVisualMappingManager().getVisualStyle())).toString(),
-		     (Color) VisualPropertyType.EDGE_COLOR.getDefault(VMMFactory.getVisualMappingManager()
-		                                                               .getVisualStyle()));
+		this((Stroke) VMMFactory.getVisualMappingManager().getVisualStyle().getDefaultValue(VisualPropertyCatalog.getVisualProperty("EDGE_LINE_STYLE")),
+			DEFAULT_ICON_SIZE * 3, DEFAULT_ICON_SIZE, "default LineTypeIcon name", 
+			(Color) VMMFactory.getVisualMappingManager().getVisualStyle().getDefaultValue(VisualPropertyCatalog.getVisualProperty("EDGE_COLOR")) );
 	}
-
-	/**
-	 * Creates a new LineTypeIcon object.
-	 *
-	 * @param lineType  DOCUMENT ME!
-	 */
-	public LineTypeIcon(Object lineStyle) {
-		this((BasicStroke) ((LineStyle) lineStyle).getStroke(2f), DEFAULT_ICON_SIZE * 3,
-		     DEFAULT_ICON_SIZE,
-		     ((LineStyle) lineStyle).toString(),
-		     (Color) VisualPropertyType.EDGE_COLOR.getDefault(VMMFactory.getVisualMappingManager()
-		                                                               .getVisualStyle()));
-	}
 	
-	public LineTypeIcon(org.cytoscape.vizmap.LineStyle style) {
-		this(style.getStroke(2f), DEFAULT_ICON_SIZE * 3,
-			     DEFAULT_ICON_SIZE, style.name());
+	public LineTypeIcon(Stroke stroke) {
+		this(stroke, DEFAULT_ICON_SIZE * 3, DEFAULT_ICON_SIZE, "default name" /* FIXME */);
 	}
 
 	/**
@@ -122,9 +102,7 @@
 	public LineTypeIcon(Stroke stroke, int width, int height, String name, Color color) {
 		super(null, width, height, name, color);
 
-		final float lineWidth = ((Number) VisualPropertyType.EDGE_LINE_WIDTH.getDefault(VMMFactory.getVisualMappingManager()
-		                                                                                         .getVisualStyle()))
-		                        .floatValue();
+		final float lineWidth = ((Number) VMMFactory.getVisualMappingManager().getVisualStyle().getDefaultValue(VisualPropertyCatalog.getVisualProperty("EDGE_LINE_WIDTH"))).floatValue(); 
 
 		final BasicStroke st = (BasicStroke) stroke;
 		/*
Index: vizmap/src/main/java/org/cytoscape/vizmap/icon/ArrowIcon.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/icon/ArrowIcon.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/icon/ArrowIcon.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -36,9 +36,6 @@
 
 import org.cytoscape.vizmap.VMMFactory;
 
-import org.cytoscape.vizmap.ArrowShape;
-import org.cytoscape.vizmap.VisualPropertyType;
-
 import java.awt.BasicStroke;
 import java.awt.Color;
 import java.awt.Component;
@@ -71,10 +68,8 @@
 	 * Creates a new ArrowIcon object.
 	 */
 	public ArrowIcon(Shape shape) {
-		this(shape, DEFAULT_ICON_SIZE * 3, DEFAULT_ICON_SIZE,
-		     ((ArrowShape)VisualPropertyType.EDGE_SRCARROW_SHAPE
-		      .getDefault(VMMFactory.getVisualMappingManager().getVisualStyle())).getName(), 
-			  DEFAULT_ICON_COLOR);
+		// FIXME: when name was set from Arrowhead-shape
+		this(shape, DEFAULT_ICON_SIZE * 3, DEFAULT_ICON_SIZE, "default ArrowIcon name", DEFAULT_ICON_COLOR); 
 	}
 
 	/**
Index: vizmap/src/main/java/org/cytoscape/vizmap/icon/NodeIcon.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/icon/NodeIcon.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/icon/NodeIcon.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -35,9 +35,9 @@
 package org.cytoscape.vizmap.icon;
 
 import org.cytoscape.vizmap.VMMFactory;
+import org.cytoscape.view.VisualPropertyCatalog;
 
-import org.cytoscape.vizmap.NodeShape;
-import org.cytoscape.vizmap.VisualPropertyType;
+import cytoscape.render.immed.GraphGraphics;
 
 import java.awt.BasicStroke;
 import java.awt.Color;
@@ -48,6 +48,7 @@
 import java.awt.Shape;
 import java.awt.geom.AffineTransform;
 import java.awt.geom.Rectangle2D;
+import java.util.Map;
 
 
 /**
@@ -67,18 +68,14 @@
 	 * Creates a new NodeIcon object.
 	 */
 	public NodeIcon() {
-		this(((NodeShape) (VisualPropertyType.NODE_SHAPE.getDefault(VMMFactory.getVisualMappingManager()
-		                                                                     .getVisualStyle())))
-		                                                               .getShape(),
+		this(Integer.valueOf(0), //FIXME: use first shape as default value note:this was pre-visual style default previously, but we want to use it for NodeRenderer's icons
 		     DEFAULT_ICON_SIZE, DEFAULT_ICON_SIZE,
-		     ((NodeShape) (VisualPropertyType.NODE_SHAPE.getDefault(VMMFactory.getVisualMappingManager()
-		                                                                     .getVisualStyle())))
-		                                                                   .getShapeName(),
+			 "some default name" /*FIXME*/,
 		     DEFAULT_ICON_COLOR);
 	}
 	
-	public NodeIcon(NodeShape ns) {
-		this(ns.getShape(), DEFAULT_ICON_SIZE, DEFAULT_ICON_SIZE, ns.getShapeName(), DEFAULT_ICON_COLOR);
+	public NodeIcon(Shape s) {
+		this(s, DEFAULT_ICON_SIZE, DEFAULT_ICON_SIZE, "some shape"/*FIXME: names!! */, DEFAULT_ICON_COLOR);
 	}
 
 	/**
@@ -108,6 +105,12 @@
 		adjustShape();
 	}
 
+	public NodeIcon(Integer shape_code, int width, int height, String name, Color color) {
+		super(GraphGraphics.getNodeShapes().get(new Byte(shape_code.byteValue())), width, height, name, color);
+
+		adjustShape();
+	}
+
 	/**
 	 * DOCUMENT ME!
 	 *
Index: vizmap/src/main/java/org/cytoscape/vizmap/VisualMappingManager.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/VisualMappingManager.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/VisualMappingManager.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -87,11 +87,6 @@
 	private GraphView networkView; // the object displaying the network
 	private VisualStyle activeVS; // the currently active visual style
 
-	// reusable appearance objects
-	private NodeAppearance myNodeApp = new NodeAppearance();
-	private EdgeAppearance myEdgeApp = new EdgeAppearance();
-	private GlobalAppearance myGlobalApp = new GlobalAppearance();
-
 	private static final String DEF_STYLE_NAME = "default";
 
 	/**
@@ -212,145 +207,4 @@
 		else
 			return activeVS;
 	}
-
-	/**
-	 * Recalculates and reapplies all of the node appearances. The visual
-	 * attributes are calculated by delegating to the NodeAppearanceCalculator
-	 * member of the current visual style.
-	 */
-	public void applyNodeAppearances() {
-		applyNodeAppearances(getNetwork(), getNetworkView());
-	}
-
-	/**
-	 * Recalculates and reapplies all of the node appearances. The visual
-	 * attributes are calculated by delegating to the NodeAppearanceCalculator
-	 * member of the current visual style.
-	 */
-	public void applyNodeAppearances(final GraphPerspective network, final GraphView network_view) {
-		final NodeAppearanceCalculator nodeAppearanceCalculator = activeVS.getNodeAppearanceCalculator();
-
-		for (Iterator i = network_view.getNodeViewsIterator(); i.hasNext();) {
-			NodeView nodeView = (NodeView) i.next();
-			Node node = nodeView.getNode();
-
-			nodeAppearanceCalculator.calculateNodeAppearance(myNodeApp, node, network);
-			myNodeApp.applyAppearance(nodeView);
-		}
-	}
-
-	/**
-	 * Recalculates and reapplies all of the edge appearances. The visual
-	 * attributes are calculated by delegating to the EdgeAppearanceCalculator
-	 * member of the current visual style.
-	 */
-	public void applyEdgeAppearances() {
-		applyEdgeAppearances(getNetwork(), getNetworkView());
-	}
-
-	/**
-	 * Recalculates and reapplies all of the edge appearances. The visual
-	 * attributes are calculated by delegating to the EdgeAppearanceCalculator
-	 * member of the current visual style.
-	 */
-	public void applyEdgeAppearances(final GraphPerspective network, final GraphView network_view) {
-		final EdgeAppearanceCalculator edgeAppearanceCalculator = activeVS.getEdgeAppearanceCalculator();
-
-		EdgeView edgeView;
-
-		for (Iterator i = network_view.getEdgeViewsIterator(); i.hasNext();) {
-			edgeView = (EdgeView) i.next();
-
-			if (edgeView == null)
-
-				// WARNING: This is a hack, edgeView should not be null, but
-				// for now do this! (iliana)
-				continue;
-
-			edgeAppearanceCalculator.calculateEdgeAppearance(myEdgeApp, edgeView.getEdge(), network);
-			myEdgeApp.applyAppearance(edgeView);
-		}
-	}
-
-	/**
-	 * Recalculates and reapplies the global visual attributes. The
-	 * recalculation is done by delegating to the GlobalAppearanceCalculator
-	 * member of the current visual style.
-	 */
-	public void applyGlobalAppearances() {
-		applyGlobalAppearances(getNetwork(), getNetworkView());
-	}
-
-	/**
-	 * Recalculates and reapplies the global visual attributes. The
-	 * recalculation is done by delegating to the GlobalAppearanceCalculator
-	 * member of the current visual style.
-	 *
-	 * @param network
-	 *            the network to apply to
-	 * @param network_view
-	 *            the view to apply to
-	 */
-	public void applyGlobalAppearances(GraphPerspective network, GraphView network_view) {
-		GlobalAppearanceCalculator globalAppearanceCalculator = activeVS.getGlobalAppearanceCalculator();
-		globalAppearanceCalculator.calculateGlobalAppearance(myGlobalApp, network);
-
-		// setup proper background colors
-		network_view.setBackgroundPaint(myGlobalApp.getBackgroundColor());
-
-		// will ignore sloppy & reverse selection color for now
-
-		// Set selection colors
-		Iterator nodeIt = network.nodesIterator();
-
-		while (nodeIt.hasNext())
-			network_view.getNodeView((Node) nodeIt.next())
-			            .setSelectedPaint(myGlobalApp.getNodeSelectionColor());
-
-		Iterator edgeIt = network.edgesIterator();
-
-		while (edgeIt.hasNext())
-			network_view.getEdgeView((Edge) edgeIt.next())
-			            .setSelectedPaint(myGlobalApp.getEdgeSelectionColor());
-	}
-
-	/**
-	 * Recalculates and reapplies all of the node, edge, and global visual
-	 * attributes. This method delegates to, in order, applyNodeAppearances,
-	 * applyEdgeAppearances, and applyGlobalAppearances.
-	 */
-	public void applyAppearances() {
-		/** first apply the node appearance to all nodes */
-		applyNodeAppearances();
-		/** then apply the edge appearance to all edges */
-		applyEdgeAppearances();
-		/** now apply global appearances */
-		applyGlobalAppearances();
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @param nodeView DOCUMENT ME!
-	 * @param network_view DOCUMENT ME!
-	 */
-	public void vizmapNode(NodeView nodeView, GraphView network_view) {
-		Node node = (Node) nodeView.getNode();
-		NodeAppearanceCalculator nodeAppearanceCalculator = activeVS.getNodeAppearanceCalculator();
-		nodeAppearanceCalculator.calculateNodeAppearance(myNodeApp, node, network_view.getGraphPerspective());
-		myNodeApp.applyAppearance(nodeView);
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @param edgeView DOCUMENT ME!
-	 * @param network_view DOCUMENT ME!
-	 */
-	public void vizmapEdge(EdgeView edgeView, GraphView network_view) {
-		Edge edge = (Edge) edgeView.getEdge();
-		EdgeAppearanceCalculator edgeAppearanceCalculator = activeVS.getEdgeAppearanceCalculator();
-		edgeAppearanceCalculator.calculateEdgeAppearance(myEdgeApp, edge, network_view.getGraphPerspective());
-		myEdgeApp.applyAppearance(edgeView);
-	}
 }
Index: vizmap/src/main/java/org/cytoscape/vizmap/CalculatorIO.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/CalculatorIO.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/CalculatorIO.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -44,19 +44,6 @@
 
 
 //----------------------------------------------------------------------------
-import static org.cytoscape.vizmap.VisualPropertyType.EDGE_LINE_STYLE;
-import static org.cytoscape.vizmap.VisualPropertyType.EDGE_LINE_WIDTH;
-import static org.cytoscape.vizmap.VisualPropertyType.EDGE_SRCARROW_COLOR;
-import static org.cytoscape.vizmap.VisualPropertyType.EDGE_SRCARROW_SHAPE;
-import static org.cytoscape.vizmap.VisualPropertyType.EDGE_TGTARROW_COLOR;
-import static org.cytoscape.vizmap.VisualPropertyType.EDGE_TGTARROW_SHAPE;
-import static org.cytoscape.vizmap.VisualPropertyType.NODE_BORDER_COLOR;
-import static org.cytoscape.vizmap.VisualPropertyType.NODE_FILL_COLOR;
-import static org.cytoscape.vizmap.VisualPropertyType.NODE_HEIGHT;
-import static org.cytoscape.vizmap.VisualPropertyType.NODE_LINE_STYLE;
-import static org.cytoscape.vizmap.VisualPropertyType.NODE_LINE_WIDTH;
-import static org.cytoscape.vizmap.VisualPropertyType.NODE_SIZE;
-import static org.cytoscape.vizmap.VisualPropertyType.NODE_WIDTH;
 
 import java.io.BufferedReader;
 import java.io.Writer;
@@ -244,13 +231,14 @@
 			styleProps = new Properties();
 
 			try {
+				/*FIXME: do IO later
 				styleProps.putAll(vs.getNodeAppearanceCalculator()
 				                    .getProperties(nodeAppearanceBaseKey + "." + name));
 				styleProps.putAll(vs.getEdgeAppearanceCalculator()
 				                    .getProperties(edgeAppearanceBaseKey + "." + name));
 				styleProps.putAll(vs.getGlobalAppearanceCalculator()
 				                    .getProperties(globalAppearanceBaseKey + "." + name));
-
+				 */
 				// now that we've constructed all the properties for this visual
 				// style without Exceptions, store in the global properties
 				// object
@@ -321,180 +309,10 @@
 
 			// separate color into fill color and border color
 			if (key.startsWith(nodeColorBaseKey + ".")) {
-				key = updateLegacyKey(key, props, nodeColorBaseKey,
-				                      NODE_FILL_COLOR.getPropertyLabel(),
-				                      "cytoscape.visual.calculators.GenericNodeFillColorCalculator");
-				storeKey(key, props, calcNames);
 
-				key = updateLegacyKey(key, props, NODE_FILL_COLOR.getPropertyLabel(),
-				                      NODE_BORDER_COLOR.getPropertyLabel(),
-				                      "cytoscape.visual.calculators.GenericNodeBorderColorCalculator");
-				storeKey(key, props, calcNames);
-
 				// separate size into uniform, width, and height 
-			} else if (key.startsWith(nodeSizeBaseKey + ".")) {
-				key = updateLegacyKey(key, props, nodeSizeBaseKey, NODE_SIZE.getPropertyLabel(),
-				                      "cytoscape.visual.calculators.GenericNodeUniformSizeCalculator");
-				storeKey(key, props, calcNames);
+				// FIXME: here was the code that handled legacy visual styles -- will have to place that code back when working on IO
 
-				key = updateLegacyKey(key, props, NODE_SIZE.getPropertyLabel(),
-				                      NODE_WIDTH.getPropertyLabel(),
-				                      "cytoscape.visual.calculators.GenericNodeWidthCalculator");
-				storeKey(key, props, calcNames);
-
-				key = updateLegacyKey(key, props, NODE_WIDTH.getPropertyLabel(),
-				                      NODE_HEIGHT.getPropertyLabel(),
-				                      "cytoscape.visual.calculators.GenericNodeHeightCalculator");
-				storeKey(key, props, calcNames);
-
-				// separate arrow into source shape, source color, target shape, target color
-			} else if (key.startsWith(edgeArrowBaseKey + ".")) {
-				// the first two separations are to support the 
-				// deprecated EDGE_SRCARROW and EDGE_TGTARROW
-				key = updateLegacyKey(key, props, edgeArrowBaseKey,
-				                      edgeSrcArrowLabel,
-				                      "cytoscape.visual.calculators.GenericEdgeSourceArrowCalculator");
-				storeKey(key, props, calcNames);
-
-				key = updateLegacyKey(key, props, edgeSrcArrowLabel,
-				                      edgeTgtArrowLabel,
-				                      "cytoscape.visual.calculators.GenericEdgeTargetArrowCalculator");
-				storeKey(key, props, calcNames);
-
-				// eventually (4/2008), these should be the only separations
-				key = updateLegacyKey(key, props, edgeTgtArrowLabel,
-				                      EDGE_SRCARROW_COLOR.getPropertyLabel(),
-				                      "cytoscape.visual.calculators.GenericEdgeSourceArrowColorCalculator");
-				storeKey(key, props, calcNames);
-
-				key = updateLegacyKey(key, props, EDGE_SRCARROW_COLOR.getPropertyLabel(),
-				                      EDGE_SRCARROW_SHAPE.getPropertyLabel(),
-				                      "cytoscape.visual.calculators.GenericEdgeSourceArrowShapeCalculator");
-				storeKey(key, props, calcNames);
-
-				key = updateLegacyKey(key, props, EDGE_SRCARROW_SHAPE.getPropertyLabel(),
-				                      EDGE_TGTARROW_COLOR.getPropertyLabel(),
-				                      "cytoscape.visual.calculators.GenericEdgeTargetArrowColorCalculator");
-				storeKey(key, props, calcNames);
-
-				key = updateLegacyKey(key, props, EDGE_TGTARROW_COLOR.getPropertyLabel(),
-				                      EDGE_TGTARROW_SHAPE.getPropertyLabel(),
-				                      "cytoscape.visual.calculators.GenericEdgeTargetArrowShapeCalculator");
-				storeKey(key, props, calcNames);
-
-				// separated source arrow into source color and source shape
-			} else if (key.startsWith(edgeSrcArrowLabel + ".")) {
-				// this first store is to support deprecated EDGE_SRCARROW
-				//storeKey(key, props, calcNames);
-
-				// eventually, these should be the only separations
-				key = updateLegacyKey(key, props, edgeSrcArrowLabel,
-				                      EDGE_SRCARROW_COLOR.getPropertyLabel(),
-				                      "cytoscape.visual.calculators.GenericEdgeSourceArrowColorCalculator");
-				storeKey(key, props, calcNames);
-
-				key = updateLegacyKey(key, props, EDGE_SRCARROW_COLOR.getPropertyLabel(),
-				                      EDGE_SRCARROW_SHAPE.getPropertyLabel(),
-				                      "cytoscape.visual.calculators.GenericEdgeSourceArrowShapeCalculator");
-
-				storeKey(key, props, calcNames);
-
-				// separated target arrow into target color and target shape
-			} else if (key.startsWith(edgeTgtArrowLabel + ".")) {
-				// this first store is to support deprecated EDGE_TGTARROW
-				//storeKey(key, props, calcNames);
-
-				// eventually, these should be the only separations
-				key = updateLegacyKey(key, props, edgeTgtArrowLabel,
-				                      EDGE_TGTARROW_COLOR.getPropertyLabel(),
-				                      "cytoscape.visual.calculators.GenericEdgeTargetArrowColorCalculator");
-				storeKey(key, props, calcNames);
-
-				key = updateLegacyKey(key, props, EDGE_TGTARROW_COLOR.getPropertyLabel(),
-				                      EDGE_TGTARROW_SHAPE.getPropertyLabel(),
-				                      "cytoscape.visual.calculators.GenericEdgeTargetArrowShapeCalculator");
-
-				storeKey(key, props, calcNames);
-
-				// handle normal names
-				// This is how all "modern" properties files should work.
-			} else if (key.startsWith(edgeLineTypeLabel + ".")) {
-				// This first store is to support deprecated EDGE_LINETYPE.
-				// This should be replaced with line style and line width.
-				//storeKey(key, props, calcNames);
-
-				// eventually, these should be the only separations
-				key = updateLegacyKey(key, props, edgeLineTypeLabel,
-				                      EDGE_LINE_STYLE.getPropertyLabel(),
-				                      "cytoscape.visual.calculators.GenericEdgeLineStyleCalculator");
-				storeKey(key, props, calcNames);
-
-				key = updateLegacyKey(key, props, EDGE_LINE_STYLE.getPropertyLabel(),
-				                      EDGE_LINE_WIDTH.getPropertyLabel(),
-				                      "cytoscape.visual.calculators.GenericEdgeLineWidthCalculator");
-				storeKey(key, props, calcNames);
-			} else if (key.startsWith(nodeLineTypeLabel + ".")) {
-				// This first store is to support deprecated EDGE_LINETYPE.
-				// This should be replaced with line style and line width.
-				//storeKey(key, props, calcNames);
-
-				// eventually, these should be the only separations
-				key = updateLegacyKey(key, props, nodeLineTypeLabel,
-				                      NODE_LINE_STYLE.getPropertyLabel(),
-				                      "cytoscape.visual.calculators.GenericNodeLineStyleCalculator");
-				storeKey(key, props, calcNames);
-
-				key = updateLegacyKey(key, props, NODE_LINE_STYLE.getPropertyLabel(),
-				                      NODE_LINE_WIDTH.getPropertyLabel(),
-				                      "cytoscape.visual.calculators.GenericNodeLineWidthCalculator");
-				storeKey(key, props, calcNames);
-
-			// These change the visual styles (rather than calculators) so that the
-			// visual style, instead of mapping a TGTARROW, now maps a TGTARROW_SHAPE.
-			} else if (key.endsWith(edgeTgtArrowLabel)) {
-				key = updateLegacyKey(key, props, edgeTgtArrowLabel,
-				                      EDGE_TGTARROW_SHAPE.getPropertyLabel(),
-				                      "cytoscape.visual.calculators.GenericEdgeTargetArrowShapeCalculator");
-				storeKey(key, props, calcNames);
-			} else if (key.endsWith(edgeSrcArrowLabel)) {
-				key = updateLegacyKey(key, props, edgeSrcArrowLabel,
-				                      EDGE_SRCARROW_SHAPE.getPropertyLabel(),
-				                      "cytoscape.visual.calculators.GenericEdgeSourceArrowShapeCalculator");
-				storeKey(key, props, calcNames);
-			} else if (key.endsWith(edgeLineTypeLabel)) {
-				key = updateLegacyKey(key, props, edgeLineTypeLabel,
-				                      EDGE_LINE_STYLE.getPropertyLabel(),
-				                      "cytoscape.visual.calculators.GenericEdgeLineStyleCalculator");
-				storeKey(key, props, calcNames);
-			} else if (key.endsWith(nodeLineTypeLabel)) {
-				key = updateLegacyKey(key, props, nodeLineTypeLabel,
-				                      NODE_LINE_STYLE.getPropertyLabel(),
-				                      "cytoscape.visual.calculators.GenericNodeLineStyleCalculator");
-				storeKey(key, props, calcNames);
-
-			// Likewise, these change the default values of visual styles to so that
-			// the default LINETYPE gets turned into the default LINE_STYLE.
-			} else if (key.endsWith(nodeLineTypeDefaultLabel)) {
-				key = updateLegacyKey(key, props, nodeLineTypeDefaultLabel,
-				                      NODE_LINE_STYLE.getDefaultPropertyLabel(),
-				                      "cytoscape.visual.calculators.GenericNodeLineStyleCalculator");
-				storeKey(key, props, calcNames);
-			} else if (key.endsWith(edgeLineTypeDefaultLabel)) {
-				key = updateLegacyKey(key, props, edgeLineTypeDefaultLabel,
-				                      EDGE_LINE_STYLE.getDefaultPropertyLabel(),
-				                      "cytoscape.visual.calculators.GenericEdgeLineStyleCalculator");
-				storeKey(key, props, calcNames);
-			} else if (key.endsWith(edgeTgtArrowDefaultLabel)) {
-				key = updateLegacyKey(key, props, edgeTgtArrowDefaultLabel,
-				                      EDGE_TGTARROW_SHAPE.getDefaultPropertyLabel(),
-				                      "cytoscape.visual.calculators.GenericEdgeTargetArrowShapeCalculator");
-				storeKey(key, props, calcNames);
-			} else if (key.endsWith(edgeSrcArrowDefaultLabel)) {
-				key = updateLegacyKey(key, props, edgeSrcArrowDefaultLabel,
-				                      EDGE_SRCARROW_SHAPE.getDefaultPropertyLabel(),
-				                      "cytoscape.visual.calculators.GenericEdgeSourceArrowShapeCalculator");
-				storeKey(key, props, calcNames);
-
 			// Store the key as is.
 			} else
 				storeKey(key, props, calcNames);
@@ -527,9 +345,11 @@
 				visualStyles.put(name, vs);
 			}
 
+			/* FIXME: do IO later
 			vs.setNodeAppearanceCalculator(new NodeAppearanceCalculator(name, nacNames.get(name),
 			                                                            nodeAppearanceBaseKey + "."
 			                                                            + name, catalog));
+			                                                            */
 		}
 
 		Map<String, Properties> eacNames = calcNames.get(edgeAppearanceBaseKey);
@@ -543,9 +363,11 @@
 				visualStyles.put(name, vs);
 			}
 
+			/* FIXME: do IO later
 			vs.setEdgeAppearanceCalculator(new EdgeAppearanceCalculator(name, eacNames.get(name),
 			                                                            edgeAppearanceBaseKey + "."
 			                                                            + name, catalog));
+			                                                            */
 		}
 
 		Map<String, Properties> gacNames = calcNames.get(globalAppearanceBaseKey);
@@ -558,11 +380,12 @@
 				vs = new VisualStyle(name);
 				visualStyles.put(name, vs);
 			}
-
+			/* FIXME: do IO later
 			vs.setGlobalAppearanceCalculator(new GlobalAppearanceCalculator(name,
 			                                                                gacNames.get(name),
 			                                                                globalAppearanceBaseKey
 			                                                                + "." + name, catalog));
+			                                                                */
 		}
 
 		// now store the visual styles in the catalog
@@ -704,7 +527,7 @@
 	 */
 	public static void renameAsNeeded(Calculator c, CalculatorCatalog catalog) {
 		final String name = c.toString();
-		final String newName = catalog.checkCalculatorName(c.getVisualPropertyType(), name);
+		final String newName = catalog.checkCalculatorName(c.getVisualProperty(), name);
 
 		if (!newName.equals(name))
 			c.setName(newName);
Index: vizmap/src/main/java/org/cytoscape/vizmap/VisualStyle.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/VisualStyle.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/VisualStyle.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -42,8 +42,23 @@
 //----------------------------------------------------------------------------
 package org.cytoscape.vizmap;
 
+import java.awt.Color;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
 import java.util.Vector;
 
+import org.cytoscape.GraphPerspective;
+import org.cytoscape.Node;
+import org.cytoscape.attributes.CyAttributes;
+import org.cytoscape.attributes.CyAttributesFactory;
+import org.cytoscape.view.EdgeView;
+import org.cytoscape.view.GraphView;
+import org.cytoscape.view.NodeView;
+import org.cytoscape.view.VisualProperty;
+import org.cytoscape.view.VisualPropertyCatalog;
 import org.cytoscape.vizmap.calculators.Calculator;
 
 
@@ -60,10 +75,10 @@
 	private String name = "default";
 	
 	// Calculators associated with this VS.
-	private NodeAppearanceCalculator nodeAC;
-	private EdgeAppearanceCalculator edgeAC;
-	private GlobalAppearanceCalculator globalAC;
-
+	private HashMap<VisualProperty, Calculator> calculators;
+	private HashMap<VisualProperty, Object> defaultValues;
+	private HashMap<String, Object> globalVisualProperties;
+	
 	/**
 	 * Keep track of number of times this style has been cloned.
 	 */
@@ -83,20 +98,15 @@
 	 * @return    vector with: name of conflicting visual style (index 0),
 	 *        name of conflicting attributes. If size == 1, then no conflicts
 	 */
-	public Vector checkConflictingCalculator(Calculator c) {
+	public Vector checkConflictingCalculator(Calculator calc) {
 		Vector<String> conflicts = new Vector<String>();
 		conflicts.add(name);
 
-		for (Calculator nodeCalcs : nodeAC.getCalculators()) {
-			if (nodeCalcs == c)
-				conflicts.add(nodeCalcs.getVisualPropertyType().getPropertyLabel());
+		for (Calculator c : calculators.values()) {
+			if (calc == c)
+				conflicts.add(c.getVisualProperty().getName());
 		}
 
-		for (Calculator edgeCalcs : edgeAC.getCalculators()) {
-			if (edgeCalcs == c)
-				conflicts.add(edgeCalcs.getVisualPropertyType().getPropertyLabel());
-		}
-
 		return conflicts;
 	}
 
@@ -119,9 +129,10 @@
 
 		copy.name = dupeFreeName;
 		copy.dupeCount++;
-		copy.nodeAC = (NodeAppearanceCalculator) this.nodeAC.clone();
-		copy.edgeAC = (EdgeAppearanceCalculator) this.edgeAC.clone();
-		copy.globalAC = (GlobalAppearanceCalculator) this.globalAC.clone();
+		copy.calculators = (HashMap <VisualProperty, Calculator>) this.calculators.clone();
+		copy.defaultValues= (HashMap <VisualProperty, Object>) this.defaultValues.clone();
+		copy.globalVisualProperties = (HashMap<String, Object>) this.globalVisualProperties.clone();  
+		
 
 		return copy;
 	}
@@ -131,20 +142,19 @@
 	 */
 	public VisualStyle(String name) {
 		setName(name);
-		setNodeAppearanceCalculator(new NodeAppearanceCalculator());
-		setEdgeAppearanceCalculator(new EdgeAppearanceCalculator());
-		setGlobalAppearanceCalculator(new GlobalAppearanceCalculator());
+		calculators = new HashMap<VisualProperty, Calculator>();
+		defaultValues = new HashMap <VisualProperty, Object>();
+		globalVisualProperties = new HashMap<String, Object>();
 	}
 
 	/**
 	 * Full constructor.
 	 */
-	public VisualStyle(String name, NodeAppearanceCalculator nac, EdgeAppearanceCalculator eac,
-	                   GlobalAppearanceCalculator gac) {
+	public VisualStyle(String name, HashMap<VisualProperty, Calculator> calculators, HashMap<String, Object> globalVisualProperties) {
 		setName(name);
-		setNodeAppearanceCalculator(nac);
-		setEdgeAppearanceCalculator(eac);
-		setGlobalAppearanceCalculator(gac);
+		this.calculators = calculators;
+		this.defaultValues = new HashMap <VisualProperty, Object>();
+		this.globalVisualProperties = globalVisualProperties;
 	}
 
 	/**
@@ -172,14 +182,9 @@
             throw new NullPointerException("Unexpected null name in VisualStyle constructor");
 
         setName(newName);
-        setNodeAppearanceCalculator((NodeAppearanceCalculator)toCopy.getNodeAppearanceCalculator().clone());
-        setEdgeAppearanceCalculator((EdgeAppearanceCalculator)toCopy.getEdgeAppearanceCalculator().clone());
-
-        try {
-            setGlobalAppearanceCalculator((GlobalAppearanceCalculator)toCopy.getGlobalAppearanceCalculator().clone());
-        } catch (CloneNotSupportedException e) {
-            e.printStackTrace();
-        }
+        this.calculators = (HashMap<VisualProperty, Calculator>) toCopy.calculators.clone();
+        this.defaultValues = (HashMap <VisualProperty, Object>) toCopy.defaultValues.clone();
+        this.globalVisualProperties = (HashMap<String, Object>) toCopy.globalVisualProperties.clone();
     }
 
 	/**
@@ -210,68 +215,156 @@
 		return tmp;
 	}
 
-	/**
-	 * Get the NodeAppearanceCalculator for this visual style.
-	 */
-	public NodeAppearanceCalculator getNodeAppearanceCalculator() {
-		return nodeAC;
+	private Object getByPass(VisualProperty vp, String graphObjectIdentifier, CyAttributes attr){
+		String value = attr.getStringAttribute(graphObjectIdentifier, vp.getName());
+		if (value == null){
+			return null;
+		} else {
+			return vp.parseStringValue(value);
+		}
 	}
 
-	/**
-	 * Set the NodeAppearanceCalculator for this visual style. A default
-	 * NodeAppearanceCalculator will be created and used if the argument
-	 * is null.
-	 *
-	 * @param nac  the new NodeAppearanceCalculator
-	 * @return  the old NodeAppearanceCalculator
-	 */
-	public NodeAppearanceCalculator setNodeAppearanceCalculator(NodeAppearanceCalculator nac) {
-		NodeAppearanceCalculator tmp = nodeAC;
-		nodeAC = (nac == null) ? new NodeAppearanceCalculator() : nac;
-		return tmp;
-	}
+	/** Apply this VisualStyle to the view */
+	public void apply(GraphView network_view){
+		System.out.println("APPLYING VISUAL STYLE");
+		
+		// FIXME: rethink this:
+		// setup proper background colors
+		Color backgroundColor = (Color) globalVisualProperties.get("backgroundColor");
+		if (backgroundColor== null){ // FIXME FIXME: temporary hack, shouldn't be needed!!
+			System.out.println("error: having to force default backgroundColor");
+			backgroundColor= Color.lightGray;
+		}
+		network_view.setBackgroundPaint(backgroundColor);
 
-	/**
-	 * Get the EdgeAppearanceCalculator for this visual style.
-	 */
-	public EdgeAppearanceCalculator getEdgeAppearanceCalculator() {
-		return edgeAC;
-	}
+		// will ignore sloppy & reverse selection color for now // FIXME
+		GraphPerspective network = network_view.getNetwork();
+		
+		// apply visual style to Nodes:
+    	NodeView nodeView;
 
-	/**
-	 * Set the EdgeAppearanceCalculator for this visual style. A default
-	 * EdgeAppearanceCalculator will be created and used if the argument
-	 * is null.
-	 *
-	 * @param nac  the new EdgeAppearanceCalculator
-	 * @return  the old EdgeAppearanceCalculator
-	 */
-	public EdgeAppearanceCalculator setEdgeAppearanceCalculator(EdgeAppearanceCalculator eac) {
-		EdgeAppearanceCalculator tmp = edgeAC;
-		edgeAC = (eac == null) ? new EdgeAppearanceCalculator() : eac;
+    	CyAttributes attrs = CyAttributesFactory.getCyAttributes("node");
+		for (Iterator i = network_view.getNodeViewsIterator(); i.hasNext();) {
+			nodeView = (NodeView) i.next();
 
-		return tmp;
+			if (nodeView == null) // FIXME:
+				// WARNING: This is a hack, nodeView should not be null, but
+				// for now do this! (iliana)
+				continue;
+
+			for (VisualProperty vp:VisualPropertyCatalog.getNodeVisualPropertyList()){
+				Object o = getByPass(vp, nodeView.getNode().getIdentifier(), attrs);
+				if (o == null) {
+					Calculator c = calculators.get(vp);
+					if (c!= null){
+						o = c.getRangeValue(nodeView.getNode(), attrs);
+					}
+				}
+				if (o == null) { o = defaultValues.get(vp); }
+				if (o == null) { o = vp.getDefaultAppearanceObject(); }
+				vp.applyToNodeView(nodeView, o);
+			}
+		}
+
+    	EdgeView edgeView;
+
+    	attrs = CyAttributesFactory.getCyAttributes("edge");
+    	
+		for (Iterator i = network_view.getEdgeViewsIterator(); i.hasNext();) {
+			edgeView = (EdgeView) i.next();
+
+			if (edgeView == null)
+				// WARNING: This is a hack, edgeView should not be null, but
+				// for now do this! (iliana)
+				continue;
+
+			for (VisualProperty vp:VisualPropertyCatalog.getEdgeVisualPropertyList()){
+				Object o = getByPass(vp, edgeView.getEdge().getIdentifier(), attrs);
+				if (o == null) {
+					Calculator c = calculators.get(vp);
+					if (c!= null){
+						o = c.getRangeValue(edgeView.getEdge(), attrs);
+					}
+				}
+				if (o == null) { o = defaultValues.get(vp); }
+				if (o == null) { o = vp.getDefaultAppearanceObject(); }
+				vp.applyToEdgeView(edgeView, o);
+			}
+		}
+		
+		// Set selection colors
+		Color nodeSelectionColor = (Color) globalVisualProperties.get("nodeSelectionColor");
+		for (Node n: network.nodesList()){ // FIXME: GraphView should have an .nodeViewsList() method but apparently doesn't have one now.
+			network_view.getNodeView(n).setSelectedPaint(nodeSelectionColor );
+		}
+		
+		Color edgeSelectionColor = (Color) globalVisualProperties.get("edgeSelectionColor");
+		if (edgeSelectionColor == null){ // FIXME FIXME: temporary hack, shouldn't be needed!!
+			System.out.println("error: having to force default edgeSelectionColor");
+			edgeSelectionColor = Color.black;
+		}
+		for (EdgeView ev: network_view.getEdgeViewsList()){
+			ev.setSelectedPaint(edgeSelectionColor );
+		}
 	}
+	
+	/** Adds given Calculator*/
+	public void setCalculator(Calculator c){
+		calculators.put(c.getVisualProperty(), c);
+	
+	}
+	public Calculator getCalculator(VisualProperty vp){
+		return calculators.get(vp);
+	}
+	public void removeCalculator(VisualProperty vp){
+		calculators.remove(vp);
+	}
+	/** need a way to iterate over the calculators */
+	public HashMap<VisualProperty, Calculator> getCalculators(){
+		return calculators;
+	}
 
-	/**
-	 * Get the GlobalAppearanceCalculator for this visual style.
-	 */
-	public GlobalAppearanceCalculator getGlobalAppearanceCalculator() {
-		return globalAC;
+	/** need a way to iterate over the calculators */
+	public List<Calculator> getNodeCalculators(){
+		List<Calculator> result = new ArrayList<Calculator>();
+		for (Calculator calc: calculators.values()){
+			if (calc.getVisualProperty().isNodeProp()){
+				result.add(calc);
+			}
+		}
+		return result;
 	}
 
-	/**
-	 * Set the GlobalAppearanceCalculator for this visual style. A default
-	 * GlobalAppearanceCalculator will be created and used if the argument
-	 * is null.
-	 *
-	 * @param nac  the new GlobalAppearanceCalculator
-	 * @return  the old GlobalAppearanceCalculator
-	 */
-	public GlobalAppearanceCalculator setGlobalAppearanceCalculator(GlobalAppearanceCalculator gac) {
-		GlobalAppearanceCalculator tmp = globalAC;
-		globalAC = (gac == null) ? new GlobalAppearanceCalculator() : gac;
+	public List<Calculator> getEdgeCalculators(){
+		List<Calculator> result = new ArrayList<Calculator>();
+		for (Calculator calc: calculators.values()){
+			if (!calc.getVisualProperty().isNodeProp()){
+				result.add(calc);
+			}
+		}
+		return result;
+	}
 
-		return tmp;
+	/** Sets the default value for a given VisualProperty */
+	public void setGlobalProperty(String key, Object value){
+		globalVisualProperties.put(key, value);
 	}
+	public Object getGlobalProperty(String key){
+		return globalVisualProperties.get(key);
+	}
+	public HashMap<String, Object> copyGlobalVisualProperties(){
+		return (HashMap<String, Object>) globalVisualProperties.clone();
+	}
+
+	/** Sets the default value for a given VisualProperty */
+	public void setDefaultValue(VisualProperty vp, Object value){
+		defaultValues.put(vp, value);
+	}
+	public Object getDefaultValue(VisualProperty vp){
+		Object o = defaultValues.get(vp);
+		if (o == null){
+			o = vp.getDefaultAppearanceObject();
+		}
+		return o;
+	}
 }
Index: vizmap/src/main/java/org/cytoscape/vizmap/ValueParserCatalog.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/ValueParserCatalog.java	(.../trunk)	(revision 0)
+++ vizmap/src/main/java/org/cytoscape/vizmap/ValueParserCatalog.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -0,0 +1,32 @@
+package org.cytoscape.vizmap;
+
+import java.awt.Color;
+import java.awt.Font;
+
+import org.cytoscape.view.VisualProperty;
+import org.cytoscape.view.renderers.NodeRenderer;
+import org.cytoscape.vizmap.parsers.ColorParser;
+import org.cytoscape.vizmap.parsers.DoubleParser;
+import org.cytoscape.vizmap.parsers.FontParser;
+import org.cytoscape.vizmap.parsers.LabelPositionParser;
+import org.cytoscape.vizmap.parsers.StringParser;
+
+public abstract class ValueParserCatalog {
+	public static ValueParser getValueParser(VisualProperty vp){
+		Class c = vp.getDataType();
+		if (c.isAssignableFrom(Color.class)){
+			return new ColorParser();
+		} else if (c.isAssignableFrom(Number.class)){
+			return new DoubleParser(); // FIXME: or FloatParser? (which to use and when?)
+		} else if (c.isAssignableFrom(Font.class)){
+			return new FontParser();
+		} else if (c.isAssignableFrom(LabelPosition.class)){
+			return new LabelPositionParser();
+		} else if (c.isAssignableFrom(String.class)){
+			return new StringParser();
+		} else {
+			System.out.println("unknown DataType!");
+			return null;
+		}
+	}
+}
Index: vizmap/src/main/java/org/cytoscape/vizmap/CalculatorCatalog.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/CalculatorCatalog.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/CalculatorCatalog.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -44,8 +44,6 @@
 
 
 //----------------------------------------------------------------------------
-import static org.cytoscape.vizmap.VisualPropertyType.NODE_LABEL;
-
 import org.cytoscape.vizmap.calculators.*;
 
 import org.cytoscape.vizmap.mappings.ObjectMapping;
@@ -53,9 +51,12 @@
 import org.cytoscape.vizmap.mappings.DiscreteMapping;
 import org.cytoscape.vizmap.mappings.ContinuousMapping;
 
+import org.cytoscape.view.renderers.NodeRenderer;
+import org.cytoscape.view.VisualProperty;
+import org.cytoscape.view.VisualPropertyCatalog;
+
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.EnumMap;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -74,8 +75,8 @@
  */
 public class CalculatorCatalog {
 	private static final String label = "label";
-	private Map<VisualPropertyType, Map<String, Calculator>> calculators;
-	private Map<VisualPropertyType, List<ChangeListener>> listeners;
+	private Map<VisualProperty, Map<String, Calculator>> calculators;
+	private Map<VisualProperty, List<ChangeListener>> listeners;
 	private Map<String, VisualStyle> visualStyles;
 	private Map<String, Class> mappers;
 
@@ -100,8 +101,8 @@
 	 * DOCUMENT ME!
 	 */
 	private void clear() {
-		calculators = new EnumMap<VisualPropertyType, Map<String, Calculator>>(VisualPropertyType.class);
-		listeners = new EnumMap<VisualPropertyType, List<ChangeListener>>(VisualPropertyType.class);
+		calculators = new HashMap<VisualProperty, Map<String, Calculator>>();
+		listeners = new HashMap<VisualProperty, List<ChangeListener>>();
 
 		visualStyles = new HashMap<String, VisualStyle>();
 
@@ -133,7 +134,7 @@
 	 * @throws IllegalArgumentException
 	 *             if unknown type passed in
 	 */
-	protected List<ChangeListener> getListenerList(final VisualPropertyType type) throws IllegalArgumentException {
+	protected List<ChangeListener> getListenerList(final VisualProperty type) throws IllegalArgumentException {
 		List<ChangeListener> l = listeners.get(type);
 
 		if (l == null) {
@@ -161,7 +162,7 @@
 	 * @throws IllegalArgumentException
 	 *             if unknown type passed in
 	 */
-	public void addChangeListener(ChangeListener l, VisualPropertyType type)
+	public void addChangeListener(ChangeListener l, VisualProperty type)
 	    throws IllegalArgumentException {
 		List<ChangeListener> theListeners = getListenerList(type);
 		theListeners.add(l);
@@ -185,7 +186,7 @@
 	 * @throws IllegalArgumentException
 	 *             if type is unknown
 	 */
-	protected void fireStateChanged(final VisualPropertyType type) throws IllegalArgumentException {
+	protected void fireStateChanged(final VisualProperty type) throws IllegalArgumentException {
 		List<ChangeListener> notifyEvents = getListenerList(type);
 
 		ChangeListener listener;
@@ -210,7 +211,7 @@
 	 *            a known type identifier
 	 * @return Map the matching Map structure
 	 */
-	protected Map<String, Calculator> getCalculatorMap(final VisualPropertyType type) {
+	protected Map<String, Calculator> getCalculatorMap(final VisualProperty type) {
 		Map<String, Calculator> m = calculators.get(type);
 
 		if (m == null) {
@@ -240,7 +241,7 @@
 	public void addCalculator(Calculator dupe)
 	    throws DuplicateCalculatorNameException, IllegalArgumentException {
 		//System.out.println("adding calculator: " + dupe.getVisualPropertyType());
-		final VisualPropertyType calcType = dupe.getVisualPropertyType();
+		final VisualProperty calcType = dupe.getVisualProperty();
 		Map<String, Calculator> theMap = getCalculatorMap(calcType);
 		addCalculator(dupe, theMap);
 
@@ -260,7 +261,7 @@
 	 *         numbers are appended until a valid name is found; this valid name
 	 *         is returned to the caller.
 	 */
-	public String checkCalculatorName(String calcName, VisualPropertyType calcType) {
+	public String checkCalculatorName(String calcName, VisualProperty calcType) {
 		Map<String, Calculator> theMap = getCalculatorMap(calcType);
 
 		return checkName(calcName, theMap);
@@ -280,7 +281,7 @@
 	 */
 	public void renameCalculator(Calculator c, String name)
 	    throws DuplicateCalculatorNameException, IllegalArgumentException {
-		final VisualPropertyType calcType = c.getVisualPropertyType();
+		final VisualProperty calcType = c.getVisualProperty();
 		final Map<String, Calculator> theMap = getCalculatorMap(calcType);
 		final String newName = checkName(name, theMap);
 
@@ -302,7 +303,7 @@
 	 *             if c is of an unknown calculator type
 	 */
 	public void removeCalculator(Calculator c) throws IllegalArgumentException {
-		final VisualPropertyType calcType = c.getVisualPropertyType();
+		final VisualProperty calcType = c.getVisualProperty();
 		final Map<String, Calculator> theMap = getCalculatorMap(calcType);
 
 		theMap.remove(c.toString());
@@ -421,10 +422,6 @@
 		}
 
 		visualStyles.put(name, vs);
-
-		// store the individual attribute calculators via helper methods
-		addNodeAppearanceCalculator(vs.getNodeAppearanceCalculator());
-		addEdgeAppearanceCalculator(vs.getEdgeAppearanceCalculator());
 	}
 
 	/**
@@ -463,24 +460,6 @@
 		return checkName(name, visualStyles);
 	}
 
-	private void addNodeAppearanceCalculator(NodeAppearanceCalculator c) {
-		for (Calculator cc : c.getCalculators()) {
-			Map<String, Calculator> m = getCalculatorMap(cc.getVisualPropertyType());
-
-			if (!m.values().contains(cc))
-				m.put(cc.toString(), cc);
-		}
-	}
-
-	private void addEdgeAppearanceCalculator(EdgeAppearanceCalculator c) {
-		for (Calculator cc : c.getCalculators()) {
-			Map<String, Calculator> m = getCalculatorMap(cc.getVisualPropertyType());
-
-			if (!m.values().contains(cc))
-				m.put(cc.toString(), cc);
-		}
-	}
-
 	protected void addCalculator(Calculator c, Map<String, Calculator> m) throws DuplicateCalculatorNameException {
 		if (c == null)
 			return;
@@ -519,7 +498,7 @@
 	public Collection<Calculator> getCalculators() {
 		final List<Calculator> calcList = new ArrayList<Calculator>();
 
-		for (VisualPropertyType type : calculators.keySet()) {
+		for (VisualProperty type : calculators.keySet()) {
 			for (String s : calculators.get(type).keySet())
 				calcList.add(calculators.get(type).get(s));
 		}
@@ -533,7 +512,7 @@
 	 * @param type
 	 * @return
 	 */
-	public Collection<Calculator> getCalculators(VisualPropertyType type) {
+	public Collection<Calculator> getCalculators(VisualProperty type) {
 		Map<String, Calculator> m = getCalculatorMap(type);
 
 		return m.values();
@@ -546,7 +525,7 @@
 	 * @param name
 	 * @return
 	 */
-	public Calculator getCalculator(VisualPropertyType type, String name) {
+	public Calculator getCalculator(VisualProperty type, String name) {
 		Map<String, Calculator> m = getCalculatorMap(type);
 
 		return m.get(name);
@@ -559,7 +538,7 @@
 	 * @param name
 	 * @return
 	 */
-	public String checkCalculatorName(VisualPropertyType type, String name) {
+	public String checkCalculatorName(VisualProperty type, String name) {
 		return checkName(name, getCalculatorMap(type));
 	}
 
@@ -570,7 +549,7 @@
 	 * @param name
 	 * @return
 	 */
-	public Calculator removeCalculator(VisualPropertyType type, String name) {
+	public Calculator removeCalculator(VisualProperty type, String name) {
 		Map<String, Calculator> m = getCalculatorMap(type);
 
 		return m.remove(name);
@@ -581,7 +560,7 @@
 	 *
 	 * @return DOCUMENT ME!
 	 */
-	public Collection<VisualPropertyType> getCalculatorTypes() {
+	public Collection<VisualProperty> getCalculatorTypes() {
 		return calculators.keySet();
 	}
 
@@ -591,14 +570,6 @@
 	public void createDefaultVisualStyle() {
 		final VisualStyle defaultVS = new VisualStyle("default");
 
-		Calculator nlc = getCalculator(NODE_LABEL, label);
-
-		if (nlc == null) {
-			PassThroughMapping m = new PassThroughMapping("", AbstractCalculator.ID);
-			nlc = new BasicCalculator(label, m, NODE_LABEL);
-		}
-
-		defaultVS.getNodeAppearanceCalculator().setCalculator(nlc);
 		addVisualStyle(defaultVS);
 	}
 /*
@@ -614,4 +585,7 @@
 	}
 	*/
 
+	public void addNodeRenderer(NodeRenderer nodeRenderer){
+		// get supported visualAttributes, add them somewhere.. (?)
+	}
 }
Index: vizmap/src/main/java/org/cytoscape/vizmap/calculators/CalculatorFactory.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/calculators/CalculatorFactory.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/calculators/CalculatorFactory.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -36,7 +36,8 @@
  */
 package org.cytoscape.vizmap.calculators;
 
-import org.cytoscape.vizmap.VisualPropertyType;
+import org.cytoscape.view.VisualProperty;
+import org.cytoscape.view.VisualPropertyCatalog;
 
 import org.cytoscape.vizmap.mappings.ObjectMapping;
 
@@ -59,14 +60,14 @@
 	 */
     public static Calculator newCalculator(String name, Properties calcProps, String baseKey) {
         final String typeName = calcProps.getProperty(baseKey + ".visualPropertyType");
-		VisualPropertyType t = null; 
+		VisualProperty t = null; 
 
 		try { 
 
 			if ( typeName == null ) 
 				t = guessType( baseKey );
 			else 
-				t = VisualPropertyType.valueOf(typeName);
+				t = VisualPropertyCatalog.getVisualProperty(typeName);
 
 			if ( t == null ) {
 				//System.out.println("Couldn't parse baseKey: " + baseKey);
@@ -81,10 +82,10 @@
 	}
 
 
-	private static VisualPropertyType guessType(String key) {
+	private static VisualProperty guessType(String key) {
 		String lckey = key.toLowerCase();
-		for ( VisualPropertyType vpt : VisualPropertyType.values() )
-			if ( lckey.startsWith(vpt.getPropertyLabel().toLowerCase()) )
+		for ( VisualProperty vpt : VisualPropertyCatalog.collectionOfVisualProperties() )
+			if ( lckey.startsWith(vpt.getName().toLowerCase()) )
 				return vpt;
 		return null;
 	}
Index: vizmap/src/main/java/org/cytoscape/vizmap/calculators/Calculator.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/calculators/Calculator.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/calculators/Calculator.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -43,8 +43,9 @@
 package org.cytoscape.vizmap.calculators;
 
 
-import org.cytoscape.vizmap.Appearance;
-import org.cytoscape.vizmap.VisualPropertyType;
+import org.cytoscape.attributes.CyAttributes;
+import org.cytoscape.view.GraphView;
+import org.cytoscape.view.VisualProperty;
 
 import org.cytoscape.vizmap.mappings.ObjectMapping;
 
@@ -56,6 +57,7 @@
 import javax.swing.event.ChangeListener;
 
 import org.cytoscape.Edge;
+import org.cytoscape.GraphObject;
 import org.cytoscape.GraphPerspective;
 import org.cytoscape.Node;
 
@@ -130,29 +132,15 @@
      *
      * @return
      */
-    public VisualPropertyType getVisualPropertyType();
+    public VisualProperty getVisualProperty();
 
-    /**
-     * DOCUMENT ME!
-     *
-     * @param appr DOCUMENT ME!
-     * @param e DOCUMENT ME!
-     * @param net DOCUMENT ME!
-     */
-    public void apply(Appearance appr, Edge e, GraphPerspective net);
+	@SuppressWarnings("unchecked") 	// TODO again, this should be fixed as part of CyAttributes
+									// this one is also related to bug 247!!!
+	public Object getRangeValue(GraphObject obj,CyAttributes attrs);
 
     /**
      * DOCUMENT ME!
      *
-     * @param appr DOCUMENT ME!
-     * @param n DOCUMENT ME!
-     * @param net DOCUMENT ME!
-     */
-    public void apply(Appearance appr, Node n, GraphPerspective net);
-
-    /**
-     * DOCUMENT ME!
-     *
      * @return DOCUMENT ME!
      */
     public Vector<ObjectMapping> getMappings();
Index: vizmap/src/main/java/org/cytoscape/vizmap/calculators/BasicCalculator.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/calculators/BasicCalculator.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/calculators/BasicCalculator.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -42,20 +42,17 @@
 //------------------------------------------------------------------------------
 package org.cytoscape.vizmap.calculators;
 
-import org.cytoscape.vizmap.VisualPropertyType;
+import org.cytoscape.view.VisualProperty;
 
 import org.cytoscape.vizmap.mappings.MappingFactory;
 import org.cytoscape.vizmap.mappings.ObjectMapping;
 
-import org.cytoscape.vizmap.ValueParser;
+import org.cytoscape.vizmap.ValueParserCatalog;
 
-import java.util.Map;
 import java.util.Properties;
 
-import org.cytoscape.GraphPerspective;
 
 
-
 /**
  * BasicCalculator implements some UI features for calculators lower in the
  * object tree.
@@ -69,7 +66,7 @@
      * @param m DOCUMENT ME!
      * @param type DOCUMENT ME!
      */
-    public BasicCalculator(String name, ObjectMapping m, VisualPropertyType type) {
+    public BasicCalculator(String name, ObjectMapping m, VisualProperty type) {
         super(name, m, type);
     }
 
@@ -82,10 +79,10 @@
      * @param parser DOCUMENT ME!
      * @param type DOCUMENT ME!
      */
-    public BasicCalculator(String name, Properties props, String baseKey, VisualPropertyType type) {
+    public BasicCalculator(String name, Properties props, String baseKey, VisualProperty type) {
         super(name,
-              MappingFactory.newMapping(props, baseKey + ".mapping", type.getValueParser(),
-                                        type.getVisualProperty().getDefaultAppearanceObject(), 
+              MappingFactory.newMapping(props, baseKey + ".mapping", ValueParserCatalog.getValueParser(type),
+                                        type.getDefaultAppearanceObject(), 
 				                        type.isNodeProp()?
 										    ObjectMapping.NODE_MAPPING:
 											ObjectMapping.EDGE_MAPPING),
Index: vizmap/src/main/java/org/cytoscape/vizmap/calculators/AbstractCalculator.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/calculators/AbstractCalculator.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/calculators/AbstractCalculator.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -45,19 +45,13 @@
 import org.cytoscape.attributes.CyAttributes;
 import org.cytoscape.attributes.CyAttributesUtils;
 
-import org.cytoscape.vizmap.Appearance;
-import org.cytoscape.vizmap.VisualPropertyType;
+import org.cytoscape.view.VisualProperty;
 
 import org.cytoscape.vizmap.mappings.MappingFactory;
 import org.cytoscape.vizmap.mappings.ObjectMapping;
 
 //------------------------------------------------------------------------------
 
-import java.awt.GridBagConstraints;
-import java.awt.event.ItemEvent;
-import java.awt.event.ItemListener;
-
-import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
@@ -66,7 +60,6 @@
 import javax.swing.event.ChangeEvent;
 import javax.swing.event.ChangeListener;
 
-import org.cytoscape.Edge;
 import org.cytoscape.GraphObject;
 import org.cytoscape.GraphPerspective;
 import org.cytoscape.Node;
@@ -99,7 +92,7 @@
 	 * Type of this visual property.
 	 * (New in version 2.5)
 	 */
-	protected VisualPropertyType type;
+	protected VisualProperty type;
 
 	/** keep track of how many times I've been duplicated */
 	private int dupeCount = 0;
@@ -122,7 +115,7 @@
 	 * @param type DOCUMENT ME!
 	 */
 	 @SuppressWarnings("unchecked") // TODO figure this one out
-	public AbstractCalculator(String name, ObjectMapping m, VisualPropertyType type) {
+	public AbstractCalculator(String name, ObjectMapping m, VisualProperty type) {
 		if (type == null)
 			throw new NullPointerException("Type parameter for Calculator is null");
 
@@ -246,11 +239,11 @@
 	 * MappingFactory with the ObjectMapping and the augmented base key.
 	 */
 	public Properties getProperties() {
-		final String mapBaseKey = type.getPropertyLabel() + "." + toString() + ".mapping";
+		final String mapBaseKey = type.getName() + "." + toString() + ".mapping";
 		final ObjectMapping m = getMapping(0);
 		final Properties props = MappingFactory.getProperties(m, mapBaseKey);
 
-		props.put(type.getPropertyLabel() + "." + toString() + ".visualPropertyType", type.toString());
+		props.put(type.getName() + "." + toString() + ".visualPropertyType", type.toString());
 
 		return props;
 	}
@@ -378,45 +371,9 @@
 		return CyAttributesUtils.getAttributes(canonicalName, cyAttrs);
 	}
 
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @param appr DOCUMENT ME!
-	 * @param e DOCUMENT ME!
-	 * @param net DOCUMENT ME!
-	 */
-	public void apply(Appearance appr, Edge e, GraphPerspective net) {
-		//System.out.println("AbstractCalculator.apply(edge) " + type.toString());
-		Object o = getRangeValue(e,appr.getCyAttributes());
-
-		// default has already been set - no need to do anything
-		if (o == null)
-			return;
-
-		appr.set(type, o);
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @param appr DOCUMENT ME!
-	 * @param n DOCUMENT ME!
-	 * @param net DOCUMENT ME!
-	 */
-	public void apply(Appearance appr, Node n, GraphPerspective net) {
-		//System.out.println("AbstractCalculator.apply(node) " + type.toString());
-		Object o = getRangeValue(n,appr.getCyAttributes());
-
-		// default has already been set - no need to do anything
-		if (o == null)
-			return;
-
-		appr.set(type, o);
-	}
-
 	@SuppressWarnings("unchecked") // TODO again, this should be fixed as part of CyAttributes
 	                               // this one is also related to bug 247!!!
-	protected Object getRangeValue(GraphObject obj,CyAttributes attrs) {
+	public Object getRangeValue(GraphObject obj,CyAttributes attrs) {
 		if (obj == null)
 			return null;
 
@@ -437,7 +394,7 @@
 	 *
 	 * The returned enum VisualPropertyType has replacement for these methods.
 	 */
-	public VisualPropertyType getVisualPropertyType() {
+	public VisualProperty getVisualProperty() {
 		return type;
 	}
 
Index: vizmap/src/main/java/org/cytoscape/vizmap/mappings/LegendTable.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/mappings/LegendTable.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/mappings/LegendTable.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -36,7 +36,7 @@
  */
 package org.cytoscape.vizmap.mappings;
 
-import org.cytoscape.vizmap.VisualPropertyType;
+import org.cytoscape.view.VisualProperty;
 
 import org.cytoscape.vizmap.icon.VisualPropertyIcon;
 
@@ -64,7 +64,7 @@
   */
 public class LegendTable extends JPanel {
 	private final static long serialVersionUID = 1202339875884157L;
-	private static VisualPropertyType type;
+	private static VisualProperty visualProperty;
 	private JTable legendTable;
 
 	/**
@@ -73,12 +73,12 @@
 	 * @param data  DOCUMENT ME!
 	 * @param vpt  DOCUMENT ME!
 	 */
-	public LegendTable(Object[][] data, VisualPropertyType vpt) {
+	public LegendTable(Object[][] data, VisualProperty vp) {
 		super();
 		legendTable = new JTable(data.length, 2);
 		legendTable.setRowHeight(50);
 		legendTable.setDefaultRenderer(Object.class, (TableCellRenderer) new LegendCellRenderer());
-		type = vpt;
+		visualProperty = vp;
 		setLayout(new BorderLayout());
 
 		Object value = null;
@@ -103,7 +103,7 @@
 			return null;
 		}
 
-		icon = (VisualPropertyIcon) type.getVisualProperty().getIcon(value);
+		icon = (VisualPropertyIcon) visualProperty.getIcon(value);
 		icon.setLeftPadding(5);
 
 		return icon;
@@ -117,7 +117,7 @@
 	 *
 	 * @return  DOCUMENT ME!
 	 */
-	public static JPanel getHeader(String attrName, VisualPropertyType type) {
+	public static JPanel getHeader(String attrName, VisualProperty type) {
 		final JPanel titles = new JPanel();
 		final JLabel[] labels = new JLabel[2];
 		labels[0] = new JLabel(type.getName());
Index: vizmap/src/main/java/org/cytoscape/vizmap/mappings/DiscreteMapping.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/mappings/DiscreteMapping.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/mappings/DiscreteMapping.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -53,9 +53,9 @@
 import javax.swing.event.ChangeListener;
 
 import org.cytoscape.GraphPerspective;
-import org.cytoscape.vizmap.NodeShape;
 import org.cytoscape.vizmap.SubjectBase;
-import org.cytoscape.vizmap.VisualPropertyType;
+import org.cytoscape.view.DiscreteValue;
+import org.cytoscape.view.VisualProperty;
 import org.cytoscape.vizmap.mappings.discrete.DiscreteLegend;
 import org.cytoscape.vizmap.mappings.discrete.DiscreteMappingReader;
 import org.cytoscape.vizmap.mappings.discrete.DiscreteMappingWriter;
@@ -190,7 +190,10 @@
 	public Class[] getAcceptedDataClasses() {
 		Class[] ret = {
 		                  String.class, Number.class, Integer.class, Double.class, Float.class,
-		                  Long.class, Short.class, NodeShape.class, List.class
+		                  Long.class, Short.class,
+		                  DiscreteValue.class
+		                  /*FIXME: this was originaly NodeShape.class, ie. ArrowShape etc. was missing from this list. Was that deliberate?*/,
+		                  List.class
 		              };
 
 		return ret;
@@ -275,7 +278,7 @@
 	 *
 	 * @return  DOCUMENT ME!
 	 */
-	public JPanel getLegend(VisualPropertyType vpt) {
-		return new DiscreteLegend(treeMap, attrName, vpt);
+	public JPanel getLegend(VisualProperty vp) {
+		return new DiscreteLegend(treeMap, attrName, vp);
 	}
 }
Index: vizmap/src/main/java/org/cytoscape/vizmap/mappings/ObjectMapping.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/mappings/ObjectMapping.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/mappings/ObjectMapping.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -45,7 +45,7 @@
 import org.cytoscape.GraphPerspective;
 
 import org.cytoscape.vizmap.ValueParser;
-import org.cytoscape.vizmap.VisualPropertyType;
+import org.cytoscape.view.VisualProperty;
 
 
 //----------------------------------------------------------------------------
@@ -137,7 +137,7 @@
 
     Object calculateRangeValue(Map attrBundle);
 
-    JPanel getLegend(VisualPropertyType type);
+    JPanel getLegend(VisualProperty visualProperty);
 
     Object clone();
 
Index: vizmap/src/main/java/org/cytoscape/vizmap/mappings/ContinuousMapping.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/mappings/ContinuousMapping.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/mappings/ContinuousMapping.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -44,7 +44,7 @@
 
 
 import org.cytoscape.vizmap.SubjectBase;
-import org.cytoscape.vizmap.VisualPropertyType;
+import org.cytoscape.view.VisualProperty;
 
 import org.cytoscape.vizmap.mappings.continuous.ContinuousLegend;
 import org.cytoscape.vizmap.mappings.continuous.ContinuousMappingPoint;
@@ -268,8 +268,8 @@
 	/**
 	 *
 	 */
-	public JPanel getLegend(VisualPropertyType vpt) {
-		return new ContinuousLegend(attrName, points, defaultObj, vpt);
+	public JPanel getLegend(VisualProperty vp) {
+		return new ContinuousLegend(attrName, points, defaultObj, vp);
 	}
 
 	/**
Index: vizmap/src/main/java/org/cytoscape/vizmap/mappings/discrete/DiscreteLegend.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/mappings/discrete/DiscreteLegend.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/mappings/discrete/DiscreteLegend.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -53,7 +53,7 @@
 
 import org.jdesktop.swingx.border.DropShadowBorder;
 
-import org.cytoscape.vizmap.VisualPropertyType;
+import org.cytoscape.view.VisualProperty;
 import org.cytoscape.vizmap.mappings.LegendTable;
 
 
@@ -75,14 +75,14 @@
 	 * @param dataAttr  DOCUMENT ME!
 	 * @param vpt  DOCUMENT ME!
 	 */
-	public DiscreteLegend(Map legendMap, String dataAttr, VisualPropertyType vpt) {
+	public DiscreteLegend(Map legendMap, String dataAttr, VisualProperty vp) {
 		super();
 
 		setLayout(new BorderLayout());
 		setBackground(Color.white);
 		setBorder(BORDER);
 
-		final JLabel title = new JLabel(" " + vpt.getName() + " Mapping");
+		final JLabel title = new JLabel(" " + vp.getName() + " Mapping");
 		title.setFont(TITLE_FONT2);
 		title.setForeground(TITLE_COLOR);
 		title.setBorder(new MatteBorder(0, 10, 1, 0, TITLE_COLOR));
@@ -106,7 +106,7 @@
 			data[i][1] = key;
 		}
 
-		add(LegendTable.getHeader(dataAttr, vpt), BorderLayout.CENTER);
-		add(new LegendTable(data, vpt), BorderLayout.SOUTH);
+		add(LegendTable.getHeader(dataAttr, vp), BorderLayout.CENTER);
+		add(new LegendTable(data, vp), BorderLayout.SOUTH);
 	}
 }
Index: vizmap/src/main/java/org/cytoscape/vizmap/mappings/PassThroughMapping.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/mappings/PassThroughMapping.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/mappings/PassThroughMapping.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -44,7 +44,7 @@
 
 import org.cytoscape.GraphPerspective;
 
-import org.cytoscape.vizmap.VisualPropertyType;
+import org.cytoscape.view.VisualProperty;
 
 import org.cytoscape.vizmap.ValueParser;
 
@@ -299,12 +299,12 @@
 	 *
 	 * @return  DOCUMENT ME!
 	 */
-	public JPanel getLegend(VisualPropertyType vpt) {
+	public JPanel getLegend(VisualProperty vp) {
 		JPanel p = new JPanel();
 
 		p.setLayout(new BorderLayout());
 
-		JLabel title = new JLabel(vpt.getName() + " is displayed as " + attrName);
+		JLabel title = new JLabel(vp.getName() + " is displayed as " + attrName);
 		title.setFont(TITLE_FONT);
 		title.setForeground(TITLE_COLOR);
 		title.setHorizontalAlignment(SwingConstants.CENTER);
Index: vizmap/src/main/java/org/cytoscape/vizmap/mappings/continuous/ContinuousLegend.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/mappings/continuous/ContinuousLegend.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/mappings/continuous/ContinuousLegend.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -58,7 +58,7 @@
 import javax.swing.border.EmptyBorder;
 import javax.swing.border.MatteBorder;
 
-import org.cytoscape.vizmap.VisualPropertyType;
+import org.cytoscape.view.VisualProperty;
 import org.cytoscape.vizmap.mappings.LegendTable;
 //import cytoscape.visual.ui.editors.continuous.C2CMappingEditor;
 //import cytoscape.visual.ui.editors.continuous.C2DMappingEditor;
@@ -74,7 +74,7 @@
 	private static final Color TITLE_COLOR = new Color(10, 200, 255);
 	private static final Border BORDER = new MatteBorder(0, 6, 3, 0, Color.DARK_GRAY);
 	private List points;
-	private VisualPropertyType type;
+	private VisualProperty visualProperty;
 	private JLabel legend = null;
 
 	/**
@@ -85,10 +85,10 @@
 	 * @param obj  DOCUMENT ME!
 	 * @param vpt  DOCUMENT ME!
 	 */
-	public ContinuousLegend(String dataAttr, List points, Object obj, VisualPropertyType vpt) {
+	public ContinuousLegend(String dataAttr, List points, Object obj, VisualProperty vp) {
 		super();
 		this.points = points;
-		this.type = vpt;
+		this.visualProperty = vp;
 		this.addComponentListener(new ComponentAdapter() {
 			public void componentResized(ComponentEvent e) {
 				setLegend(e);
@@ -99,7 +99,7 @@
 		setBackground(Color.white);
 		setBorder(BORDER);
 
-		final JLabel title = new JLabel(" " + vpt.getName() + " Mapping");
+		final JLabel title = new JLabel(" " + vp.getName() + " Mapping");
 		title.setFont(TITLE_FONT2);
 		title.setForeground(TITLE_COLOR);
 		title.setBorder(new MatteBorder(0, 10, 1, 0, TITLE_COLOR));
@@ -127,18 +127,18 @@
 			}
 		}
 
-		if (type.getDataType() == Color.class) {
+		if (visualProperty.getDataType() == Color.class) {
 			// TODO - fix
 			//legend = new JLabel(GradientEditorPanel.getLegend(trackW, 100, type));
-			legend = new JLabel(type.getName());
-		} else if (type.getDataType() == Number.class) {
+			legend = new JLabel(visualProperty.getName());
+		} else if (visualProperty.getDataType() == Number.class) {
 			// TODO - fix
 			//legend = new JLabel(C2CMappingEditor.getLegend(trackW, 150, type));
-			legend = new JLabel(type.getName());
+			legend = new JLabel(visualProperty.getName());
 		} else {
 			// TODO - fix
 			//legend = new JLabel(C2DMappingEditor.getLegend(trackW, 150, type));
-			legend = new JLabel(type.getName());
+			legend = new JLabel(visualProperty.getName());
 		}
 
 		legend.setBorder(new EmptyBorder(10, 10, 10, 10));
@@ -234,7 +234,7 @@
 		return new ImageIcon(bi);
 	}
 
-	private JPanel getObjectPanel(VisualPropertyType vpt) {
+	private JPanel getObjectPanel(VisualProperty vp) {
 		Object[][] data = new Object[points.size() + 2][2];
 
 		ContinuousMappingPoint curr = null;
@@ -256,7 +256,7 @@
 			}
 		}
 
-		LegendTable lt = new LegendTable(data, vpt);
+		LegendTable lt = new LegendTable(data, vp);
 
 		return lt;
 	}
Index: vizmap/src/main/java/org/cytoscape/vizmap/Appearance.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/Appearance.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/Appearance.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -1,341 +0,0 @@
-
-/*
- Copyright (c) 2006, 2007, The Cytoscape Consortium (www.cytoscape.org)
-
- The Cytoscape Consortium is:
- - Institute for Systems Biology
- - University of California San Diego
- - Memorial Sloan-Kettering Cancer Center
- - Institut Pasteur
- - Agilent Technologies
-
- This library is free software; you can redistribute it and/or modify it
- under the terms of the GNU Lesser General Public License as published
- by the Free Software Foundation; either version 2.1 of the License, or
- any later version.
-
- This library is distributed in the hope that it will be useful, but
- WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF
- MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  The software and
- documentation provided hereunder is on an "as is" basis, and the
- Institute for Systems Biology and the Whitehead Institute
- have no obligations to provide maintenance, support,
- updates, enhancements or modifications.  In no event shall the
- Institute for Systems Biology and the Whitehead Institute
- be liable to any party for direct, indirect, special,
- incidental or consequential damages, including lost profits, arising
- out of the use of this software and its documentation, even if the
- Institute for Systems Biology and the Whitehead Institute
- have been advised of the possibility of such damage.  See
- the GNU Lesser General Public License for more details.
-
- You should have received a copy of the GNU Lesser General Public License
- along with this library; if not, write to the Free Software Foundation,
- Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
-*/
-
-package org.cytoscape.vizmap;
-
-import org.cytoscape.attributes.CyAttributes;
-
-import org.cytoscape.vizmap.ValueParser;
-import org.cytoscape.vizmap.ObjectToString;
-
-
-import org.cytoscape.view.EdgeView;
-import org.cytoscape.view.NodeView;
-
-import java.util.Properties;
-import java.util.Map;
-import java.util.HashMap;
-
-import java.awt.Color;
-
-import org.cytoscape.Edge;
-import org.cytoscape.GraphObject;
-import org.cytoscape.Node;
-
-
-/**
- * A class that holds the appearance information for NodeViews and EdgeViews. 
- * The class is indexed on {@link VisualPropertyType}, so to access the node
- * shape you would use the VisualPropertyType.NODE_SHAPE enum to get and set
- * node shape values for this Appearance.
- */
-public class Appearance {
-
-	private static final String NODE_SIZE_LOCKED = ".nodeSizeLocked";
-	protected Object[] vizProps;
-	protected boolean nodeSizeLocked = true;
-	protected CyAttributes attrs;
-
-	/**
-	 * Creates a new Appearance object.
-	 */
-	public Appearance(CyAttributes attrs) {
-		this.attrs = attrs;
-		vizProps = new Object[VisualPropertyType.values().length];
-
-		for (VisualPropertyType type : VisualPropertyType.values())
-					vizProps[type.ordinal()] = type.getVisualProperty().getDefaultAppearanceObject();
-	}
-
-	public CyAttributes getCyAttributes() {
-		return attrs;
-	}
-
-	/**
-	 * Sets the appearance for the specified VisualPropertyType. 
-	 *
-	 * @param p The VisualPropertyType that identifies which aspect of the appearance
-	 *          this particular object should be applied to.
-	 * @param o The object the defines the appearance for the aspect of the appearance
-	 *          defined by parameter p.
-	 */
-	public void set(VisualPropertyType p, Object o) {
-		if (o != null)
-			vizProps[p.ordinal()] = o;
-	}
-
-	/**
-	 * Gets the appearance for the specified VisualPropertyType. 
-	 *
-	 * @param p The VisualPropertyType that identifies which aspect of the appearance to get.
-	 *
-	 * @return An Object of varying type depending on the VisualPropertyType. The
-	 *         VisualPropertyType enum defines what the type of this object will be.
-	 */
-	public Object get(VisualPropertyType p) {
-		return vizProps[p.ordinal()];
-	}
-
-	/**
-	 * Applies this appearance to the specified NodeView. 
-	 *
-	 * @param nodeView The NodeView that this appearance will be applied to. 
-	 */
-	public void applyAppearance(final NodeView nodeView) {
-        for ( VisualPropertyType type : VisualPropertyType.values() )
-            if ( type == VisualPropertyType.NODE_SIZE ) {
-                if ( nodeSizeLocked )
-                    type.getVisualProperty().applyToNodeView(nodeView,vizProps[type.ordinal()]);
-                else
-                    continue;
-            } else if ( type == VisualPropertyType.NODE_WIDTH || type == VisualPropertyType.NODE_HEIGHT ) {
-                if ( nodeSizeLocked )
-                    continue;
-                else
-                    type.getVisualProperty().applyToNodeView(nodeView,vizProps[type.ordinal()]);
-            } else
-                type.getVisualProperty().applyToNodeView(nodeView,vizProps[type.ordinal()]);	
-	}
-
-	/**
-	 * Applies this appearance to the specified EdgeView. 
-	 *
-	 * @param edgeView The EdgeView that this appearance will be applied to. 
-	 */
-	public void applyAppearance(final EdgeView edgeView) {
-		for (VisualPropertyType type : VisualPropertyType.values())
-			type.getVisualProperty().applyToEdgeView(edgeView, vizProps[type.ordinal()]);
-	}
-
-	/**
-	 * Applies the specified properties as default values for this appearance. 
-	 *
-	 * @param nacProps The properties used to specify the default appearance. 
-	 * @param baseKey A string identifying which specific properties should be
-	 *                used for the appearance.
-	 */
-	public void applyDefaultProperties(final Properties nacProps, String baseKey) {
-		for (VisualPropertyType type : VisualPropertyType.values()) {
-			Object o = type.getVisualProperty().parseProperty(nacProps, baseKey);
-
-			if (o != null)
-				vizProps[type.ordinal()] = o;
-		}
-		
-		// Apply nodeSizeLock
-		final String lockKey = baseKey + NODE_SIZE_LOCKED;
-		final String lockVal = nacProps.getProperty(lockKey);
-		if(lockVal == null || lockVal.equalsIgnoreCase("true")) {
-			setNodeSizeLocked(true);
-		} else {
-			setNodeSizeLocked(false);
-		}
-	}
-
-	/**
-	 * Returns a Properties object that defines this appearance. 
-	 *
-	 * @param baseKey The key to use to identify the specific properties for this appearance.
-	 *
-	 * @return A Properties object that defines this appearance. 
-	 */
-	public Properties getDefaultProperties(String baseKey) {
-		Properties props = new Properties();
-
-		for (VisualPropertyType type : VisualPropertyType.values()) {
-			String key = type.getDefaultPropertyKey(baseKey);
-			String value = ObjectToString.getStringValue(vizProps[type.ordinal()]);
-			if ( key != null && value != null ) {
-//				System.out.println("(Key,val) = " + key + ", " + value + ", basekey = " + baseKey);
-				props.setProperty(key,value);
-			}
-		}
-
-		// Add node size lock as an extra prop.
-		final String lockKey = baseKey + NODE_SIZE_LOCKED;
-		final String lockVal = new Boolean(getNodeSizeLocked()).toString();
-		props.setProperty(lockKey, lockVal);
-
-		return props;
-	}
-
-	/**
-	 * Returns a string describing this appearance. 
-	 *
-	 * @param prefix Can be used to apply an identifying prefix to the output strings.  
-	 *
-	 * @return A string describing the appearance. 
-	 */
-	public String getDescription(String prefix) {
-		if (prefix == null)
-			prefix = "";
-
-		final String lineSep = System.getProperty("line.separator");
-		final StringBuilder sb = new StringBuilder();
-
-		for (VisualPropertyType type : VisualPropertyType.values()) {
-			if (vizProps[type.ordinal()] != null) {
-				sb.append(prefix);
-				sb.append(type.getName());
-				sb.append(" = ");
-				sb.append(ObjectToString.getStringValue(vizProps[type.ordinal()]));
-				sb.append(lineSep);
-			}
-		}
-
-		return sb.toString();
-	}
-
-	/**
-	 * Returns a string describing this appearance with no identifying prefix. 
-	 *
-	 * @return A string describing the appearance. 
-	 */
-	public String getDescription() {
-		return getDescription(null);
-	}
-
-	/**
-	 * Copies the specified Appearance into <i>this</i> Appearance object. 
-	 *
-	 * @param na The Appearance object that will be copied into <i>this</i> Appearance object. 
-	 */
-	public void copy(final Appearance na) {
-
-		final boolean actualLockState = na.getNodeSizeLocked();
-
-        // set everything to false so that it copies correctly
-        setNodeSizeLocked(false);
-        na.setNodeSizeLocked(false);
-
-		for (VisualPropertyType type : VisualPropertyType.values())
-			this.vizProps[type.ordinal()] = na.get(type);
-
-        // now set the lock state correctly
-        setNodeSizeLocked(actualLockState);
-        na.setNodeSizeLocked(actualLockState);
-	}
-
-	/**
-	 * Returns a clone of this Appearance. 
-	 *
-	 * @return A clone of this Appearance. 
-	 */
-	public Object clone() {
-		Appearance ga = new Appearance(attrs);
-		ga.copy(this);
-
-		return ga;
-	}
-
-	/**
-	 * Applies the visual bypass values specified in the node (edge) attributes
-	 * for the specified node (edge) to the node (edge). 
-	 *
-	 * @param n The {@link Node} or {@link Edge} object that the visual bypass 
-	 *          should be applied to.
-	 */
-	public void applyBypass(final GraphObject n) {
-		if (n == null)
-			return;
-
-		final String id = n.getIdentifier();
-
-		for (VisualPropertyType type : VisualPropertyType.values()) {
-			Object bypass = getBypass(attrs, id, type);
-
-			if (bypass != null)
-				vizProps[type.ordinal()] = bypass;
-		}
-	}
-
-	/**
-	 * A helper method that returns the specified bypass object if one happens to exist for
-	 * this node/edge and property type.
-	 *
-	 * This method has default scope only to help with unit testing. 
-	 *
-	 * You really shouldn't have any reason to use this method!
-	 */
-    static Object getBypass( CyAttributes xattrs, String id, VisualPropertyType type ) {
-		String attrName = type.getBypassAttrName();
-
-        final String value = xattrs.getStringAttribute(id, attrName);
-
-        if (value == null)
-            return null;
-
-        ValueParser p = type.getValueParser(); 
-
-        Object ret = null;
-        if (p != null)
-            ret = p.parseStringValue(value);
-        else
-            return null;
-
-        // now do color...
-        if ( ret == null || !(ret instanceof Color) || !(ret.equals(Color.black)))
-            return ret;
-
-        // now check to see that the attribute actually specifies black,
-        // and isn't returning black by default
-        final String v = xattrs.getStringAttribute(id, attrName);
-
-        if (v == null)
-            return null;
-
-        if (v.equals("0,0,0"))
-            return ret;
-        else
-            return null;
-    }
-
-	/**
-	 * Returns whether or not the node height and width are locked.
-	 * @return Whether or not the node height and width are locked.
-	 */
-    public boolean getNodeSizeLocked() {
-        return nodeSizeLocked;
-    }
-
-	/**
-	 * Sets whether or not the node height and width are locked.
-	 */
-    public void setNodeSizeLocked(boolean b) {
-        nodeSizeLocked = b;
-    }
-
-}
Index: vizmap/src/main/java/org/cytoscape/vizmap/NodeAppearance.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/NodeAppearance.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/NodeAppearance.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -1,91 +0,0 @@
-/*
- File: NodeAppearance.java
-
- Copyright (c) 2006, The Cytoscape Consortium (www.cytoscape.org)
-
- The Cytoscape Consortium is:
- - Institute for Systems Biology
- - University of California San Diego
- - Memorial Sloan-Kettering Cancer Center
- - Institut Pasteur
- - Agilent Technologies
-
- This library is free software; you can redistribute it and/or modify it
- under the terms of the GNU Lesser General Public License as published
- by the Free Software Foundation; either version 2.1 of the License, or
- any later version.
-
- This library is distributed in the hope that it will be useful, but
- WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF
- MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  The software and
- documentation provided hereunder is on an "as is" basis, and the
- Institute for Systems Biology and the Whitehead Institute
- have no obligations to provide maintenance, support,
- updates, enhancements or modifications.  In no event shall the
- Institute for Systems Biology and the Whitehead Institute
- be liable to any party for direct, indirect, special,
- incidental or consequential damages, including lost profits, arising
- out of the use of this software and its documentation, even if the
- Institute for Systems Biology and the Whitehead Institute
- have been advised of the possibility of such damage.  See
- the GNU Lesser General Public License for more details.
-
- You should have received a copy of the GNU Lesser General Public License
- along with this library; if not, write to the Free Software Foundation,
- Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- */
-
-//----------------------------------------------------------------------------
-// $Revision: 12953 $
-// $Date: 2008-02-05 18:07:28 -0800 (Tue, 05 Feb 2008) $
-// $Author: mes $
-//----------------------------------------------------------------------------
-package org.cytoscape.vizmap;
-
-import static org.cytoscape.vizmap.VisualPropertyType.NODE_HEIGHT;
-import static org.cytoscape.vizmap.VisualPropertyType.NODE_SIZE;
-import static org.cytoscape.vizmap.VisualPropertyType.NODE_WIDTH;
-import org.cytoscape.view.NodeView;
-import org.cytoscape.attributes.CyAttributesFactory;
-
-import java.awt.Color;
-import java.awt.Font;
-
-
-/**
- * Objects of this class hold data describing the appearance of a Node.
- */
-public class NodeAppearance extends Appearance {
-
-	/**
-	 * Constructor.
-	 */
-	public NodeAppearance() {
-		super(CyAttributesFactory.getCyAttributes("node"));
-	}
-
-	/**
-	 * Clone.
-	 */
-    public Object clone() {
-		NodeAppearance ga = new NodeAppearance();
-		ga.copy(this);
-		return ga;
-	}
-
-    public Object get(VisualPropertyType p) {
-		if ( p == VisualPropertyType.NODE_WIDTH || p == VisualPropertyType.NODE_HEIGHT ) 
-			if ( nodeSizeLocked )
-				return vizProps[VisualPropertyType.NODE_SIZE.ordinal()]; 
-
-        return vizProps[p.ordinal()];
-    }
-
-	public void set(VisualPropertyType p, Object o) {
-		if (o == null)
-			return;
-		vizProps[p.ordinal()] = o;
-	}
-
-
-}
Index: vizmap/src/main/java/org/cytoscape/vizmap/NodeShape.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/NodeShape.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/NodeShape.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -1,216 +0,0 @@
-/*
- Copyright (c) 2006, 2007, The Cytoscape Consortium (www.cytoscape.org)
-
- The Cytoscape Consortium is:
- - Institute for Systems Biology
- - University of California San Diego
- - Memorial Sloan-Kettering Cancer Center
- - Institut Pasteur
- - Agilent Technologies
-
- This library is free software; you can redistribute it and/or modify it
- under the terms of the GNU Lesser General Public License as published
- by the Free Software Foundation; either version 2.1 of the License, or
- any later version.
-
- This library is distributed in the hope that it will be useful, but
- WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF
- MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  The software and
- documentation provided hereunder is on an "as is" basis, and the
- Institute for Systems Biology and the Whitehead Institute
- have no obligations to provide maintenance, support,
- updates, enhancements or modifications.  In no event shall the
- Institute for Systems Biology and the Whitehead Institute
- be liable to any party for direct, indirect, special,
- incidental or consequential damages, including lost profits, arising
- out of the use of this software and its documentation, even if the
- Institute for Systems Biology and the Whitehead Institute
- have been advised of the possibility of such damage.  See
- the GNU Lesser General Public License for more details.
-
- You should have received a copy of the GNU Lesser General Public License
- along with this library; if not, write to the Free Software Foundation,
- Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
-*/
-package org.cytoscape.vizmap;
-
-import org.cytoscape.vizmap.icon.NodeIcon;
-import org.cytoscape.vizmap.icon.VisualPropertyIcon;
-
-import org.cytoscape.view.ShapeFactory;
-
-import org.cytoscape.view.NodeView;
-
-import java.awt.Shape;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import javax.swing.Icon;
-
-/**
- * This is a replacement for ShapeNodeRealizer.java
- *
- * @since Cytoscape 2.5
- * @version 0.7
- * @author kono
- *
- */
-public enum NodeShape {
-	RECT(NodeView.RECTANGLE, "Rectangle", true),
-	ROUND_RECT(NodeView.ROUNDED_RECTANGLE, "Round Rectangle", true),
-	RECT_3D(NodeView.RECTANGLE, "3D Rectabgle", false),
-	TRAPEZOID(NodeView.RECTANGLE, "Trapezoid", false),
-	TRAPEZOID_2(NodeView.RECTANGLE, "Trapezoid 2", false),
-	TRIANGLE(NodeView.TRIANGLE, "Triangle", true),
-	PARALLELOGRAM(NodeView.PARALELLOGRAM, "Parallelogram", true),
-	DIAMOND(NodeView.DIAMOND, "Diamond", true),
-	ELLIPSE(NodeView.ELLIPSE, "Ellipse", true),
-	HEXAGON(NodeView.HEXAGON, "Hexagon", true),
-	OCTAGON(NodeView.OCTAGON, "Octagon", true);
-
-	private int ginyShape;
-	private String name;
-	private boolean isSupported;
-	private static Map<Integer, Shape> nodeShapes = ShapeFactory.getNodeShapes();
-
-	private NodeShape(int ginyShape, String name, boolean isSupported) {
-		this.ginyShape = ginyShape;
-		this.name = name;
-		this.isSupported = isSupported;
-	}
-
-	/**
-	 * If the shape is supported by rendering engine, return true.<br>
-	 * Otherwise, return false.
-	 * @return
-	 */
-	public boolean isSupported() {
-		return isSupported;
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @param text DOCUMENT ME!
-	 *
-	 * @return DOCUMENT ME!
-	 */
-	public static NodeShape parseNodeShapeText(String text) {
-		String trimed = text.trim();
-
-		for (NodeShape shape : values()) {
-			if (getNodeShapeText(shape).equalsIgnoreCase(trimed))
-				return shape;
-		}
-
-		// Unknown shape: return rectangle.
-		return NodeShape.RECT;
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @return DOCUMENT ME!
-	 */
-	public static String[] valuesAsString() {
-		final int length = values().length;
-		final String[] nameArray = new String[length];
-
-		for (int i = 0; i < length; i++)
-			nameArray[i] = values()[i].getShapeName();
-
-		return nameArray;
-	}
-
-	/**
-	 * Get name of the shape.
-	 *
-	 * @return DOCUMENT ME!
-	 */
-	public String getShapeName() {
-		return name;
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @param type
-	 *            DOCUMENT ME!
-	 *
-	 * @return DOCUMENT ME!
-	 */
-	public static boolean isValidShape(NodeShape type) {
-		for (NodeShape curType : values()) {
-			if (type == curType)
-				return true;
-		}
-
-		return false;
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @param shape
-	 *            DOCUMENT ME!
-	 *
-	 * @return DOCUMENT ME!
-	 */
-	public static String getNodeShapeText(NodeShape shape) {
-		String nstext = shape.name();
-		nstext = nstext.replaceAll("_", "");
-
-		return nstext.toLowerCase();
-	}
-
-	/**
-	 * Get GINY shape as integer.
-	 *
-	 * @return Giny shape as integer.
-	 */
-	public int getGinyShape() {
-		return ginyShape;
-	}
-
-	/**
-	 * Convert from Giny shape to Cytoscape NodeShape enum.
-	 *
-	 * @param ginyShape
-	 * @return
-	 */
-	public static NodeShape getNodeShape(int ginyShape) {
-		for (NodeShape shape : values()) {
-			if (shape.ginyShape == ginyShape)
-				return shape;
-		}
-
-		// Unknown. Return rectangle as the def val.
-		return NodeShape.RECT;
-	}
-
-	/**
-	 * Returns a Shape object for the NodeShape in question.
-	 */
-	public Shape getShape() {
-		return nodeShapes.get(ginyShape);
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @return  DOCUMENT ME!
-	 */
-	public static Map<Object, Icon> getIconSet() {
-		Map<Object, Icon> nodeShapeIcons = new HashMap<Object, Icon>();
-
-		for (NodeShape shape : values()) {
-			NodeIcon icon = new NodeIcon(nodeShapes.get(shape.getGinyShape()),
-			                             VisualPropertyIcon.DEFAULT_ICON_SIZE,
-			                             VisualPropertyIcon.DEFAULT_ICON_SIZE, shape.getShapeName());
-			nodeShapeIcons.put(shape, icon);
-		}
-
-		return nodeShapeIcons;
-	}
-}
Index: vizmap/src/main/java/org/cytoscape/vizmap/LineStyle.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/LineStyle.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/LineStyle.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -1,173 +0,0 @@
-
-/*
- Copyright (c) 2006, 2007, The Cytoscape Consortium (www.cytoscape.org)
-
- The Cytoscape Consortium is:
- - Institute for Systems Biology
- - University of California San Diego
- - Memorial Sloan-Kettering Cancer Center
- - Institut Pasteur
- - Agilent Technologies
-
- This library is free software; you can redistribute it and/or modify it
- under the terms of the GNU Lesser General Public License as published
- by the Free Software Foundation; either version 2.1 of the License, or
- any later version.
-
- This library is distributed in the hope that it will be useful, but
- WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF
- MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  The software and
- documentation provided hereunder is on an "as is" basis, and the
- Institute for Systems Biology and the Whitehead Institute
- have no obligations to provide maintenance, support,
- updates, enhancements or modifications.  In no event shall the
- Institute for Systems Biology and the Whitehead Institute
- be liable to any party for direct, indirect, special,
- incidental or consequential damages, including lost profits, arising
- out of the use of this software and its documentation, even if the
- Institute for Systems Biology and the Whitehead Institute
- have been advised of the possibility of such damage.  See
- the GNU Lesser General Public License for more details.
-
- You should have received a copy of the GNU Lesser General Public License
- along with this library; if not, write to the Free Software Foundation,
- Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
-*/
-
-package org.cytoscape.vizmap;
-
-import java.awt.BasicStroke;
-import java.awt.Stroke;
-import javax.swing.Icon;
-import java.util.Map;
-import java.util.HashMap;
-import java.util.regex.Pattern;
-import java.util.regex.Matcher;
-import org.cytoscape.vizmap.icon.*;
-
-/**
- *
- * Define line stroke.
- *
- * TODO: need to modify rendering engine to fully support dash lines.
- *
- * @author kono
- *
- */
-public enum LineStyle {
-	SOLID(null,"line"),
-	LONG_DASH("10.0f,4.0f","dash");
-
-	// DASH("4.0f,4.0f"),
-	// DASH_DOT("12.0f,3.0f,3.0f,3.0f"),
-
-	private final float[] strokeDef;
-	private String regex;
-
-	private LineStyle(String def, String regex) {
-		if (def == null)
-			strokeDef = null;
-		else {
-			final String[] parts = def.split(",");
-			strokeDef = new float[parts.length];
-
-			for (int i = 0; i < strokeDef.length; i++)
-				strokeDef[i] = Float.parseFloat(parts[i]);
-		}
-
-		this.regex = regex;
-	}
-
-	private String getRegex() {
-		return regex;
-	}
-
-	public static LineStyle parse(String val) {
-		// first check the style names
-		for ( LineStyle ls : values() ) {
-			if ( ls.toString().equals(val) )
-				return ls;
-		}
-
-		// then try regex matching instead 
-		for ( LineStyle ls : values() ) {
-			Pattern p = Pattern.compile(ls.getRegex(),Pattern.CASE_INSENSITIVE);
-			Matcher m = p.matcher(val);
-			if ( m.matches() ) {
-				return ls;
-			}
-		}
-
-		// default
-		return SOLID;
-	}
-
-	private static Pattern numPattern = Pattern.compile("(\\d+)");
-
-	/** 
-	 * This method attempts to extract a width from a string that has
-	 * a number in it like "dashed1" or "line2". This exists to support
-	 * old-style line type definitions.
-	 * @return The parsed value or if something doesn't match, 1.0
-	 */
-	public static float parseWidth(String s) {
-		Matcher m = numPattern.matcher(s);
-		if ( m.matches() ) {
-			try {
-				return (new Float(m.group(1))).floatValue();
-			} catch (Exception e) { }
-		}
-		return 1.0f;
-	}
-
-	/**
-	 * A method that attempts to figure out if a stroke is dashed
-	 * or not.  If the Stroke object is not a BasicStroke, it will
-	 * return SOLID by default.
-	 * @return the LineStyle guessed based on the BasicStroke dash array.
-	 */
-	public static LineStyle extractLineStyle(Stroke stroke) {
-		if ( stroke instanceof BasicStroke ) {
-        	final float[] dash = ((BasicStroke)stroke).getDashArray();
-			if ( dash == null )
-				return SOLID;
-			else
-				return LONG_DASH;
-		} 
-
-		return SOLID;
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @param width DOCUMENT ME!
-	 *
-	 * @return DOCUMENT ME!
-	 */
-	public Stroke getStroke(float width) {
-		if (strokeDef != null)
-			return new BasicStroke(width, BasicStroke.CAP_ROUND, BasicStroke.JOIN_MITER, 10.0f,
-			                       strokeDef, 0.0f);
-		else
-			return new BasicStroke(width);
-	}
-	
-	public float[] getDashDef() {
-		return strokeDef;
-	}
-
-    public static Map<Object,Icon> getIconSet() {
-        Map<Object,Icon> icons = new HashMap<Object,Icon>();
-
-        for (LineStyle def : values()) {
-            LineTypeIcon icon = new LineTypeIcon((BasicStroke) def.getStroke(5.0f), 
-                                                 VisualPropertyIcon.DEFAULT_ICON_SIZE * 4, 
-                                                 VisualPropertyIcon.DEFAULT_ICON_SIZE, 
-												 def.name());
-            icons.put(def, icon);
-        }
-
-        return icons;
-    }
-}
Index: vizmap/src/main/java/org/cytoscape/vizmap/VisualProperty.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/VisualProperty.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/VisualProperty.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -1,76 +0,0 @@
-/*
- Copyright (c) 2007, The Cytoscape Consortium (www.cytoscape.org)
-
- The Cytoscape Consortium is:
- - Institute for Systems Biology
- - University of California San Diego
- - Memorial Sloan-Kettering Cancer Center
- - Institut Pasteur
- - Agilent Technologies
-
- This library is free software; you can redistribute it and/or modify it
- under the terms of the GNU Lesser General Public License as published
- by the Free Software Foundation; either version 2.1 of the License, or
- any later version.
-
- This library is distributed in the hope that it will be useful, but
- WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF
- MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  The software and
- documentation provided hereunder is on an "as is" basis, and the
- Institute for Systems Biology and the Whitehead Institute
- have no obligations to provide maintenance, support,
- updates, enhancements or modifications.  In no event shall the
- Institute for Systems Biology and the Whitehead Institute
- be liable to any party for direct, indirect, special,
- incidental or consequential damages, including lost profits, arising
- out of the use of this software and its documentation, even if the
- Institute for Systems Biology and the Whitehead Institute
- have been advised of the possibility of such damage.  See
- the GNU Lesser General Public License for more details.
-
- You should have received a copy of the GNU Lesser General Public License
- along with this library; if not, write to the Free Software Foundation,
- Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- */
-package org.cytoscape.vizmap;
-
-import java.util.Map;
-
-import javax.swing.Icon;
-import java.util.Properties;
-import org.cytoscape.view.EdgeView;
-import org.cytoscape.view.NodeView;
-
-
-/**
- * Represents a visual property.  All vp should implement this interface.
- * 
-  */
-public interface VisualProperty {
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @return  DOCUMENT ME!
-	 */
-	public VisualPropertyType getType();
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @return  DOCUMENT ME!
-	 */
-	public Map<Object, Icon> getIconSet();
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @return  DOCUMENT ME!
-	 */
-	public Icon getDefaultIcon();
-	public Icon getIcon(final Object value);
-
-	public void applyToNodeView(NodeView nv, Object o);
-	public void applyToEdgeView(EdgeView nv, Object o);
-	public Object parseProperty(Properties props, String baseKey);
-	public Object getDefaultAppearanceObject();
-}
Index: vizmap/src/main/java/org/cytoscape/vizmap/AppearanceCalculator.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/AppearanceCalculator.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/AppearanceCalculator.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -1,234 +0,0 @@
-/*
- File: AppearanceCalculator.java
-
- Copyright (c) 2006, The Cytoscape Consortium (www.cytoscape.org)
-
- The Cytoscape Consortium is:
- - Institute for Systems Biology
- - University of California San Diego
- - Memorial Sloan-Kettering Cancer Center
- - Institut Pasteur
- - Agilent Technologies
-
- This library is free software; you can redistribute it and/or modify it
- under the terms of the GNU Lesser General Public License as published
- by the Free Software Foundation; either version 2.1 of the License, or
- any later version.
-
- This library is distributed in the hope that it will be useful, but
- WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF
- MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  The software and
- documentation provided hereunder is on an "as is" basis, and the
- Institute for Systems Biology and the Whitehead Institute
- have no obligations to provide maintenance, support,
- updates, enhancements or modifications.  In no event shall the
- Institute for Systems Biology and the Whitehead Institute
- be liable to any party for direct, indirect, special,
- incidental or consequential damages, including lost profits, arising
- out of the use of this software and its documentation, even if the
- Institute for Systems Biology and the Whitehead Institute
- have been advised of the possibility of such damage.  See
- the GNU Lesser General Public License for more details.
-
- You should have received a copy of the GNU Lesser General Public License
- along with this library; if not, write to the Free Software Foundation,
- Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- */
-package org.cytoscape.vizmap;
-
-import org.cytoscape.vizmap.calculators.Calculator;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Properties;
-
-
-/**
- * This class calculates the appearance of a Node. It holds a default value and
- * a (possibly null) calculator for each visual attribute.
- */
-abstract class AppearanceCalculator implements Cloneable {
-	protected List<Calculator> calcs = new ArrayList<Calculator>();
-	protected Appearance tmpDefaultAppearance;
-
-	/**
-	 * Make shallow copy of this object
-	 */
-	public Object clone() {
-		Object copy = null;
-
-		try {
-			copy = super.clone();
-		} catch (CloneNotSupportedException e) {
-			System.err.println("Error cloning!");
-		}
-
-		return copy;
-	}
-	
-	/**
-	 * Make deep copy of this object
-	 */
-	public Object clone(String vsName) {
-		Object copy = null;
-
-		System.out.println("====Cloning: " + this.toString());
-		
-		try {
-			copy = super.clone();
-		} catch (CloneNotSupportedException e) {
-			System.err.println("Error cloning!");
-		}
-
-		return copy;
-	}
-
-	/**
-	 * Creates a new AppearanceCalculator object.
-	 */
-	public AppearanceCalculator() {
-	}
-
-	/**
-	 * Creates a new AppearanceCalculator and immediately customizes it by
-	 * calling applyProperties with the supplied arguments.
-	 */
-	public AppearanceCalculator(String name, Properties nacProps, String baseKey,
-	                            CalculatorCatalog catalog, Appearance appr) {
-		tmpDefaultAppearance = appr;
-		applyProperties(appr, name, nacProps, baseKey, catalog);
-	}
-
-	/**
-	 * Creates a new AppearanceCalculator object.
-	 *
-	 * @param toCopy DOCUMENT ME!
-	 */
-	public AppearanceCalculator(AppearanceCalculator toCopy) {
-		if (toCopy == null)
-			return;
-
-		for (Calculator c : toCopy.getCalculators()) {
-			System.out.println("New calc = " + c.toString());
-			setCalculator(c);
-		}
-
-		copyDefaultAppearance(toCopy);
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @param type DOCUMENT ME!
-	 *
-	 * @return DOCUMENT ME!
-	 */
-	public Calculator getCalculator(final VisualPropertyType type) {
-		for (Calculator nc : calcs) {
-			if (nc.getVisualPropertyType() == type)
-				return nc;
-		}
-
-		return null;
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @return DOCUMENT ME!
-	 */
-	public List<Calculator> getCalculators() {
-		return calcs;
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @param type DOCUMENT ME!
-	 */
-	public void removeCalculator(final VisualPropertyType type) {
-		Calculator toBeRemoved = null;
-
-		for (Calculator c : calcs) {
-			if (c.getVisualPropertyType() == type) {
-				toBeRemoved = c;
-
-				break;
-			}
-		}
-
-		calcs.remove(toBeRemoved);
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @param c DOCUMENT ME!
-	 */
-	public void setCalculator(Calculator c) {
-		if (c == null)
-			return;
-
-		Calculator toReplace = null;
-
-		for (Calculator nc : calcs)
-			if (nc.getVisualPropertyType() == c.getVisualPropertyType()) {
-				toReplace = nc;
-
-				break;
-			}
-
-		if (toReplace != null)
-			calcs.remove(toReplace);
-
-		calcs.add(c);
-	}
-
-	protected String getDescription(String name, Appearance defaultAppr) {
-		final String lineSep = System.getProperty("line.separator");
-		final StringBuilder sb = new StringBuilder();
-
-		sb.append(name + ":" + lineSep);
-		sb.append(defaultAppr.getDescription("default")).append(lineSep);
-
-		for (Calculator c : calcs)
-			sb.append(c.toString()).append(lineSep);
-
-		return sb.toString();
-	}
-
-	protected void applyProperties(Appearance appr, String name, Properties nacProps,
-	                               String baseKey, CalculatorCatalog catalog) {
-		String value = null;
-
-		appr.applyDefaultProperties(nacProps, baseKey);
-
-		Calculator newCalc;
-
-		for (VisualPropertyType type : catalog.getCalculatorTypes()) {
-			for (Calculator c : catalog.getCalculators(type)) {
-				value = nacProps.getProperty(baseKey + "."
-				                             + c.getVisualPropertyType().getPropertyLabel());
-				newCalc = catalog.getCalculator(c.getVisualPropertyType(), value);
-				setCalculator(newCalc);
-			}
-		}
-	}
-
-	protected Properties getProperties(Appearance appr, String baseKey) {
-		String key = null;
-		String value = null;
-		Properties newProps = appr.getDefaultProperties(baseKey);
-
-		for (Calculator c : calcs) {
-			// do actual
-			key = baseKey + "." + c.getVisualPropertyType().getPropertyLabel();
-			value = c.toString();
-			newProps.setProperty(key, value);
-		}
-
-		return newProps;
-	}
-
-	protected abstract void copyDefaultAppearance(AppearanceCalculator toCopy);
-}
Index: vizmap/src/main/java/org/cytoscape/vizmap/VisualPropertyType.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/VisualPropertyType.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/VisualPropertyType.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -1,472 +0,0 @@
-/*
- Copyright (c) 2006, 2007, The Cytoscape Consortium (www.cytoscape.org)
-
- The Cytoscape Consortium is:
- - Institute for Systems Biology
- - University of California San Diego
- - Memorial Sloan-Kettering Cancer Center
- - Institut Pasteur
- - Agilent Technologies
-
- This library is free software; you can redistribute it and/or modify it
- under the terms of the GNU Lesser General Public License as published
- by the Free Software Foundation; either version 2.1 of the License, or
- any later version.
-
- This library is distributed in the hope that it will be useful, but
- WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF
- MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  The software and
- documentation provided hereunder is on an "as is" basis, and the
- Institute for Systems Biology and the Whitehead Institute
- have no obligations to provide maintenance, support,
- updates, enhancements or modifications.  In no event shall the
- Institute for Systems Biology and the Whitehead Institute
- be liable to any party for direct, indirect, special,
- incidental or consequential damages, including lost profits, arising
- out of the use of this software and its documentation, even if the
- Institute for Systems Biology and the Whitehead Institute
- have been advised of the possibility of such damage.  See
- the GNU Lesser General Public License for more details.
-
- You should have received a copy of the GNU Lesser General Public License
- along with this library; if not, write to the Free Software Foundation,
- Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- */
-package org.cytoscape.vizmap;
-
-import java.awt.Color;
-import java.awt.Font;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.cytoscape.vizmap.calculators.Calculator;
-import org.cytoscape.vizmap.properties.EdgeColorProp;
-import org.cytoscape.vizmap.properties.EdgeFontFaceProp;
-import org.cytoscape.vizmap.properties.EdgeFontSizeProp;
-import org.cytoscape.vizmap.properties.EdgeLabelColorProp;
-import org.cytoscape.vizmap.properties.EdgeLabelOpacityProp;
-import org.cytoscape.vizmap.properties.EdgeLabelPositionProp;
-import org.cytoscape.vizmap.properties.EdgeLabelProp;
-import org.cytoscape.vizmap.properties.EdgeLineStyleProp;
-import org.cytoscape.vizmap.properties.EdgeLineWidthProp;
-import org.cytoscape.vizmap.properties.EdgeOpacityProp;
-import org.cytoscape.vizmap.properties.EdgeSourceArrowColorProp;
-import org.cytoscape.vizmap.properties.EdgeSourceArrowOpacityProp;
-import org.cytoscape.vizmap.properties.EdgeSourceArrowShapeProp;
-import org.cytoscape.vizmap.properties.EdgeTargetArrowColorProp;
-import org.cytoscape.vizmap.properties.EdgeTargetArrowOpacityProp;
-import org.cytoscape.vizmap.properties.EdgeTargetArrowShapeProp;
-import org.cytoscape.vizmap.properties.EdgeToolTipProp;
-import org.cytoscape.vizmap.properties.NodeBorderColorProp;
-import org.cytoscape.vizmap.properties.NodeBorderOpacityProp;
-import org.cytoscape.vizmap.properties.NodeFillColorProp;
-import org.cytoscape.vizmap.properties.NodeFontFaceProp;
-import org.cytoscape.vizmap.properties.NodeFontSizeProp;
-import org.cytoscape.vizmap.properties.NodeHeightProp;
-import org.cytoscape.vizmap.properties.NodeLabelColorProp;
-import org.cytoscape.vizmap.properties.NodeLabelOpacityProp;
-import org.cytoscape.vizmap.properties.NodeLabelPositionProp;
-import org.cytoscape.vizmap.properties.NodeLabelProp;
-import org.cytoscape.vizmap.properties.NodeLineStyleProp;
-import org.cytoscape.vizmap.properties.NodeLineWidthProp;
-import org.cytoscape.vizmap.properties.NodeOpacityProp;
-import org.cytoscape.vizmap.properties.NodeShapeProp;
-import org.cytoscape.vizmap.properties.NodeSizeProp;
-import org.cytoscape.vizmap.properties.NodeToolTipProp;
-import org.cytoscape.vizmap.properties.NodeWidthProp;
-import org.cytoscape.vizmap.parsers.*;
-import org.cytoscape.vizmap.ValueParser;
-
-/**
- * Enum for calculator types.<br>
- *
- * This will replace public constants defined in VizMapperUI class.<br>
- * This Enum defines visual attributes used in Cytoscape.
- *
- * @version 0.5
- * @since Cytoscape 2.5
- * @author kono
- *
- */
-public enum VisualPropertyType {
-
-	NODE_FILL_COLOR("Node Color", "nodeFillColorCalculator", "node.fillColor",
-	                "defaultNodeFillColor", Color.class,
-	                new NodeFillColorProp(), new ColorParser(), true, true),
-	NODE_BORDER_COLOR("Node Border Color", "nodeBorderColorCalculator", "node.borderColor",
-	                  "defaultNodeBorderColor", 
-	                  Color.class, new NodeBorderColorProp(), new ColorParser(), true, true ), 
-	NODE_SHAPE("Node Shape", "nodeShapeCalculator", "node.shape", "defaultNodeShape",
-	           NodeShape.class, new NodeShapeProp(),
-			   new NodeShapeParser(), true, true), 
-	NODE_SIZE("Node Size", "nodeUniformSizeCalculator", "node.size", "defaultNodeSize",
-	          Number.class, new NodeSizeProp(),
-			  new DoubleParser(), true, true), 
-	NODE_WIDTH("Node Width", "nodeWidthCalculator", "node.width", "defaultNodeWidth",
-	           Number.class, new NodeWidthProp(),
-			   new DoubleParser(), true, true), 
-	NODE_HEIGHT("Node Height", "nodeHeightCalculator", "node.height", "defaultNodeHight",
-	            Number.class, new NodeHeightProp(),
-				new DoubleParser(), true, true), 
-	NODE_LABEL("Node Label", "nodeLabelCalculator", "node.label", "defaultNodeLabel",
-	           String.class, new NodeLabelProp(),
-			   new StringParser(), true, true), 
-	NODE_FONT_FACE("Node Font Face", "nodeFontFaceCalculator", "node.font", "defaultNodeFont",
-	               Font.class, new NodeFontFaceProp(),
-				   new FontParser(), true, true), 
-	NODE_FONT_SIZE("Node Font Size", "nodeFontSizeCalculator", "node.fontSize",
-	               "defaultNodeFontSize", Number.class,
-	               new NodeFontSizeProp(), new DoubleParser(), true, true), 
-	NODE_LABEL_COLOR("Node Label Color", "nodeLabelColor", "node.labelColor",
-	                 "defaultNodeLabelColor", Color.class,
-	                 new NodeLabelColorProp(), new ColorParser(), true, true), 
-	NODE_TOOLTIP("Node Tooltip", "nodeTooltipCalculator", "node.toolTip", "defaultNodeToolTip",
-	             String.class, new NodeToolTipProp(),
-				 new StringParser(), true, true), 
-	NODE_LABEL_POSITION("Node Label Position", "nodeLabelPositionCalculator", "node.labelPosition",
-	                    "defaultNodeLabelPosition", 
-	                    LabelPosition.class, new NodeLabelPositionProp(), new LabelPositionParser(), true, true), 
-	EDGE_COLOR("Edge Color", "edgeColorCalculator", "edge.color", "defaultEdgeColor",
-	           Color.class, new EdgeColorProp(),
-			   new ColorParser(), false, true), 
-//	EDGE_SRCARROW("Edge Source Arrow", "edgeSourceArrowCalculator", "edge.sourceArrow",
-//	              "defaultEdgeSourceArrow", Arrow.class,
-//	              new EdgeSourceArrowProp(), new ArrowParser(), false, false), 
-//	EDGE_TGTARROW("Edge Target Arrow", "edgeTargetArrowCalculator", "edge.targetArrow",
-//	              "defaultEdgeTargetArrow", Arrow.class,
-//	              new EdgeTargetArrowProp(), new ArrowParser(), false, false), 
-	EDGE_LABEL("Edge Label", "edgeLabelCalculator", "edge.label", "defaultEdgeLabel",
-	           String.class, new EdgeLabelProp(),
-			   new StringParser(), false, true), 
-	EDGE_FONT_FACE("Edge Font Face", "edgeFontFaceCalculator", "edge.font", "defaultEdgeFont",
-	               Font.class, new EdgeFontFaceProp(),
-				   new FontParser(), false, true), 
-	EDGE_FONT_SIZE("Edge Font Size", "edgeFontSizeCalculator", "edge.fontSize",
-	               "defaultEdgeFontSize", Number.class,
-	               new EdgeFontSizeProp(), new DoubleParser(), false, true), 
-	EDGE_LABEL_COLOR("Edge Label Color", "edgeLabelColorCalculator", "edge.labelColor",
-	                 "defaultEdgeLabelColor", Color.class,
-	                 new EdgeLabelColorProp(), new ColorParser(), false, true), 
-	EDGE_TOOLTIP("Edge Tooltip", "edgeTooltipCalculator", "edge.toolTip", "defaultEdgeToolTip",
-	             String.class, new EdgeToolTipProp(),
-				 new StringParser(), false, true), 
-
-	// New from 2.5: line can have arbitrary width.
-	NODE_LINE_WIDTH("Node Line Width", "nodeLineWidthCalculator", "node.lineWidth",
-	                "defaultNodeLineWidth", Number.class,
-	                new NodeLineWidthProp(), new FloatParser(), true, true), 
-	EDGE_LINE_WIDTH("Edge Line Width", "edgeLineWidthCalculator", "edge.lineWidth",
-	                "defaultEdgeLineWidth", Number.class,
-	                new EdgeLineWidthProp(), new FloatParser(), false, true), 
-	NODE_LINE_STYLE("Node Line Style", "nodeLineStyleCalculator", "node.lineStyle",
-	                "defaultNodeLineStyle", LineStyle.class,
-	                new NodeLineStyleProp(), new LineStyleParser(), true, true), 
-	EDGE_LINE_STYLE("Edge Line Style", "edgeLineStyleCalculator", "edge.lineStyle",
-	                "defaultEdgeLineStyle", LineStyle.class,
-	                new EdgeLineStyleProp(), new LineStyleParser(), false, true), 
-
-	// New from 2.5: arrows have its own color, shape, and size.
-	EDGE_SRCARROW_SHAPE("Edge Source Arrow Shape", "edgeSourceArrowShapeCalculator",
-	                    "edge.sourceArrowShape", "defaultEdgeSourceArrowShape",
-	                    ArrowShape.class,
-	                    new EdgeSourceArrowShapeProp(), new ArrowShapeParser(), false, true), 
-	EDGE_TGTARROW_SHAPE("Edge Target Arrow Shape", "edgeTargetArrowShapeCalculator",
-	                    "edge.targetArrowShape", "defaultEdgeTargetArrowShape",
-	                    ArrowShape.class,
-	                    new EdgeTargetArrowShapeProp(), new ArrowShapeParser(), false, true), 
-	EDGE_SRCARROW_COLOR("Edge Source Arrow Color", "edgeSourceArrowColorCalculator",
-	                    "edge.sourceArrowColor", "defaultEdgeSourceArrowColor",
-	                    Color.class,
-	                    new EdgeSourceArrowColorProp(), new ColorParser(), false, true), 
-	EDGE_TGTARROW_COLOR("Edge Target Arrow Color", "edgeTargetArrowColorCalculator",
-	                    "edge.targetArrowColor", "defaultEdgeTargetArrowColor",
-	                    Color.class,
-	                    new EdgeTargetArrowColorProp(), new ColorParser(), false, true),
-	/*
-	 * New in 2.5: Opacity support
-	 */
-	NODE_OPACITY("Node Opacity", "nodeOpacityCalculator", "node.opacity", "defaultNodeOpacity",
-	             Number.class, new NodeOpacityProp(),
-				 new FloatParser(), true, true), 
-	EDGE_OPACITY("Edge Opacity", "edgeOpacityCalculator", "edge.opacity", "defaultEdgeOpacity",
-	    	     Number.class, new EdgeOpacityProp(),
-				 new FloatParser(), false, true), 
-	NODE_LABEL_OPACITY("Node Label Opacity", "nodeLabelOpacityCalculator", "node.LabelOpacity", "defaultNodeLabelOpacity",
-	    	             Number.class, new NodeLabelOpacityProp(),
-						 new FloatParser(), true, true), 
-	EDGE_LABEL_OPACITY("Edge Label Opacity", "edgeLabelOpacityCalculator", "edge.labelOpacity", "defaultEdgeLabelOpacity",
-	    	    	     Number.class, new EdgeLabelOpacityProp(),
-						 new FloatParser(), false, true), 
-    NODE_BORDER_OPACITY("Node Border Opacity", "nodeBorderOpacityCalculator", "node.borderOpacity", "defaultNodeBorderOpacity",
-	    	    	             Number.class, new NodeBorderOpacityProp(),
-								 new FloatParser(), true, true), 
-	EDGE_SRCARROW_OPACITY("Edge Source Arrow Opacity", "edgeSourceArrowOpacityCalculator", "edge.sourceArrowOpacity", "defaultEdgeSourceArrowOpacity", Number.class, new EdgeSourceArrowOpacityProp(),
-						 new FloatParser(), false, true), 
-	EDGE_TGTARROW_OPACITY("Edge Target Arrow Opacity", "edgeTargetArrowOpacityCalculator", "edge.targetArrowOpacity", "defaultEdgeTargetArrowOpacity", Number.class, new EdgeTargetArrowOpacityProp(),
-						 new FloatParser(), false, true), 
-	// Not yet implemented in version 2.5
-	EDGE_LABEL_POSITION("Edge Label Position", "edgeLabelPositionCalculator", "edge.labelPosition",
-	                    "defaultEdgeLabelPosition", null, new EdgeLabelPositionProp(),
-						new LabelPositionParser(), false, false),
-						
-	;
-	/*
-	 * String returned by toString() method.
-	 */
-	private final String calcName;
-
-	/*
-	 * Property label in prop file.
-	 */
-	private String propertyLabel;
-
-	/*
-	 * Attribute name for vizmap bypass function (right-click bypass)
-	 */
-	private String bypassAttrName;
-	private String defaultPropertyLabel;
-
-	// Data type for the actual visual property.
-	private Class dataType;
-	private VisualProperty vizProp;
-	private ValueParser valueParser;
-
-	// indicates whether or not property is for a node or edge
-	private boolean isNodeProp;
-
-	// Indicates whether or not we should be using this property for 
-	// normal operations. If this is false, that means the property
-	// either hasn't been implemented or has been deprecated.  This
-	// is primarily used to build lists of properties that we can
-	// display to users.
-	private boolean isAllowed;
-
-	/*
-	 * private constructor to put name into this enum.
-	 */
-	private VisualPropertyType(final String calcName, final String propertyLabel,
-	                           final String bypassAttrName, final String defaultPropertyLabel,
-	                           final Class dataType, final VisualProperty vizProp, 
-							   final ValueParser valueParser, final boolean isNodeProp,
-							   final boolean isAllowed) {
-		this.calcName = calcName;
-		this.propertyLabel = propertyLabel;
-		this.bypassAttrName = bypassAttrName;
-		this.defaultPropertyLabel = defaultPropertyLabel;
-		this.dataType = dataType;
-		this.vizProp = vizProp;
-		this.valueParser = valueParser;
-		this.isNodeProp = isNodeProp;
-		this.isAllowed = isAllowed;
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @return DOCUMENT ME!
-	 */
-	public String getName() {
-		return calcName;
-	}
-
-	/**
-	 * Returns string used as property label in VS prop file.
-	 *
-	 * @return
-	 */
-	public String getPropertyLabel() {
-		return propertyLabel;
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @return DOCUMENT ME!
-	 */
-	public String getBypassAttrName() {
-		return bypassAttrName;
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @return DOCUMENT ME!
-	 */
-	public String getDefaultPropertyLabel() {
-		return defaultPropertyLabel;
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @param baseKey
-	 *            DOCUMENT ME!
-	 *
-	 * @return DOCUMENT ME!
-	 */
-	public String getDefaultPropertyKey(final String baseKey) {
-		return baseKey + "." + defaultPropertyLabel;
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @return DOCUMENT ME!
-	 */
-	public Class getDataType() {
-		return dataType;
-	}
-
-	/**
-	 * Check this visual property is for node or not.
-	 *
-	 * @return true if vp is for node.
-	 */
-	public boolean isNodeProp() {
-		return isNodeProp;
-	}
-
-	/** 
-	 * Indicates whether or not we should be using this property for 
-	 * normal operations. If this is false, that means the property
-	 * either hasn't been implemented or has been deprecated.  This
-	 * is primarily used to build lists of properties that we can
-	 * display to users.
-	 */
-	public boolean isAllowed() {
-		return isAllowed;
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @return  DOCUMENT ME!
-	 */
-	public static List<VisualPropertyType> getNodeVisualPropertyList() {
-		List<VisualPropertyType> list = new ArrayList<VisualPropertyType>();
-
-		for (VisualPropertyType type : values()) {
-			if ( type.isNodeProp() && type.isAllowed() ) {
-				list.add(type);
-			}
-		}
-
-		return list;
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @return  DOCUMENT ME!
-	 */
-	public static List<VisualPropertyType> getEdgeVisualPropertyList() {
-		List<VisualPropertyType> list = new ArrayList<VisualPropertyType>();
-
-		for (VisualPropertyType type : values()) {
-			if ( !type.isNodeProp() && type.isAllowed() ) {
-				list.add(type);
-			}
-		}
-
-		return list;
-	}
-
-	/**
-	 * Returns the VisualProperty object associated with this enum.
-	 */
-	public VisualProperty getVisualProperty() {
-		return vizProp;
-	}
-
-	/**
-	 * Gets the current default value for this type in the specified
-	     * visual style. Returns null if the style is null.
-	     * @param style The visual style we want to get the default for.
-	     * @return the default object for this type and the specified style.
-	 */
-	public Object getDefault(VisualStyle style) {
-		if (style == null)
-			return null;
-
-		Appearance a = null;
-
-		if (isNodeProp())
-			a = style.getNodeAppearanceCalculator().getDefaultAppearance();
-		else
-			a = style.getEdgeAppearanceCalculator().getDefaultAppearance();
-
-		return a.get(this);
-	}
-
-	/**
-	 * Sets the default value for the visual attribute for this type
-	 * in the specified visual style. No-op if either arg is null.
-	     * @param style The visual style to be set.
-	     * @param c The new default value.
-	 */
-	public void setDefault(VisualStyle style, Object c) {
-		if ((style == null) || (c == null))
-			return;
-
-		if (isNodeProp()) {
-			NodeAppearanceCalculator nodeCalc = style.getNodeAppearanceCalculator();
-			NodeAppearance na = nodeCalc.getDefaultAppearance();
-			na.set(this, c);
-			nodeCalc.setDefaultAppearance(na);
-		} else {
-			EdgeAppearanceCalculator edgeCalc = style.getEdgeAppearanceCalculator();
-			EdgeAppearance ea = edgeCalc.getDefaultAppearance();
-			ea.set(this, c);
-			edgeCalc.setDefaultAppearance(ea);
-		}
-	}
-
-	/**
-	 * Gets the current calculator for the visual attribute for this type
-	     * and the specified visual style.  This may be null if no calculator
-	     * is currently specified. Returns null if the style is null.
-	     * @param style The style we're getting the calculator for.
-	     * @return the current calculator for this style and type
-	 */
-	public Calculator getCurrentCalculator(VisualStyle style) {
-		if (style == null)
-			return null;
-
-		if (isNodeProp())
-			return style.getNodeAppearanceCalculator().getCalculator(this);
-		else
-
-			return style.getEdgeAppearanceCalculator().getCalculator(this);
-	}
-
-	/**
-	 * Sets the current calculator for the visual attribute for this type
-	 * and the specified visual style. If the new calculator is null, then
-	     * the calculator for this type will be removed. This method does
-	 * nothing if the first argument specifying the visual style is null.
-	     * @param style The style to set the calculator for.
-	     * @param c The calculator to set.
-	 */
-	public void setCurrentCalculator(VisualStyle style, Calculator c) {
-		if (style == null)
-			return;
-
-		if (isNodeProp()) {
-			if (c == null)
-				style.getNodeAppearanceCalculator().removeCalculator(this);
-			else
-				style.getNodeAppearanceCalculator().setCalculator(c);
-		} else {
-			if (c == null)
-				style.getEdgeAppearanceCalculator().removeCalculator(this);
-			else
-				style.getEdgeAppearanceCalculator().setCalculator(c);
-		}
-	}
-
-	public ValueParser getValueParser() {
-		return valueParser;
-	}
-}
Index: vizmap/src/main/java/org/cytoscape/vizmap/ArrowShape.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/ArrowShape.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/ArrowShape.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -1,214 +0,0 @@
-/*
- Copyright (c) 2006, 2007, The Cytoscape Consortium (www.cytoscape.org)
-
- The Cytoscape Consortium is:
- - Institute for Systems Biology
- - University of California San Diego
- - Memorial Sloan-Kettering Cancer Center
- - Institut Pasteur
- - Agilent Technologies
-
- This library is free software; you can redistribute it and/or modify it
- under the terms of the GNU Lesser General Public License as published
- by the Free Software Foundation; either version 2.1 of the License, or
- any later version.
-
- This library is distributed in the hope that it will be useful, but
- WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF
- MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  The software and
- documentation provided hereunder is on an "as is" basis, and the
- Institute for Systems Biology and the Whitehead Institute
- have no obligations to provide maintenance, support,
- updates, enhancements or modifications.  In no event shall the
- Institute for Systems Biology and the Whitehead Institute
- be liable to any party for direct, indirect, special,
- incidental or consequential damages, including lost profits, arising
- out of the use of this software and its documentation, even if the
- Institute for Systems Biology and the Whitehead Institute
- have been advised of the possibility of such damage.  See
- the GNU Lesser General Public License for more details.
-
- You should have received a copy of the GNU Lesser General Public License
- along with this library; if not, write to the Free Software Foundation,
- Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
-*/
-package org.cytoscape.vizmap;
-
-import org.cytoscape.view.EdgeView;
-import org.cytoscape.view.ShapeFactory;
-import javax.swing.Icon;
-import java.util.Map;
-import java.util.HashMap;
-import java.awt.Shape;
-import org.cytoscape.vizmap.icon.*; 
-
-/**
- * Defines arrow shapes.<br>
- * This replaces constants defined in Arrow.java.
- *
- * @since Cytoscape 2.5
- * @author kono
- *
- */
-public enum ArrowShape {
-	NONE("No Arrow", "NONE", EdgeView.NO_END, 
-	     new int[]{EdgeView.NO_END},
-		 new String[]{"NO_END"}),
-	DIAMOND("Diamond", "COLOR_DIAMOND", EdgeView.EDGE_COLOR_DIAMOND,
-	     new int[]{EdgeView.EDGE_COLOR_DIAMOND, EdgeView.WHITE_DIAMOND,EdgeView.BLACK_DIAMOND},
-	     new String[]{"EDGE_COLOR_DIAMOND", "WHITE_DIAMOND","BLACK_DIAMOND"}),
-	DELTA("Delta", "COLOR_DELTA", EdgeView.EDGE_COLOR_DELTA,
-	     new int[]{EdgeView.EDGE_COLOR_DELTA, EdgeView.WHITE_DELTA,EdgeView.BLACK_DELTA},
-	     new String[]{"EDGE_COLOR_DELTA", "WHITE_DELTA","BLACK_DELTA"}),
-	ARROW("Arrow", "COLOR_ARROW", EdgeView.EDGE_COLOR_DELTA,
-	     new int[]{EdgeView.EDGE_COLOR_ARROW, EdgeView.WHITE_ARROW,EdgeView.BLACK_ARROW},
-	     new String[]{"EDGE_COLOR_ARROW", "WHITE_ARROW","BLACK_ARROW"}),
-	T("T", "COLOR_T", EdgeView.EDGE_COLOR_T,
-	     new int[]{EdgeView.EDGE_COLOR_T, EdgeView.WHITE_T,EdgeView.BLACK_T},
-	     new String[]{"EDGE_COLOR_T", "WHITE_T","BLACK_T"}),
-	CIRCLE("Circle", "COLOR_CIRCLE", EdgeView.EDGE_COLOR_CIRCLE,
-	     new int[]{EdgeView.EDGE_COLOR_CIRCLE, EdgeView.WHITE_CIRCLE,EdgeView.BLACK_CIRCLE},
-	     new String[]{"EDGE_COLOR_CIRCLE", "WHITE_CIRCLE","BLACK_CIRCLE"}),
-
-	// Not yet implemented
-	//	REVERSE_ARROW("Reverse Arrow", "REVERSE_ARROW", -1,
-	//	     new int[]{-1},
-	//		 new String[]{""}),
-	;
-
-
-	private static Map<Integer,Shape> arrowShapes = ShapeFactory.getArrowShapes();
-
-	private String shapeName;
-	private String ginyShapeName;
-	private int ginyType;
-	private int[] possibleGinyTypes;
-	private String[] possibleGinyNames;
-
-	private ArrowShape(String shapeName, String ginyShapeName, int ginyType, int[] possibleGinyTypes,
-	                   String[] possibleGinyNames) {
-		this.shapeName = shapeName;
-		this.ginyShapeName = ginyShapeName;
-		this.ginyType = ginyType;
-		this.possibleGinyTypes = possibleGinyTypes;
-		this.possibleGinyNames = possibleGinyNames;
-	}
-
-	/**
-	 * Returns arrow type in GINY.
-	 *
-	 * @return
-	 */
-	public int getGinyArrow() {
-		return ginyType;
-	}
-
-	/**
-	 * Returns name of arrow shape.
-	 *
-	 * @return
-	 */
-	public String getGinyName() {
-		return ginyShapeName;
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @return DOCUMENT ME!
-	 */
-	public String getName() {
-		return shapeName;
-	}
-
-	/**
-	 *
-	 * @param text
-	 * @return
-	 */
-	public static ArrowShape parseArrowText(String text) {
-		try {
-			ArrowShape val = valueOf(text);
-			return val;
-		// brilliant flow control
-		// this isn't a problem, we just don't match
-		} catch (IllegalArgumentException e) { }
-		
-		// if string doesn't match, then try other possible GINY names 
-		for (ArrowShape shape : values())  {
-			if (shape.shapeName.equals(text) || shape.ginyShapeName.equals(text))
-				return shape;
-			for (String possibleName : shape.getPossibleGinyNames()) {
-				if ( possibleName.equals(text) ) 
-					return shape;
-			}
-		}
-
-		return NONE;
-	}
-
-	public String[] getPossibleGinyNames() {
-		return possibleGinyNames;
-	}
-
-	public int[] getPossibleGinyTypes() {
-		return possibleGinyTypes;
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @param ginyType
-	 *            DOCUMENT ME!
-	 *
-	 * @return DOCUMENT ME!
-	 */
-	public static ArrowShape getArrowShape(int ginyType) {
-		// first try for an exact match
-		for (ArrowShape shape : values()) {
-			if (shape.getGinyArrow() == ginyType)
-				return shape;
-		}
-
-		// if no exact match is found, then try the possible ginyTypes 
-		for (ArrowShape shape : values()) {
-			for ( int possible : shape.getPossibleGinyTypes() ) {
-				if ( possible == ginyType ) 
-					return shape;
-			}
-		}
-
-		// if we can't match anything, just return NONE.
-		return NONE;
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @return  DOCUMENT ME!
-	 */
-	public Shape getShape() {
-		return arrowShapes.get(ginyType);
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @param size DOCUMENT ME!
-	 *
-	 * @return  DOCUMENT ME!
-	 */
-	public static Map<Object, Icon> getIconSet() {
-		Map<Object, Icon> arrowShapeIcons = new HashMap<Object, Icon>();
-
-		for (ArrowShape shape : values()) {
-			ArrowIcon icon = new ArrowIcon(arrowShapes.get(shape.getGinyArrow()), 
-			                               VisualPropertyIcon.DEFAULT_ICON_SIZE, 
-			                               VisualPropertyIcon.DEFAULT_ICON_SIZE, 
-										   shape.getName());
-			arrowShapeIcons.put(shape, icon);
-		}
-
-		return arrowShapeIcons;
-	}
-}
Index: vizmap/src/main/java/org/cytoscape/vizmap/NodeAppearanceCalculator.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/NodeAppearanceCalculator.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/NodeAppearanceCalculator.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -1,208 +0,0 @@
-/*
- File: NodeAppearanceCalculator.java
-
- Copyright (c) 2006, The Cytoscape Consortium (www.cytoscape.org)
-
- The Cytoscape Consortium is:
- - Institute for Systems Biology
- - University of California San Diego
- - Memorial Sloan-Kettering Cancer Center
- - Institut Pasteur
- - Agilent Technologies
-
- This library is free software; you can redistribute it and/or modify it
- under the terms of the GNU Lesser General Public License as published
- by the Free Software Foundation; either version 2.1 of the License, or
- any later version.
-
- This library is distributed in the hope that it will be useful, but
- WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF
- MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  The software and
- documentation provided hereunder is on an "as is" basis, and the
- Institute for Systems Biology and the Whitehead Institute
- have no obligations to provide maintenance, support,
- updates, enhancements or modifications.  In no event shall the
- Institute for Systems Biology and the Whitehead Institute
- be liable to any party for direct, indirect, special,
- incidental or consequential damages, including lost profits, arising
- out of the use of this software and its documentation, even if the
- Institute for Systems Biology and the Whitehead Institute
- have been advised of the possibility of such damage.  See
- the GNU Lesser General Public License for more details.
-
- You should have received a copy of the GNU Lesser General Public License
- along with this library; if not, write to the Free Software Foundation,
- Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- */
-package org.cytoscape.vizmap;
-
-import org.cytoscape.GraphPerspective;
-
-import org.cytoscape.vizmap.calculators.*;
-import org.cytoscape.vizmap.mappings.ObjectMapping;
-
-import org.cytoscape.Node;
-
-import java.awt.Color;
-import java.awt.Font;
-
-import java.util.Properties;
-
-
-/**
- * This class calculates the appearance of a Node. It holds a default value and
- * a (possibly null) calculator for each visual attribute.
- */
-public class NodeAppearanceCalculator extends AppearanceCalculator {
-    private NodeAppearance defaultAppearance = new NodeAppearance();
-
-    /**
-     * Creates a new NodeAppearanceCalculator object.
-     */
-    public NodeAppearanceCalculator() {
-        super();
-    }
-
-    /**
-     * Creates a new NodeAppearanceCalculator and immediately customizes it by
-     * calling applyProperties with the supplied arguments.
-     */
-    public NodeAppearanceCalculator(String name, Properties nacProps,
-        String baseKey, CalculatorCatalog catalog) {
-        super(name, nacProps, baseKey, catalog, new NodeAppearance());
-        defaultAppearance = (NodeAppearance) tmpDefaultAppearance;
-    }
-
-    /**
-     * Copy constructor. Returns a default object if the argument is null.
-     */
-    public NodeAppearanceCalculator(NodeAppearanceCalculator toCopy) {
-        super(toCopy);
-    }
-
-    /**
-     * Using the rules defined by the default values and calculators in this
-     * object, compute an appearance for the requested Node in the supplied
-     * CyNetwork. A new NodeApperance object will be created.
-     */
-    public NodeAppearance calculateNodeAppearance(Node node, GraphPerspective network) {
-        NodeAppearance appr = new NodeAppearance();
-        calculateNodeAppearance(appr, node, network);
-
-        return appr;
-    }
-    
-    /**
-     * Create deep copy of the object.
-     */
-    public Object clone() {
-    	final NodeAppearanceCalculator copy = new NodeAppearanceCalculator();
-    	
-    	// Copy defaults
-    	final NodeAppearance defAppr = new NodeAppearance();
-    	for(VisualPropertyType type : VisualPropertyType.getNodeVisualPropertyList()) {
-    		defAppr.set(type, defaultAppearance.get(type));
-    	}
-    	defAppr.setNodeSizeLocked(defaultAppearance.getNodeSizeLocked());
-    	copy.setDefaultAppearance(defAppr);
-    	
-    	//Copy mappings
-    	for(Calculator cal  : this.calcs) {
-    		ObjectMapping mCopy = (ObjectMapping) cal.getMapping(0).clone();
-    		BasicCalculator bCalc = new BasicCalculator(cal.toString(), mCopy, cal.getVisualPropertyType());
-    		copy.setCalculator(bCalc);
-    	}
-    	
-    	return copy;
-    }
-
-    /**
-     * Using the rules defined by the default values and calculators in this
-     * object, compute an appearance for the requested Node in the supplied
-     * CyNetwork. The supplied NodeAppearance object will be changed to hold the
-     * new values.
-     */
-    public void calculateNodeAppearance(NodeAppearance appr, Node node, GraphPerspective network) {
-        appr.copy(defaultAppearance); // set defaults and node lock state
-
-        for (Calculator nc : calcs)
-            nc.apply(appr, node, network);
-
-        appr.applyBypass(node);
-    }
-
-    /**
-     * DOCUMENT ME!
-     *
-     * @return DOCUMENT ME!
-     */
-    public NodeAppearance getDefaultAppearance() {
-        return defaultAppearance;
-    }
-
-    /**
-     * DOCUMENT ME!
-     *
-     * @param n DOCUMENT ME!
-     */
-    public void setDefaultAppearance(NodeAppearance n) {
-        defaultAppearance = n;
-    }
-
-    /**
-     * Returns a text description of the current default values and calculator
-     * names.
-     */
-    public String getDescription() {
-        return getDescription("NodeAppearanceCalculator", defaultAppearance);
-    }
-
-    /**
-     * DOCUMENT ME!
-     *
-     * @param name DOCUMENT ME!
-     * @param nacProps DOCUMENT ME!
-     * @param baseKey DOCUMENT ME!
-     * @param catalog DOCUMENT ME!
-     */
-    public void applyProperties(String name, Properties nacProps,
-        String baseKey, CalculatorCatalog catalog) {
-        applyProperties(defaultAppearance, name, nacProps, baseKey, catalog);
-    }
-
-    /**
-     * DOCUMENT ME!
-     *
-     * @param baseKey DOCUMENT ME!
-     *
-     * @return DOCUMENT ME!
-     */
-    public Properties getProperties(String baseKey) {
-        return getProperties(defaultAppearance, baseKey);
-    }
-
-    protected void copyDefaultAppearance(AppearanceCalculator toCopy) {
-        defaultAppearance = (NodeAppearance) (((NodeAppearanceCalculator) toCopy).getDefaultAppearance().clone());
-    }
-
-    // probably shouldn't be here now
-    /**
-     * DOCUMENT ME!
-     *
-     * @return DOCUMENT ME!
-     */
-    public boolean getNodeSizeLocked() {
-        return defaultAppearance.getNodeSizeLocked();
-    }
-
-    // probably shouldn't be here now
-    /**
-     * DOCUMENT ME!
-     *
-     * @param b DOCUMENT ME!
-     */
-    public void setNodeSizeLocked(boolean b) {
-        defaultAppearance.setNodeSizeLocked(b);
-    }
-
-}
Index: vizmap/src/main/java/org/cytoscape/vizmap/GlobalAppearance.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/GlobalAppearance.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/GlobalAppearance.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -1,192 +0,0 @@
-/*
- File: GlobalAppearance.java
-
- Copyright (c) 2006, The Cytoscape Consortium (www.cytoscape.org)
-
- The Cytoscape Consortium is:
- - Institute for Systems Biology
- - University of California San Diego
- - Memorial Sloan-Kettering Cancer Center
- - Institut Pasteur
- - Agilent Technologies
-
- This library is free software; you can redistribute it and/or modify it
- under the terms of the GNU Lesser General Public License as published
- by the Free Software Foundation; either version 2.1 of the License, or
- any later version.
-
- This library is distributed in the hope that it will be useful, but
- WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF
- MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  The software and
- documentation provided hereunder is on an "as is" basis, and the
- Institute for Systems Biology and the Whitehead Institute
- have no obligations to provide maintenance, support,
- updates, enhancements or modifications.  In no event shall the
- Institute for Systems Biology and the Whitehead Institute
- be liable to any party for direct, indirect, special,
- incidental or consequential damages, including lost profits, arising
- out of the use of this software and its documentation, even if the
- Institute for Systems Biology and the Whitehead Institute
- have been advised of the possibility of such damage.  See
- the GNU Lesser General Public License for more details.
-
- You should have received a copy of the GNU Lesser General Public License
- along with this library; if not, write to the Free Software Foundation,
- Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- */
-
-//----------------------------------------------------------------------------
-// $Revision: 12924 $
-// $Date: 2008-02-04 11:10:30 -0800 (Mon, 04 Feb 2008) $
-// $Author: mes $
-//----------------------------------------------------------------------------
-package org.cytoscape.vizmap;
-
-import java.awt.Color;
-
-
-/**
- * Objects of this class hold data describing global appearance attributes of
- * the graph window.
- */
-public class GlobalAppearance {
-	
-	private enum GlobalAppearenceName {
-		BACKGROUND_COLOR("Background Color"),
-		NODE_SELECTION_COLOR("Node Selection Color"),
-		NODE_REVERSE_SELECTION_COLOR("Node Reverse Selection Color"),
-		EDGE_SELECTION_COLOR("Edge Selection Color"),
-		EDGE_REVERSE_SELECTION_COLOR("Edge Reverse Selection Color");
-
-		private String name;
-		private static String[] names;
-
-		static {
-			names = new String[GlobalAppearenceName.values().length];
-			int i = 0;
-			for(GlobalAppearenceName ganame: GlobalAppearenceName.values()) {
-				names[i] = ganame.getName();
-				i++;
-			}
-		}
-		
-		private GlobalAppearenceName(String name) {
-			this.name = name;
-		}
-
-		public String getName() {
-			return name;
-		}
-		
-		public static String[] getAllNames() {
-			return names;
-		}
-	}
-
-	private Color backgroundColor;
-	private Color nodeSelectionColor;
-	private Color nodeReverseSelectionColor;
-	private Color edgeSelectionColor;
-	private Color edgeReverseSelectionColor;
-
-	/**
-	 * Creates a new GlobalAppearance object.
-	 */
-	public GlobalAppearance() {
-	}
-	
-	protected static String[] getCalculatorNames() {
-		return GlobalAppearenceName.getAllNames();
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @return  DOCUMENT ME!
-	 */
-	public Color getBackgroundColor() {
-		return backgroundColor;
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @param c DOCUMENT ME!
-	 */
-	public void setBackgroundColor(Color c) {
-		backgroundColor = c;
-	}
-
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @return  DOCUMENT ME!
-	 */
-	public Color getNodeSelectionColor() {
-		return nodeSelectionColor;
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @param c DOCUMENT ME!
-	 */
-	public void setNodeSelectionColor(Color c) {
-		nodeSelectionColor = c;
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @return  DOCUMENT ME!
-	 */
-	public Color getNodeReverseSelectionColor() {
-		return nodeReverseSelectionColor;
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @param c DOCUMENT ME!
-	 */
-	public void setNodeReverseSelectionColor(Color c) {
-		nodeReverseSelectionColor = c;
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @return  DOCUMENT ME!
-	 */
-	public Color getEdgeSelectionColor() {
-		return edgeSelectionColor;
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @param c DOCUMENT ME!
-	 */
-	public void setEdgeSelectionColor(Color c) {
-		edgeSelectionColor = c;
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @return  DOCUMENT ME!
-	 */
-	public Color getEdgeReverseSelectionColor() {
-		return edgeReverseSelectionColor;
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @param c DOCUMENT ME!
-	 */
-	public void setEdgeReverseSelectionColor(Color c) {
-		edgeReverseSelectionColor = c;
-	}
-}
Index: vizmap/src/main/java/org/cytoscape/vizmap/EdgeAppearance.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/EdgeAppearance.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/EdgeAppearance.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -1,79 +0,0 @@
-/*
- File: EdgeAppearance.java
-
- Copyright (c) 2006, The Cytoscape Consortium (www.cytoscape.org)
-
- The Cytoscape Consortium is:
- - Institute for Systems Biology
- - University of California San Diego
- - Memorial Sloan-Kettering Cancer Center
- - Institut Pasteur
- - Agilent Technologies
-
- This library is free software; you can redistribute it and/or modify it
- under the terms of the GNU Lesser General Public License as published
- by the Free Software Foundation; either version 2.1 of the License, or
- any later version.
-
- This library is distributed in the hope that it will be useful, but
- WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF
- MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  The software and
- documentation provided hereunder is on an "as is" basis, and the
- Institute for Systems Biology and the Whitehead Institute
- have no obligations to provide maintenance, support,
- updates, enhancements or modifications.  In no event shall the
- Institute for Systems Biology and the Whitehead Institute
- be liable to any party for direct, indirect, special,
- incidental or consequential damages, including lost profits, arising
- out of the use of this software and its documentation, even if the
- Institute for Systems Biology and the Whitehead Institute
- have been advised of the possibility of such damage.  See
- the GNU Lesser General Public License for more details.
-
- You should have received a copy of the GNU Lesser General Public License
- along with this library; if not, write to the Free Software Foundation,
- Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- */
-
-package org.cytoscape.vizmap;
-
-import org.cytoscape.vizmap.parsers.ColorParser;
-import org.cytoscape.vizmap.parsers.FloatParser;
-import org.cytoscape.vizmap.parsers.FontParser;
-import org.cytoscape.vizmap.ObjectToString;
-
-import org.cytoscape.Edge;
-import org.cytoscape.attributes.CyAttributesFactory;
-
-import org.cytoscape.view.EdgeView;
-import org.cytoscape.view.Label;
-
-import java.awt.Color;
-import java.awt.Font;
-import java.awt.Paint;
-import java.awt.Stroke;
-
-import java.util.Properties;
-
-
-/**
- * Objects of this class hold data describing the appearance of an Edge.
- */
-public class EdgeAppearance extends Appearance {
-
-	/**
-	 * Creates a new EdgeAppearance object.
-	 */
-	public EdgeAppearance() {
-		super(CyAttributesFactory.getCyAttributes("edge"));
-	}
-
-	/**
-	 * Clone.
-	 */
-    public Object clone() {
-        EdgeAppearance ga = new EdgeAppearance();
-        ga.copy(this);
-        return ga;
-	}
-}
Index: vizmap/src/main/java/org/cytoscape/vizmap/GlobalAppearanceCalculator.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/GlobalAppearanceCalculator.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/GlobalAppearanceCalculator.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -1,465 +0,0 @@
-/*
- File: GlobalAppearanceCalculator.java
-
- Copyright (c) 2006, The Cytoscape Consortium (www.cytoscape.org)
-
- The Cytoscape Consortium is:
- - Institute for Systems Biology
- - University of California San Diego
- - Memorial Sloan-Kettering Cancer Center
- - Institut Pasteur
- - Agilent Technologies
-
- This library is free software; you can redistribute it and/or modify it
- under the terms of the GNU Lesser General Public License as published
- by the Free Software Foundation; either version 2.1 of the License, or
- any later version.
-
- This library is distributed in the hope that it will be useful, but
- WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF
- MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  The software and
- documentation provided hereunder is on an "as is" basis, and the
- Institute for Systems Biology and the Whitehead Institute
- have no obligations to provide maintenance, support,
- updates, enhancements or modifications.  In no event shall the
- Institute for Systems Biology and the Whitehead Institute
- be liable to any party for direct, indirect, special,
- incidental or consequential damages, including lost profits, arising
- out of the use of this software and its documentation, even if the
- Institute for Systems Biology and the Whitehead Institute
- have been advised of the possibility of such damage.  See
- the GNU Lesser General Public License for more details.
-
- You should have received a copy of the GNU Lesser General Public License
- along with this library; if not, write to the Free Software Foundation,
- Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- */
-
-//----------------------------------------------------------------------------
-// $Revision: 13022 $
-// $Date: 2008-02-11 13:59:26 -0800 (Mon, 11 Feb 2008) $
-// $Author: mes $
-//----------------------------------------------------------------------------
-package org.cytoscape.vizmap;
-
-import org.cytoscape.GraphPerspective;
-
-import org.cytoscape.vizmap.parsers.ColorParser;
-import org.cytoscape.vizmap.ObjectToString;
-
-//----------------------------------------------------------------------------
-import java.awt.Color;
-
-import java.lang.reflect.Method;
-
-import java.util.Properties;
-
-
-//----------------------------------------------------------------------------
-/**
- * This class calculates global visual attributes such as the background color
- * of the graph window. Currently dynamic calculators for these values are not
- * supported, only default values.
- */
-public class GlobalAppearanceCalculator extends SubjectBase implements Cloneable {
-	/*
-	 * Set default colors
-	 */
-	private Color defaultBackgroundColor = Color.WHITE;
-	private Color defaultNodeSelectionColor = Color.YELLOW;
-	private Color defaultNodeReverseSelectionColor = Color.GREEN;
-	private Color defaultEdgeSelectionColor = Color.RED;
-	private Color defaultEdgeReverseSelectionColor = Color.GREEN;
-
-//	/**
-//	 * Make shallow copy of this object
-//	 */
-//	public Object clone() throws CloneNotSupportedException {
-//		Object copy = null;
-//		copy = super.clone();
-//
-//		return copy;
-//	}
-//	
-	/**
-	 * Make deep copy of this object
-	 */
-	public Object clone() throws CloneNotSupportedException {
-		final GlobalAppearanceCalculator copy = new GlobalAppearanceCalculator();
-		copy.setDefaultBackgroundColor(this.defaultBackgroundColor);
-		copy.setDefaultNodeSelectionColor(this.defaultNodeSelectionColor);
-		copy.setDefaultEdgeSelectionColor(this.defaultEdgeSelectionColor);
-		copy.setDefaultNodeReverseSelectionColor(this.defaultNodeReverseSelectionColor);
-		copy.setDefaultEdgeReverseSelectionColor(this.defaultEdgeReverseSelectionColor);
-		return copy;
-	}
-
-	/**
-	 * Creates a new GlobalAppearanceCalculator object.
-	 */
-	public GlobalAppearanceCalculator() {
-	}
-
-	/**
-	 *  Get default color for the given parameter name.
-	 * Should be used names in GlobalAppearenceNames enum.
-	 *
-	 * @param name DOCUMENT ME!
-	 *
-	 * @return  DOCUMENT ME!
-	 *
-	 * @throws Exception DOCUMENT ME!
-	 */
-	public Color getDefaultColor(final String name) throws Exception {
-		final Class cls = this.getClass();
-		final String newName = name.replace(" ", "");
-		final Method method = cls.getMethod("getDefault" + newName, new Class[] {});
-		final Object obj = method.invoke(this, new Object[] {});
-
-		if ((obj != null) && obj instanceof Color) {
-			return (Color) obj;
-		} else
-
-			return null;
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @param name DOCUMENT ME!
-	 * @param newColor DOCUMENT ME!
-	 *
-	 * @throws Exception DOCUMENT ME!
-	 */
-	public void setDefaultColor(final String name, final Color newColor) throws Exception {
-		final Class cls = this.getClass();
-		final String newName = name.replace(" ", "");
-		final Method method = cls.getMethod("setDefault" + newName, new Class[] { Color.class });
-		method.invoke(this, new Object[] { newColor });
-	}
-
-	/**
-	 *  Get name of global appearances.
-	 *
-	 * @return  DOCUMENT ME!
-	 */
-	public static String[] getGlobalAppearanceNames() {
-		return GlobalAppearance.getCalculatorNames();
-	}
-
-	/**
-	 * Copy constructor. Returns a default object if the argument is null.
-	 */
-	public GlobalAppearanceCalculator(GlobalAppearanceCalculator toCopy) {
-		if (toCopy == null) {
-			return;
-		}
-
-		setDefaultBackgroundColor(toCopy.getDefaultBackgroundColor());
-		setDefaultNodeSelectionColor(toCopy.getDefaultNodeSelectionColor());
-		setDefaultNodeReverseSelectionColor(toCopy.getDefaultNodeReverseSelectionColor());
-		setDefaultEdgeSelectionColor(toCopy.getDefaultEdgeSelectionColor());
-		setDefaultEdgeReverseSelectionColor(toCopy.getDefaultEdgeReverseSelectionColor());
-	}
-
-	/**
-	 * Creates a new GlobalAppearanceCalculator and immediately customizes it by
-	 * calling applyProperties with the supplied arguments.
-	 */
-	public GlobalAppearanceCalculator(String name, Properties gProps, String baseKey,
-	                                  CalculatorCatalog catalog) {
-		applyProperties(name, gProps, baseKey, catalog);
-	}
-
-	/**
-	 * Constructs a new GlobalAppearance object containing the values for the
-	 * known global visual attributes.
-	 */
-	public GlobalAppearance calculateGlobalAppearance(GraphPerspective network) {
-		GlobalAppearance appr = new GlobalAppearance();
-		calculateGlobalAppearance(appr, network);
-
-		return appr;
-	}
-
-	/**
-	 * The supplied GlobalAppearance object will be changed to hold new values
-	 * for the known global visual attributes.
-	 */
-	public void calculateGlobalAppearance(GlobalAppearance appr, GraphPerspective network) {
-		appr.setBackgroundColor(calculateBackgroundColor(network));
-		appr.setNodeSelectionColor(calculateNodeSelectionColor(network));
-		appr.setNodeReverseSelectionColor(calculateNodeReverseSelectionColor(network));
-		appr.setEdgeSelectionColor(calculateEdgeSelectionColor(network));
-		appr.setEdgeReverseSelectionColor(calculateEdgeReverseSelectionColor(network));
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @return  DOCUMENT ME!
-	 */
-	public Color getDefaultBackgroundColor() {
-		return defaultBackgroundColor;
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @param c DOCUMENT ME!
-	 */
-	public void setDefaultBackgroundColor(Color c) {
-		if (c != null) {
-			defaultBackgroundColor = c;
-			this.fireStateChanged();
-		}
-	}
-
-	/**
-	 * Currently no calculators are supported for global visual attributes, so
-	 * this method simply returns the default background color.
-	 */
-	public Color calculateBackgroundColor(GraphPerspective network) {
-		return defaultBackgroundColor;
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @return  DOCUMENT ME!
-	 */
-	public Color getDefaultNodeSelectionColor() {
-		return defaultNodeSelectionColor;
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @param c DOCUMENT ME!
-	 */
-	public void setDefaultNodeSelectionColor(Color c) {
-		if (c != null) {
-			defaultNodeSelectionColor = c;
-			this.fireStateChanged();
-		}
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @return  DOCUMENT ME!
-	 */
-	public Color getDefaultNodeReverseSelectionColor() {
-		return defaultNodeReverseSelectionColor;
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @param c DOCUMENT ME!
-	 */
-	public void setDefaultNodeReverseSelectionColor(Color c) {
-		if (c != null) {
-			defaultNodeReverseSelectionColor = c;
-			this.fireStateChanged();
-		}
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @return  DOCUMENT ME!
-	 */
-	public Color getDefaultEdgeSelectionColor() {
-		return defaultEdgeSelectionColor;
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @param c DOCUMENT ME!
-	 */
-	public void setDefaultEdgeSelectionColor(Color c) {
-		if (c != null) {
-			defaultEdgeSelectionColor = c;
-			this.fireStateChanged();
-		}
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @return  DOCUMENT ME!
-	 */
-	public Color getDefaultEdgeReverseSelectionColor() {
-		return defaultEdgeReverseSelectionColor;
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @param c DOCUMENT ME!
-	 */
-	public void setDefaultEdgeReverseSelectionColor(Color c) {
-		if (c != null) {
-			defaultEdgeReverseSelectionColor = c;
-			this.fireStateChanged();
-		}
-	}
-
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @param network DOCUMENT ME!
-	 *
-	 * @return  DOCUMENT ME!
-	 */
-	public Color calculateNodeSelectionColor(GraphPerspective network) {
-		return defaultNodeSelectionColor;
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @param network DOCUMENT ME!
-	 *
-	 * @return  DOCUMENT ME!
-	 */
-	public Color calculateNodeReverseSelectionColor(GraphPerspective network) {
-		return defaultNodeReverseSelectionColor;
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @param network DOCUMENT ME!
-	 *
-	 * @return  DOCUMENT ME!
-	 */
-	public Color calculateEdgeSelectionColor(GraphPerspective network) {
-		return defaultEdgeSelectionColor;
-	}
-
-	/**
-	 *  DOCUMENT ME!
-	 *
-	 * @param network DOCUMENT ME!
-	 *
-	 * @return  DOCUMENT ME!
-	 */
-	public Color calculateEdgeReverseSelectionColor(GraphPerspective network) {
-		return defaultEdgeReverseSelectionColor;
-	}
-
-	/**
-	 * Returns a text description of this object's current state.
-	 */
-	public String getDescription() {
-		String lineSep = System.getProperty("line.separator");
-		StringBuffer sb = new StringBuffer();
-		sb.append("GlobalAppearanceCalculator:" + lineSep);
-		sb.append("defaultBackgroundColor = ");
-		sb.append(defaultBackgroundColor).append(lineSep);
-
-		return sb.toString();
-	}
-
-	/**
-	 * This method customizes this object by searching the supplied properties
-	 * object for keys identifying default values and calculators. Recognized
-	 * keys are of the form "globalAppearanceCalculator." + name + ident, where
-	 * name is a supplied argument and ident is a String indicating a default
-	 * value for a specific visual attribute. Since calculators are not
-	 * supported for global visual attributes, the catalog argument is currently
-	 * ignored.
-	 */
-	public void applyProperties(String name, Properties nacProps, String baseKey,
-	                            CalculatorCatalog catalog) {
-		String value = null;
-
-		// look for default values
-		value = nacProps.getProperty(baseKey + ".defaultBackgroundColor");
-
-		if (value != null) {
-			Color c = (new ColorParser()).parseColor(value);
-
-			if (c != null) {
-				setDefaultBackgroundColor(c);
-			}
-		}
-
-		value = nacProps.getProperty(baseKey + ".defaultNodeSelectionColor");
-
-		if (value != null) {
-			Color c = (new ColorParser()).parseColor(value);
-
-			if (c != null) {
-				setDefaultNodeSelectionColor(c);
-			}
-		}
-
-		value = nacProps.getProperty(baseKey + ".defaultNodeReverseSelectionColor");
-
-		if (value != null) {
-			Color c = (new ColorParser()).parseColor(value);
-
-			if (c != null) {
-				setDefaultNodeReverseSelectionColor(c);
-			}
-		}
-
-		value = nacProps.getProperty(baseKey + ".defaultEdgeSelectionColor");
-
-		if (value != null) {
-			Color c = (new ColorParser()).parseColor(value);
-
-			if (c != null) {
-				setDefaultEdgeSelectionColor(c);
-			}
-		}
-
-		value = nacProps.getProperty(baseKey + ".defaultEdgeReverseSelectionColor");
-
-		if (value != null) {
-			Color c = (new ColorParser()).parseColor(value);
-
-			if (c != null) {
-				setDefaultEdgeReverseSelectionColor(c);
-			}
-		}
-	}
-
-	/**
-	 * Returns a Properties description of this object, suitable for
-	 * customization by the applyProperties method.
-	 */
-	public Properties getProperties(String baseKey) {
-		String key = null;
-		String value = null;
-		Properties newProps = new Properties();
-
-		// save default values
-		key = baseKey + ".defaultBackgroundColor";
-		value = ObjectToString.getStringValue(getDefaultBackgroundColor());
-		newProps.setProperty(key, value);
-
-		key = baseKey + ".defaultNodeSelectionColor";
-		value = ObjectToString.getStringValue(getDefaultNodeSelectionColor());
-		newProps.setProperty(key, value);
-
-		key = baseKey + ".defaultNodeReverseSelectionColor";
-		value = ObjectToString.getStringValue(getDefaultNodeReverseSelectionColor());
-		newProps.setProperty(key, value);
-
-		key = baseKey + ".defaultEdgeSelectionColor";
-		value = ObjectToString.getStringValue(getDefaultEdgeSelectionColor());
-		newProps.setProperty(key, value);
-
-		key = baseKey + ".defaultEdgeReverseSelectionColor";
-		value = ObjectToString.getStringValue(getDefaultEdgeReverseSelectionColor());
-		newProps.setProperty(key, value);
-
-		return newProps;
-	}
-}
Index: vizmap/src/main/java/org/cytoscape/vizmap/EdgeAppearanceCalculator.java
===================================================================
--- vizmap/src/main/java/org/cytoscape/vizmap/EdgeAppearanceCalculator.java	(.../trunk)	(revision 14573)
+++ vizmap/src/main/java/org/cytoscape/vizmap/EdgeAppearanceCalculator.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -1,201 +0,0 @@
-/*
- File: EdgeAppearanceCalculator.java
-
- Copyright (c) 2006, The Cytoscape Consortium (www.cytoscape.org)
-
- The Cytoscape Consortium is:
- - Institute for Systems Biology
- - University of California San Diego
- - Memorial Sloan-Kettering Cancer Center
- - Institut Pasteur
- - Agilent Technologies
-
- This library is free software; you can redistribute it and/or modify it
- under the terms of the GNU Lesser General Public License as published
- by the Free Software Foundation; either version 2.1 of the License, or
- any later version.
-
- This library is distributed in the hope that it will be useful, but
- WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF
- MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  The software and
- documentation provided hereunder is on an "as is" basis, and the
- Institute for Systems Biology and the Whitehead Institute
- have no obligations to provide maintenance, support,
- updates, enhancements or modifications.  In no event shall the
- Institute for Systems Biology and the Whitehead Institute
- be liable to any party for direct, indirect, special,
- incidental or consequential damages, including lost profits, arising
- out of the use of this software and its documentation, even if the
- Institute for Systems Biology and the Whitehead Institute
- have been advised of the possibility of such damage.  See
- the GNU Lesser General Public License for more details.
-
- You should have received a copy of the GNU Lesser General Public License
- along with this library; if not, write to the Free Software Foundation,
- Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- */
-
-//----------------------------------------------------------------------------
-// $Revision: 13022 $
-// $Date: 2008-02-11 13:59:26 -0800 (Mon, 11 Feb 2008) $
-// $Author: mes $
-//----------------------------------------------------------------------------
-package org.cytoscape.vizmap;
-
-import org.cytoscape.GraphPerspective;
-
-import org.cytoscape.vizmap.calculators.BasicCalculator;
-import org.cytoscape.vizmap.calculators.Calculator;
-
-import org.cytoscape.vizmap.mappings.ObjectMapping;
-
-import org.cytoscape.Edge;
-
-import java.awt.Color;
-import java.awt.Font;
-
-import java.util.Properties;
-
-
-//----------------------------------------------------------------------------
-/**
- * This class calculates the appearance of an Edge. It holds a default value and
- * a (possibly null) calculator for each visual attribute.
- */
-public class EdgeAppearanceCalculator extends AppearanceCalculator {
-	private EdgeAppearance defaultAppearance = new EdgeAppearance();
-
-	/**
-	 * Creates a new EdgeAppearanceCalculator object.
-	 */
-	public EdgeAppearanceCalculator() {
-		super();
-	}
-
-	/**
-	 * Copy constructor. Returns a default object if the argument is null.
-	 */
-	public EdgeAppearanceCalculator(EdgeAppearanceCalculator toCopy) {
-		super(toCopy);
-	}
-
-	/**
-	 * Creates a new EdgeAppearanceCalculator and immediately customizes it by
-	 * calling applyProperties with the supplied arguments.
-	 */
-	public EdgeAppearanceCalculator(String name, Properties eacProps, String baseKey,
-	                                CalculatorCatalog catalog) {
-		super(name, eacProps, baseKey, catalog, new EdgeAppearance());
-		defaultAppearance = (EdgeAppearance) tmpDefaultAppearance;
-	}
-
-	/**
-	 * Create deep copy of the object.
-	 */
-	public Object clone() {
-		final EdgeAppearanceCalculator copy = new EdgeAppearanceCalculator();
-
-		// Copy defaults
-		final EdgeAppearance defAppr = new EdgeAppearance();
-
-		for (VisualPropertyType type : VisualPropertyType.getEdgeVisualPropertyList()) {
-			defAppr.set(type, defaultAppearance.get(type));
-		}
-
-		copy.setDefaultAppearance(defAppr);
-
-		//Copy mappings
-		for (Calculator cal : this.calcs) {
-			final ObjectMapping mCopy = (ObjectMapping) cal.getMapping(0).clone();
-			BasicCalculator bCalc = new BasicCalculator(cal.toString(), mCopy,
-			                                            cal.getVisualPropertyType());
-			copy.setCalculator(bCalc);
-		}
-
-		return copy;
-	}
-
-	/**
-	 * Using the rules defined by the default values and calculators in this
-	 * object, compute an appearance for the requested Edge in the supplied
-	 * CyNetwork. A new EdgeApperance object will be created.
-	 */
-	public EdgeAppearance calculateEdgeAppearance(Edge edge, GraphPerspective network) {
-		EdgeAppearance appr = (EdgeAppearance) defaultAppearance.clone();
-		calculateEdgeAppearance(appr, edge, network);
-
-		return appr;
-	}
-
-	/**
-	 * Using the rules defined by the default values and calculators in this
-	 * object, compute an appearance for the requested Edge in the supplied
-	 * CyNetwork. The supplied EdgeAppearance object will be changed to hold the
-	 * new values.
-	 */
-	public void calculateEdgeAppearance(EdgeAppearance appr, Edge edge, GraphPerspective network) {
-		appr.copy(defaultAppearance); // set default values
-
-		for (Calculator c : calcs)
-			c.apply(appr, edge, network);
-
-		appr.applyBypass(edge);
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @return DOCUMENT ME!
-	 */
-	public EdgeAppearance getDefaultAppearance() {
-		return defaultAppearance;
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @param appr DOCUMENT ME!
-	 */
-	public void setDefaultAppearance(EdgeAppearance appr) {
-		defaultAppearance = appr;
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @return DOCUMENT ME!
-	 */
-	public String getDescription() {
-		return getDescription("EdgeAppearanceCalculator", defaultAppearance);
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @param name DOCUMENT ME!
-	 * @param eacProps DOCUMENT ME!
-	 * @param baseKey DOCUMENT ME!
-	 * @param catalog DOCUMENT ME!
-	 */
-	public void applyProperties(String name, Properties eacProps, String baseKey,
-	                            CalculatorCatalog catalog) {
-		applyProperties(defaultAppearance, name, eacProps, baseKey, catalog);
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @param baseKey DOCUMENT ME!
-	 *
-	 * @return DOCUMENT ME!
-	 */
-	public Properties getProperties(String baseKey) {
-		return getProperties(defaultAppearance, baseKey);
-	}
-
-	protected void copyDefaultAppearance(AppearanceCalculator toCopy) {
-		defaultAppearance = (EdgeAppearance) (((EdgeAppearanceCalculator) toCopy).getDefaultAppearance()
-		                                       .clone());
-	}
-
-}
Index: render.immed/src/main/java/cytoscape/render/immed/GraphGraphics.java
===================================================================
--- render.immed/src/main/java/cytoscape/render/immed/GraphGraphics.java	(.../trunk)	(revision 14573)
+++ render.immed/src/main/java/cytoscape/render/immed/GraphGraphics.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -220,7 +220,6 @@
 	private final Line2D.Double m_line2d = new Line2D.Double();
 	private final double[] m_polyCoords = // I need this for extra precision.
 	new double[2 * CUSTOM_SHAPE_MAX_VERTICES];
-	private final HashMap<Byte, double[]> m_customShapes = new HashMap<Byte, double[]>();
 	private final double[] m_ptsBuff = new double[4];
 	private final EdgeAnchors m_noAnchors = new EdgeAnchors() {
 		public final int numAnchors() {
@@ -245,9 +244,6 @@
 	private final float[] m_currDash = new float[] { 0.0f, 0.0f };
 	private int m_currCapType;
 
-	// This member variable only to be used from within defineCustomNodeShape().
-	private byte m_lastCustomShapeType = s_last_shape;
-
 	// This is only used by computeCubicPolyEdgePath().
 	private final float[] m_floatBuff = new float[2];
 
@@ -298,6 +294,9 @@
 		m_cleared = false;
 	}
 
+	public Graphics2D getCanvas(){
+		return m_g2d;
+	}
 	/**
 	 * Clears image area with background paint specified and sets an appropriate
 	 * transformation of coordinate systems. See the class description for a
@@ -543,207 +542,17 @@
 				RenderingHints.VALUE_RENDER_SPEED);
 	}
 
-	/**
-	 * Draws a node with medium to high detail, depending on parameters
-	 * specified. The xMin, yMin, xMax, and yMax parameters specify the extents
-	 * of the node shape (in the node coordinate system), including the border
-	 * width. That is, the drawn border won't extend beyond the extents
-	 * specified.
-	 * <p>
-	 * There is an imposed constraint on borderWidth which, using the
-	 * implemented algorithms, prevents strange-looking borders. The constraint
-	 * is that borderWidth may not exceed the minimum of the node width and node
-	 * height divided by six. In addition, for custom node shapes, this
-	 * requirement may be more constrained, depending on the kinks in the custom
-	 * node shape.
-	 * <p>
-	 * There is a constraint that only applies to SHAPE_ROUNDED_RECTANGLE which
-	 * imposes that the maximum of the width and height be strictly less than
-	 * twice the minimum of the width and height of the node.
-	 * <p>
-	 * This method will not work unless clear() has been called at least once
-	 * previously.
-	 * 
-	 * @param nodeShape
-	 *            the shape of the node to draw (one of the SHAPE_* constants or
-	 *            a custom node shape).
-	 * @param xMin
-	 *            an extent of the node shape to draw, in node coordinate space;
-	 *            the drawn shape will theoretically contain a point that lies
-	 *            on this X coordinate.
-	 * @param yMin
-	 *            an extent of the node shape to draw, in node coordinate space;
-	 *            the drawn shape will theoretically contain a point that lies
-	 *            on this Y coordinate.
-	 * @param xMax
-	 *            an extent of the node shape to draw, in node coordinate space;
-	 *            the drawn shape will theoretically contain a point that lies
-	 *            on this X coordinate.
-	 * @param yMax
-	 *            an extent of the node shape to draw, in node coordinate space;
-	 *            the drawn shape will theoretically contain a point that lies
-	 *            on this Y coordinate.
-	 * @param fillPaint
-	 *            the paint to use when drawing the node area minus the border
-	 *            (the "interior" of the node).
-	 * @param borderWidth
-	 *            the border width, in node coordinate space; if this value is
-	 *            zero, the rendering engine skips over the process of rendering
-	 *            the border, which gives a significant performance boost.
-	 * @param borderPaint
-	 *            if borderWidth is not zero, this paint is used for rendering
-	 *            the node border; otherwise, this parameter is ignored (and may
-	 *            be null).
-	 * @exception IllegalArgumentException
-	 *                if xMin is not less than xMax or if yMin is not less than
-	 *                yMax, if borderWidth is negative or is greater than
-	 *                Math.min(xMax - xMin, yMax - yMin) / 6 (for custom node
-	 *                shapes borderWidth may be even more limited, depending on
-	 *                the specific shape), if nodeShape is
-	 *                SHAPE_ROUNDED_RECTANGLE and the condition max(width,
-	 *                height) < 2 * min(width, height) does not hold, or if
-	 *                nodeShape is neither one of the SHAPE_* constants nor a
-	 *                previously defined custom node shape.
-	 */
-	public final void drawNodeFull(final byte nodeShape, final float xMin,
-			final float yMin, final float xMax, final float yMax,
-			final Paint fillPaint, final float borderWidth,
-			final Paint borderPaint) {
-		if (m_debug) {
-			if (!EventQueue.isDispatchThread()) {
-				throw new IllegalStateException(
-						"calling thread is not AWT event dispatcher");
-			}
+	public void drawEdgeAnchor(float x, float y, float anchorSize, Paint anchorFillPaint){
 
-			if (!m_cleared) {
-				throw new IllegalStateException(
-						"clear() has not been called previously");
-			}
-
-			if (!(xMin < xMax)) {
-				throw new IllegalArgumentException("xMin not less than xMax");
-			}
-
-			if (!(yMin < yMax)) {
-				throw new IllegalArgumentException("yMin not less than yMax");
-			}
-
-			if (!(borderWidth >= 0.0f)) {
-				throw new IllegalArgumentException(
-						"borderWidth not zero or positive");
-			}
-
-			if (!((6.0d * borderWidth) <= Math.min(((double) xMax) - xMin,
-					((double) yMax) - yMin))) {
-				throw new IllegalArgumentException(
-						"borderWidth is not less than the minimum of node width and node "
-								+ "height divided by six");
-			}
-
-			if (nodeShape == SHAPE_ROUNDED_RECTANGLE) {
-				final double width = ((double) xMax) - xMin;
-				final double height = ((double) yMax) - yMin;
-
-				if (!(Math.max(width, height) < (2.0d * Math.min(width, height)))) {
-					throw new IllegalArgumentException(
-							"rounded rectangle does not meet constraint "
-									+ "max(width, height) < 2 * min(width, height)");
-				}
-			}
-		}
-
-		if (borderWidth == 0.0f) {
-			m_g2d.setPaint(fillPaint);
-			m_g2d.fill(getShape(nodeShape, xMin, yMin, xMax, yMax));
-		} else { // There is a border.
-			m_path2dPrime.reset();
-			m_path2dPrime.append(getShape(nodeShape, xMin, yMin, xMax, yMax),
-					false); // Make a copy, essentially.
-
-			final Shape innerShape;
-
-			if (nodeShape == SHAPE_ELLIPSE) {
-				// TODO: Compute a more accurate inner area for ellipse +
-				// border.
-				innerShape = getShape(SHAPE_ELLIPSE, ((double) xMin)
-						+ borderWidth, ((double) yMin) + borderWidth,
-						((double) xMax) - borderWidth, ((double) yMax)
-								- borderWidth);
-			} else if (nodeShape == SHAPE_ROUNDED_RECTANGLE) {
-				computeRoundedRectangle(((double) xMin) + borderWidth,
-						((double) yMin) + borderWidth, ((double) xMax)
-								- borderWidth, ((double) yMax) - borderWidth,
-						(Math.max(((double) xMax) - xMin, ((double) yMax)
-								- yMin) / 4.0d)
-								- borderWidth, m_path2d);
-				innerShape = m_path2d;
-			} else {
-				// A general [possibly non-convex] polygon with certain
-				// restrictions: no two consecutive line segments can be
-				// parallel,
-				// each line segment must have nonzero length, the polygon
-				// cannot
-				// self-intersect, and the polygon must be clockwise
-				// in the node coordinate system.
-				m_path2d.reset();
-
-				final double xNot = m_polyCoords[0];
-				final double yNot = m_polyCoords[1];
-				final double xOne = m_polyCoords[2];
-				final double yOne = m_polyCoords[3];
-				double xPrev = xNot;
-				double yPrev = yNot;
-				double xCurr = xOne;
-				double yCurr = yOne;
-				double xNext = m_polyCoords[4];
-				double yNext = m_polyCoords[5];
-				computeInnerPoint(m_ptsBuff, xPrev, yPrev, xCurr, yCurr, xNext,
-						yNext, borderWidth);
-				m_path2d.moveTo((float) m_ptsBuff[0], (float) m_ptsBuff[1]);
-
-				int i = 6;
-
-				while (true) {
-					if (i == (m_polyNumPoints * 2)) {
-						computeInnerPoint(m_ptsBuff, xCurr, yCurr, xNext,
-								yNext, xNot, yNot, borderWidth);
-						m_path2d.lineTo((float) m_ptsBuff[0],
-								(float) m_ptsBuff[1]);
-						computeInnerPoint(m_ptsBuff, xNext, yNext, xNot, yNot,
-								xOne, yOne, borderWidth);
-						m_path2d.lineTo((float) m_ptsBuff[0],
-								(float) m_ptsBuff[1]);
-						m_path2d.closePath();
-
-						break;
-					} else {
-						xPrev = xCurr;
-						yPrev = yCurr;
-						xCurr = xNext;
-						yCurr = yNext;
-						xNext = m_polyCoords[i++];
-						yNext = m_polyCoords[i++];
-						computeInnerPoint(m_ptsBuff, xPrev, yPrev, xCurr,
-								yCurr, xNext, yNext, borderWidth);
-						m_path2d.lineTo((float) m_ptsBuff[0],
-								(float) m_ptsBuff[1]);
-					}
-				}
-
-				innerShape = m_path2d;
-			}
-
-			m_g2d.setPaint(fillPaint);
-			m_g2d.fill(innerShape);
-
-			// Render the border such that it does not overlap with the fill
-			// region because translucent colors may be used. Don't do
-			// things differently for opaque and translucent colors for the
-			// sake of consistency.
-			m_path2dPrime.append(innerShape, false);
-			m_g2d.setPaint(borderPaint);
-			m_g2d.fill(m_path2dPrime);
-		}
+		byte nodeShape = GraphGraphics.SHAPE_RECTANGLE;
+		double xMin = x - (anchorSize / 2.0d); 
+		double yMin = y - (anchorSize / 2.0d);
+		double xMax = x + (anchorSize / 2.0d);
+		double yMax = x - (anchorSize / 2.0d);
+		Paint fillPaint = anchorFillPaint;
+		
+		m_g2d.setPaint(fillPaint);
+		m_g2d.fill(getShape(nodeShape, xMin, yMin, xMax, yMax));
 	}
 
 	/**
@@ -800,280 +609,6 @@
 		path.append(getShape(nodeShape, xMin, yMin, xMax, yMax), false);
 	}
 
-	/**
-	 * The custom node shape that is defined is a polygon specified by the
-	 * coordinates supplied. The polygon must meet several constraints listed
-	 * below.
-	 * <p>
-	 * If we define the value xCenter to be the average of the minimum and
-	 * maximum X values of the vertices and if we define yCenter likewise, then
-	 * the specified polygon must meet the following constraints:
-	 * <ol>
-	 * <li>Each polygon line segment must have nonzero length.</li>
-	 * <li>No two consecutive polygon line segments can be parallel (this
-	 * essentially implies that the polygon must have at least three vertices).</li>
-	 * <li>No two distinct non-consecutive polygon line segments may intersect
-	 * (not even at the endpoints); this makes possible the notion of interior
-	 * of the polygon.</li>
-	 * <li>The polygon must be star-shaped with respect to the point (xCenter,
-	 * yCenter); a polygon is said to be <i>star-shaped with respect to a point
-	 * (a,b)</i> if and only if for every point (x,y) in the interior or on the
-	 * boundary of the polygon, the interior of the segment (a,b)->(x,y) lies in
-	 * the interior of the polygon.</li>
-	 * <li>The path traversed by the polygon must be clockwise where +X points
-	 * right and +Y points down.</li>
-	 * </ol>
-	 * <p>
-	 * In addition to these constraints, when rendering custom nodes with
-	 * nonzero border width, possible problems may arise if the border width is
-	 * large with respect to the kinks in the polygon.
-	 * 
-	 * @param coords
-	 *            vertexCount * 2 consecutive coordinate values are read from
-	 *            this array starting at coords[offset]; coords[offset],
-	 *            coords[offset + 1], coords[offset + 2], coords[offset + 3] and
-	 *            so on are interpreted as x0, y0, x1, y1, and so on; the
-	 *            initial vertex need not be repeated as the last vertex
-	 *            specified.
-	 * @param offset
-	 *            the starting index of where to read coordinates from in the
-	 *            coords parameter.
-	 * @param vertexCount
-	 *            the number of vertices to read from coords; vertexCount * 2
-	 *            entries in coords are read.
-	 * @return the node shape identifier to be used in future rendering calls
-	 *         (to be used as parameter nodeShape in method drawNodeFull()).
-	 * @exception IllegalArgumentException
-	 *                if any of the constraints are not met, or if the specified
-	 *                polygon has more than CUSTOM_SHAPE_MAX_VERTICES vertices.
-	 * @exception IllegalStateException
-	 *                if too many custom node shapes are already defined; a
-	 *                little over one hundered custom node shapes can be
-	 *                defined.
-	 */
-	public final byte defineCustomNodeShape(final float[] coords,
-			final int offset, final int vertexCount) {
-		if (vertexCount > CUSTOM_SHAPE_MAX_VERTICES) {
-			throw new IllegalArgumentException(
-					"too many vertices (greater than "
-							+ CUSTOM_SHAPE_MAX_VERTICES + ")");
-		}
-
-		final double[] polyCoords;
-
-		{
-			polyCoords = new double[vertexCount * 2];
-
-			for (int i = 0; i < polyCoords.length; i++)
-				polyCoords[i] = coords[offset + i];
-
-			// Normalize the polygon so that it spans [-0.5, 0.5] x [-0.5, 0.5].
-			double xMin = Double.POSITIVE_INFINITY;
-			double yMin = Double.POSITIVE_INFINITY;
-			double xMax = Double.NEGATIVE_INFINITY;
-			double yMax = Double.NEGATIVE_INFINITY;
-
-			for (int i = 0; i < polyCoords.length;) {
-				xMin = Math.min(xMin, coords[i]);
-				xMax = Math.max(xMax, coords[i++]);
-				yMin = Math.min(yMin, coords[i]);
-				yMax = Math.max(yMax, coords[i++]);
-			}
-
-			final double xDist = xMax - xMin;
-
-			if (xDist == 0.0d) {
-				throw new IllegalArgumentException(
-						"polygon does not move in the X direction");
-			}
-
-			final double yDist = yMax - yMin;
-
-			if (yDist == 0.0d) {
-				throw new IllegalArgumentException(
-						"polygon does not move in the Y direction");
-			}
-
-			final double xMid = (xMin + xMax) / 2.0d;
-			final double yMid = (yMin + yMax) / 2.0d;
-
-			for (int i = 0; i < polyCoords.length;) {
-				double foo = (polyCoords[i] - xMid) / xDist;
-				polyCoords[i++] = Math.min(Math.max(-0.5d, foo), 0.5d);
-				foo = (polyCoords[i] - yMid) / yDist;
-				polyCoords[i++] = Math.min(Math.max(-0.5d, foo), 0.5d);
-			}
-		}
-
-		if (m_debug) {
-			if (!EventQueue.isDispatchThread()) {
-				throw new IllegalStateException(
-						"calling thread is not AWT event dispatcher");
-			}
-		}
-
-		{ // Test all criteria regardless of m_debug.
-
-			int yInterceptsCenter = 0;
-
-			for (int i = 0; i < vertexCount; i++) {
-				final double x0 = polyCoords[i * 2];
-				final double y0 = polyCoords[(i * 2) + 1];
-				final double x1 = polyCoords[((i * 2) + 2) % (vertexCount * 2)];
-				final double y1 = polyCoords[((i * 2) + 3) % (vertexCount * 2)];
-				final double x2 = polyCoords[((i * 2) + 4) % (vertexCount * 2)];
-				final double y2 = polyCoords[((i * 2) + 5) % (vertexCount * 2)];
-				final double distP0P1 = Math.sqrt(((x1 - x0) * (x1 - x0))
-						+ ((y1 - y0) * (y1 - y0)));
-
-				if ((float) distP0P1 == 0.0f) { // Too close to distance zero.
-					throw new IllegalArgumentException(
-							"a line segment has distance [too close to] zero");
-				}
-
-				final double distP2fromP0P1 = ((((y0 - y1) * x2)
-						+ ((x1 - x0) * y2) + (x0 * y1)) - (x1 * y0))
-						/ distP0P1;
-
-				if ((float) distP2fromP0P1 == 0.0f) { // Too close to
-					// parallel.
-					throw new IllegalArgumentException(
-							"either a line segment has distance [too close to] zero or "
-									+ "two consecutive line segments are [too close to] parallel");
-				}
-
-				final double distCenterFromP0P1 = ((x0 * y1) - (x1 * y0))
-						/ distP0P1;
-
-				if (!((float) distCenterFromP0P1 > 0.0f)) {
-					throw new IllegalArgumentException(
-							"polygon is going counter-clockwise or is not star-shaped with "
-									+ "respect to center");
-				}
-
-				if ((Math.min(y0, y1) < 0.0d) && (Math.max(y0, y1) >= 0.0d)) {
-					yInterceptsCenter++;
-				}
-			}
-
-			if (yInterceptsCenter != 2) {
-				throw new IllegalArgumentException(
-						"the polygon self-intersects (we know this because the winding "
-								+ "number of the center is not one)");
-			}
-		}
-
-		// polyCoords now contains a polygon spanning [-0.5, 0.5] X [-0.5, 0.5]
-		// that passes all of the criteria.
-		final byte nextCustomShapeType = (byte) (m_lastCustomShapeType + 1);
-
-		if (nextCustomShapeType < 0) {
-			throw new IllegalStateException(
-					"too many custom node shapes are already defined");
-		}
-
-		m_lastCustomShapeType++;
-		m_customShapes.put(new Byte(nextCustomShapeType), polyCoords);
-
-		return nextCustomShapeType;
-	}
-
-	/**
-	 * Determines whether the specified shape is a custom defined node shape.
-	 */
-	public final boolean customNodeShapeExists(final byte shape) {
-		if (m_debug) {
-			if (!EventQueue.isDispatchThread()) {
-				throw new IllegalStateException(
-						"calling thread is not AWT event dispatcher");
-			}
-		}
-
-		return (shape > s_last_shape) && (shape <= m_lastCustomShapeType);
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 * 
-	 * @return DOCUMENT ME!
-	 */
-	public final byte[] getCustomNodeShapes() {
-		if (m_debug) {
-			if (!EventQueue.isDispatchThread()) {
-				throw new IllegalStateException(
-						"calling thread is not AWT event dispatcher");
-			}
-		}
-
-		final byte[] returnThis = new byte[m_lastCustomShapeType - s_last_shape];
-
-		for (int i = 0; i < returnThis.length; i++) {
-			returnThis[i] = (byte) (s_last_shape + 1 + i);
-		}
-
-		return returnThis;
-	}
-
-	/**
-	 * Returns the vertices of a previously defined custom node shape. The
-	 * polygon will be normalized to fit within the [-0.5, 0.5] x [-0.5, 0.5]
-	 * square. Returns null if specified shape is not a previously defined
-	 * custom shape.
-	 */
-	public final float[] getCustomNodeShape(final byte customShape) {
-		if (m_debug) {
-			if (!EventQueue.isDispatchThread()) {
-				throw new IllegalStateException(
-						"calling thread is not AWT event dispatcher");
-			}
-		}
-
-		final double[] dCoords = m_customShapes.get(new Byte(customShape));
-
-		if (dCoords == null) {
-			return null;
-		}
-
-		final float[] returnThis = new float[dCoords.length];
-
-		for (int i = 0; i < returnThis.length; i++) {
-			returnThis[i] = (float) dCoords[i];
-		}
-
-		return returnThis;
-	}
-
-	/**
-	 * If this is a new instance, imports the custom node shapes from the
-	 * GraphGraphics specified into this GraphGraphics.
-	 * 
-	 * @param grafx
-	 *            custom node shapes will be imported from this GraphGraphics.
-	 * @exception IllegalStateException
-	 *                if at least one custom node shape is already defined in
-	 *                this GraphGraphics.
-	 */
-	public final void importCustomNodeShapes(final GraphGraphics grafx) {
-		if (m_debug) {
-			if (!EventQueue.isDispatchThread()) {
-				throw new IllegalStateException(
-						"calling thread is not AWT event dispatcher");
-			}
-		}
-
-		// I define this error check outside the scope of m_debug because
-		// clobbering existing custom node shape definitions could be major.
-		if (m_lastCustomShapeType != s_last_shape) {
-			throw new IllegalStateException(
-					"a custom node shape is already defined in this GraphGraphics");
-		}
-
-		for (Map.Entry<Byte, double[]> entry : grafx.m_customShapes.entrySet()) {
-			m_customShapes.put(entry.getKey(), entry.getValue());
-			m_lastCustomShapeType++;
-		}
-	}
-
 	/*
 	 * This method has the side effect of setting m_ellp2d or m_path2d; if
 	 * m_path2d is set (every case but the ellipse and rounded rectangle), then
@@ -1196,29 +731,9 @@
 
 			break;
 
-		default: // Try a custom node shape or throw an exception.
-
-			final double[] storedPolyCoords = // To optimize don't construct
-			// Byte.
-			(double[]) m_customShapes.get(new Byte(nodeShape));
-
-			if (storedPolyCoords == null) {
-				throw new IllegalArgumentException(
-						"nodeShape is not recognized");
-			}
-
-			m_polyNumPoints = storedPolyCoords.length / 2;
-
-			final double desiredXCenter = (xMin + xMax) / 2.0d;
-			final double desiredYCenter = (yMin + yMax) / 2.0d;
-			final double desiredWidth = xMax - xMin;
-			final double desiredHeight = yMax - yMin;
-			m_xformUtil.setToTranslation(desiredXCenter, desiredYCenter);
-			m_xformUtil.scale(desiredWidth, desiredHeight);
-			m_xformUtil.transform(storedPolyCoords, 0, m_polyCoords, 0,
-					m_polyNumPoints);
-
-			break;
+		default:
+			throw new IllegalArgumentException("nodeShape is not recognized");
+		    //break;
 		}
 
 		m_path2d.reset();
@@ -1323,35 +838,6 @@
 		path2d.closePath();
 	}
 
-	/*
-	 * This method is used to construct an inner shape for node border.
-	 * output[0] is the x return value and output[1] is the y return value. The
-	 * line prev->curr cannot be parallel to curr->next.
-	 */
-	private final static void computeInnerPoint(final double[] output,
-			final double xPrev, final double yPrev, final double xCurr,
-			final double yCurr, final double xNext, final double yNext,
-			final double borderWidth) {
-		final double segX1 = xCurr - xPrev;
-		final double segY1 = yCurr - yPrev;
-		final double segLength1 = Math.sqrt((segX1 * segX1) + (segY1 * segY1));
-		final double segX2 = xNext - xCurr;
-		final double segY2 = yNext - yCurr;
-		final double segLength2 = Math.sqrt((segX2 * segX2) + (segY2 * segY2));
-		final double segX2Normal = segX2 / segLength2;
-		final double segY2Normal = segY2 / segLength2;
-		final double xNextPrime = (segX2Normal * segLength1) + xPrev;
-		final double yNextPrime = (segY2Normal * segLength1) + yPrev;
-		final double segPrimeX = xNextPrime - xCurr;
-		final double segPrimeY = yNextPrime - yCurr;
-		final double distancePrimeToSeg1 = (((segX1 * yNextPrime)
-				- (segY1 * xNextPrime) + (xPrev * yCurr)) - (xCurr * yPrev))
-				/ segLength1;
-		final double multFactor = borderWidth / distancePrimeToSeg1;
-		output[0] = (multFactor * segPrimeX) + xCurr;
-		output[1] = (multFactor * segPrimeY) + yCurr;
-	}
-
 	/**
 	 * This is the method that will render an edge very quickly. Translucent
 	 * colors are not supported by the low detail rendering methods.
@@ -3366,43 +2852,6 @@
 		return m_fontRenderContextFull;
 	}
 
-	/**
-	 * Fills an arbitrary graphical shape with high detail.
-	 * <p>
-	 * This method will not work unless clear() has been called at least once
-	 * previously.
-	 * 
-	 * @param shape
-	 *            the shape to fill; the shape is specified in node coordinates.
-	 * @param xOffset
-	 *            in node coordinates, a value to add to the X coordinates of
-	 *            the shape's definition.
-	 * @param yOffset
-	 *            in node coordinates, a value to add to the Y coordinates of
-	 *            the shape's definition.
-	 * @param paint
-	 *            the paint to use when filling the shape.
-	 */
-	public final void drawCustomGraphicFull(final Shape shape,
-			final float xOffset, final float yOffset, final Paint paint) {
-		if (m_debug) {
-			if (!EventQueue.isDispatchThread()) {
-				throw new IllegalStateException(
-						"calling thread is not AWT event dispatcher");
-			}
-
-			if (!m_cleared) {
-				throw new IllegalStateException(
-						"clear() has not been called previously");
-			}
-		}
-
-		m_g2d.translate(xOffset, yOffset);
-		m_g2d.setPaint(paint);
-		m_g2d.fill(shape);
-		m_g2d.setTransform(m_currNativeXform);
-	}
-
 	private enum ShapeTypes {
 		NODE_SHAPE, ARROW_SHAPE, LINE_STROKE;
 	}
Index: view/osgi.bnd
===================================================================
--- view/osgi.bnd	(.../trunk)	(revision 14573)
+++ view/osgi.bnd	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -2,6 +2,6 @@
 # Use this file to add customized Bnd instructions for the bundle
 #-----------------------------------------------------------------
 
-Export-Package: org.cytoscape.view
+Export-Package: org.cytoscape.view,org.cytoscape.view.renderers
 Private-Package: org.cytoscape.view.impl
 
Index: view/src/main/java/org/cytoscape/view/DiscreteValue.java
===================================================================
--- view/src/main/java/org/cytoscape/view/DiscreteValue.java	(.../trunk)	(revision 0)
+++ view/src/main/java/org/cytoscape/view/DiscreteValue.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -0,0 +1,6 @@
+package org.cytoscape.view;
+
+/** For specifying dataType in DiscreteVisualProperties */
+public abstract class DiscreteValue {
+
+}
Index: view/src/main/java/org/cytoscape/view/VisualPropertyCatalog.java
===================================================================
--- view/src/main/java/org/cytoscape/view/VisualPropertyCatalog.java	(.../trunk)	(revision 0)
+++ view/src/main/java/org/cytoscape/view/VisualPropertyCatalog.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -0,0 +1,126 @@
+package org.cytoscape.view;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.cytoscape.view.renderers.Renderer;
+
+/**
+ * The singleton class that holds all currently defined VisualProperties.
+ */
+public abstract class VisualPropertyCatalog {
+
+	/* Mapping from UID to VisualProperty */
+	private static HashMap <String, VisualProperty> visualProperties = new HashMap<String, VisualProperty>();
+	
+	private static HashMap <String, DependentVisualPropertyCallback>callbacks = new HashMap<String, DependentVisualPropertyCallback>(); 
+	
+	public static void addVisualPropertiesOfRenderer(Renderer renderer){
+		for(VisualProperty vp: renderer.supportedVisualAttributes()){
+			addVisualProperty(vp);
+		}
+	}
+
+	/** Add a top-level VisualProperty. Note: this is most likely _not_ what you want to use */
+	public static void addVisualProperty(VisualProperty vp){
+		String name = vp.getName();
+		if (visualProperties.containsKey(name)){
+			System.out.println("Error: VisualProperty already exsists!");
+		} else {
+			DependentVisualPropertyCallback callback = vp.dependentVisualPropertyCallback();
+			if (callback != null)
+				callbacks.put(vp.getName(), callback);
+
+			visualProperties.put(name, vp);
+		}
+	}
+
+	public static VisualProperty getVisualProperty(String name){
+		return visualProperties.get(name);
+	}
+	
+	/**
+	 * Returns the collection of all defined VisualProperties. Note that not all
+	 * of these will be actually in use. For showing in a UI, use of ... is
+	 * recommended ... FIXME
+	 * 
+	 * @return the Collection of all defined VisualProperties
+	 */
+	public static Collection<VisualProperty> collectionOfVisualProperties(){
+		return collectionOfVisualProperties(null, null);
+	}
+
+	/**
+	 * Returns the collection of all those VisualProperties that are in use for
+	 * the given GraphObjects. I.e. these are the VisualProperties, for which
+	 * setting a value will actually change the displayed graph.
+	 * 
+	 * Note: returns the same as collectionOfVisualProperties() if both args are null.
+	 */
+	public static Collection<VisualProperty> collectionOfVisualProperties(Collection<NodeView> nodeviews, Collection<EdgeView> edgeviews){
+		Collection<VisualProperty> allVisualProperties = visualProperties.values();
+		if (nodeviews == null && edgeviews == null)
+			return allVisualProperties;
+
+		Set <VisualProperty> toRemove = new HashSet<VisualProperty>();
+		for (DependentVisualPropertyCallback callback: callbacks.values()){
+			toRemove.addAll(callback.changed(nodeviews, edgeviews, allVisualProperties));
+		}
+		Set <VisualProperty> result = new HashSet<VisualProperty>(allVisualProperties);
+		result.removeAll(toRemove);
+		return result;
+	}
+
+	/**
+	 * Returns the collection of all defined edge VisualProperties.
+	 */
+	public static List<VisualProperty> getEdgeVisualPropertyList(){
+		return getEdgeVisualPropertyList(null, null);
+	}
+	
+	/**
+	 * Returns the collection of all edge VisualProperties that are in use for
+	 * the given GraphObjects.
+	 * 
+	 * Note: returns all defined edge VisualProperties if both args are null.
+	 */
+	public static List<VisualProperty> getEdgeVisualPropertyList(Collection<NodeView> nodeviews, Collection<EdgeView> edgeviews){
+		ArrayList<VisualProperty> result = new ArrayList<VisualProperty>();
+		for (VisualProperty vp: collectionOfVisualProperties(nodeviews, edgeviews)){
+			if (vp.isNodeProp()){
+				continue;
+			} else {
+				result.add(vp);
+			}
+		}
+		return result;
+	}
+
+	/**
+	 * Returns the collection of all defined node VisualProperties.
+	 */
+	public static List<VisualProperty> getNodeVisualPropertyList(){
+		return getNodeVisualPropertyList(null, null);
+	}
+	
+	/**
+	 * Returns the collection of all node VisualProperties that are in use for
+	 * the given GraphObjects.
+	 * 
+	 * Note: returns all defined node VisualProperties if both args are null.
+	 */
+	public static List<VisualProperty> getNodeVisualPropertyList(Collection<NodeView> nodeviews, Collection<EdgeView> edgeviews){
+		ArrayList<VisualProperty> result = new ArrayList<VisualProperty>();
+		for (VisualProperty vp: collectionOfVisualProperties(nodeviews, edgeviews)){
+			if (vp.isNodeProp()){
+				result.add(vp);
+			}
+		}
+		return result;
+	}
+
+}
Index: view/src/main/java/org/cytoscape/view/VisualProperty.java
===================================================================
--- view/src/main/java/org/cytoscape/view/VisualProperty.java	(.../trunk)	(revision 0)
+++ view/src/main/java/org/cytoscape/view/VisualProperty.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -0,0 +1,88 @@
+/*
+ Copyright (c) 2007, The Cytoscape Consortium (www.cytoscape.org)
+
+ The Cytoscape Consortium is:
+ - Institute for Systems Biology
+ - University of California San Diego
+ - Memorial Sloan-Kettering Cancer Center
+ - Institut Pasteur
+ - Agilent Technologies
+
+ This library is free software; you can redistribute it and/or modify it
+ under the terms of the GNU Lesser General Public License as published
+ by the Free Software Foundation; either version 2.1 of the License, or
+ any later version.
+
+ This library is distributed in the hope that it will be useful, but
+ WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF
+ MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  The software and
+ documentation provided hereunder is on an "as is" basis, and the
+ Institute for Systems Biology and the Whitehead Institute
+ have no obligations to provide maintenance, support,
+ updates, enhancements or modifications.  In no event shall the
+ Institute for Systems Biology and the Whitehead Institute
+ be liable to any party for direct, indirect, special,
+ incidental or consequential damages, including lost profits, arising
+ out of the use of this software and its documentation, even if the
+ Institute for Systems Biology and the Whitehead Institute
+ have been advised of the possibility of such damage.  See
+ the GNU Lesser General Public License for more details.
+
+ You should have received a copy of the GNU Lesser General Public License
+ along with this library; if not, write to the Free Software Foundation,
+ Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ */
+package org.cytoscape.view;
+
+import java.util.Map;
+
+import javax.swing.Icon;
+import java.util.Properties;
+import org.cytoscape.view.EdgeView;
+import org.cytoscape.view.NodeView;
+
+
+/**
+ * Represents a visual property.  All vp should implement this interface.
+ * 
+  */
+public interface VisualProperty {
+	
+	/** Returns the name of the VisualProperty. This should be an unique identifier */
+	public String getName();
+
+	/**
+	 * Returns the data type of this VisualProperty.
+	 * @return 
+	 */
+	public Class getDataType();
+	
+	/**
+	 * Check this visual property is for node or not.
+	 *
+	 * @return true if vp is for node. If false, this is a vp for edge.
+	 */
+	public boolean isNodeProp();
+	
+	/**
+	 *  DOCUMENT ME!
+	 *
+	 * @return  DOCUMENT ME!
+	 */
+	public Map<Object, Icon> getIconSet();
+
+	/**
+	 *  DOCUMENT ME!
+	 *
+	 * @return  DOCUMENT ME!
+	 */
+	public Icon getDefaultIcon();
+	public Icon getIcon(final Object value);
+
+	public void applyToNodeView(NodeView nv, Object o);
+	public void applyToEdgeView(EdgeView nv, Object o);
+	public Object parseProperty(Properties props, String baseKey);
+	public Object parseStringValue(String string);
+	public Object getDefaultAppearanceObject();
+	public DependentVisualPropertyCallback dependentVisualPropertyCallback();
+}

Property changes on: view/src/main/java/org/cytoscape/view/VisualProperty.java
___________________________________________________________________
Added: svn:mergeinfo

Index: view/src/main/java/org/cytoscape/view/renderers/Renderer.java
===================================================================
--- view/src/main/java/org/cytoscape/view/renderers/Renderer.java	(.../trunk)	(revision 0)
+++ view/src/main/java/org/cytoscape/view/renderers/Renderer.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -0,0 +1,12 @@
+package org.cytoscape.view.renderers;
+
+import java.util.Collection;
+
+import org.cytoscape.view.VisualProperty;
+
+public interface Renderer {
+	/**
+	 * Return a list of visual attributes this renderer can use
+	 */
+	public Collection<VisualProperty> supportedVisualAttributes();
+}
Index: view/src/main/java/org/cytoscape/view/renderers/NodeRenderer.java
===================================================================
--- view/src/main/java/org/cytoscape/view/renderers/NodeRenderer.java	(.../trunk)	(revision 0)
+++ view/src/main/java/org/cytoscape/view/renderers/NodeRenderer.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -0,0 +1,26 @@
+package org.cytoscape.view.renderers;
+
+import java.awt.Graphics2D;
+import java.util.Collection;
+
+import org.cytoscape.view.NodeView;
+import org.cytoscape.view.VisualProperty;
+
+import cytoscape.render.stateful.NodeDetails;
+
+public interface NodeRenderer extends Renderer{
+	/**
+	 * 
+	 */
+	public void render(Graphics2D graphics, NodeDetails nodeDetails, float[] position, int node, NodeView nodeView);
+	
+	/**
+	 * Draw a preview image on canvas at given place (using some default NodeDetails that the renderer can make up)
+	 */
+	public void generatePreview(Graphics2D graphics, float[] position);
+	
+	/**
+	 * Return a list of visual attributes this renderer can use
+	 */
+	public Collection<VisualProperty> supportedVisualAttributes();
+}
Index: view/src/main/java/org/cytoscape/view/DependentVisualPropertyCallback.java
===================================================================
--- view/src/main/java/org/cytoscape/view/DependentVisualPropertyCallback.java	(.../trunk)	(revision 0)
+++ view/src/main/java/org/cytoscape/view/DependentVisualPropertyCallback.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -0,0 +1,11 @@
+package org.cytoscape.view;
+
+import java.util.Collection;
+import java.util.Set;
+
+public abstract class DependentVisualPropertyCallback {
+	/** Called when mapping results change.
+	 * @return the set of VisualProperties to hide
+	 */
+	public abstract Set<VisualProperty> changed(Collection<NodeView> nodeviews, Collection<EdgeView> edgeviews, Collection<VisualProperty> current_vps);
+}
Index: view/src/main/java/org/cytoscape/view/NodeView.java
===================================================================
--- view/src/main/java/org/cytoscape/view/NodeView.java	(.../trunk)	(revision 14573)
+++ view/src/main/java/org/cytoscape/view/NodeView.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -2,7 +2,9 @@
 
 import java.awt.*;
 import org.cytoscape.*;
+import org.cytoscape.view.renderers.NodeRenderer;
 import java.awt.geom.Point2D;
+import java.util.HashMap;
 
 /** 
  * Any and all questions should be directed to me.
@@ -25,6 +27,8 @@
    */
   public Node getNode () ;
 
+  public HashMap<String, Object> getVisualAttributes();
+  
   /**
    * @return the index of this node in the perspective to which we are in a view on.
    */
@@ -49,7 +53,9 @@
    */
   public int getShape () ;
 
-
+  public NodeRenderer getRenderer () ;
+  public void setRenderer (NodeRenderer renderer) ;
+  
   /**
    * This sets the Paint that will be used by this node
    * when it is painted as selected.
@@ -245,10 +251,4 @@
   public double getLabelOffsetX();
   public double getLabelOffsetY();
   public int getNodeLabelAnchor();
-
-	public int getCustomGraphicCount();
-	public Shape getCustomGraphicShape(int index);
-	public Paint getCustomGraphicPaint(int index);
-	public void removeCustomGraphic(int index);
-	public void addCustomGraphic(Shape s, Paint p, int index);
 }
Index: view/src/main/java/org/cytoscape/view/VisualPropertyIcon.java
===================================================================
--- view/src/main/java/org/cytoscape/view/VisualPropertyIcon.java	(.../trunk)	(revision 0)
+++ view/src/main/java/org/cytoscape/view/VisualPropertyIcon.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -0,0 +1,214 @@
+/*
+ Copyright (c) 2006, 2007, The Cytoscape Consortium (www.cytoscape.org)
+
+ The Cytoscape Consortium is:
+ - Institute for Systems Biology
+ - University of California San Diego
+ - Memorial Sloan-Kettering Cancer Center
+ - Institut Pasteur
+ - Agilent Technologies
+
+ This library is free software; you can redistribute it and/or modify it
+ under the terms of the GNU Lesser General Public License as published
+ by the Free Software Foundation; either version 2.1 of the License, or
+ any later version.
+
+ This library is distributed in the hope that it will be useful, but
+ WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF
+ MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  The software and
+ documentation provided hereunder is on an "as is" basis, and the
+ Institute for Systems Biology and the Whitehead Institute
+ have no obligations to provide maintenance, support,
+ updates, enhancements or modifications.  In no event shall the
+ Institute for Systems Biology and the Whitehead Institute
+ be liable to any party for direct, indirect, special,
+ incidental or consequential damages, including lost profits, arising
+ out of the use of this software and its documentation, even if the
+ Institute for Systems Biology and the Whitehead Institute
+ have been advised of the possibility of such damage.  See
+ the GNU Lesser General Public License for more details.
+
+ You should have received a copy of the GNU Lesser General Public License
+ along with this library; if not, write to the Free Software Foundation,
+ Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+*/
+package org.cytoscape.view;
+
+import java.awt.Color;
+import java.awt.Shape;
+
+import javax.swing.ImageIcon;
+
+
+/**
+ *
+ * Icon created from Shape object passed from rendering engine.<br>
+ *
+ * This icon is scalable (vector image).
+ *
+ * Actual paint method is defined in child classes.
+ *
+ * @version 0.5
+ * @since Cytoscape 2.5
+ * @author kono
+ *
+ */
+public abstract class VisualPropertyIcon extends ImageIcon {
+	/**
+	 * Default icon color.
+	 */
+	public static final Color DEFAULT_ICON_COLOR = Color.DARK_GRAY;
+
+	/**
+	 *
+	 */
+	public static final int DEFAULT_ICON_SIZE = 32;
+	protected int height;
+	protected int width;
+	protected Color color;
+	protected Shape shape;
+	protected String name;
+	protected int leftPad = 0;
+	protected int bottomPad = 0;
+
+	/**
+	 * Creates a new VisualPropertyIcon object.
+	 *
+	 * @param shape  DOCUMENT ME!
+	 * @param name  DOCUMENT ME!
+	 */
+	public VisualPropertyIcon(String name, Color color) {
+		this(null, DEFAULT_ICON_SIZE, DEFAULT_ICON_SIZE, name, color);
+	}
+
+	/**
+	 * Constructor without Color parameter.
+	 *
+	 * @param shape
+	 * @param width
+	 * @param height
+	 * @param name
+	 */
+	public VisualPropertyIcon(Shape shape, int width, int height, String name) {
+		this(shape, width, height, name, DEFAULT_ICON_COLOR);
+	}
+
+	/**
+	 * Constructor with full parameter set.
+	 *
+	 * @param shape
+	 * @param width
+	 * @param height
+	 * @param name
+	 * @param color
+	 */
+	public VisualPropertyIcon(Shape shape, int width, int height, String name, Color color) {
+		this.shape = shape;
+		this.width = width;
+		this.height = height;
+		this.name = name;
+
+		if (color != null)
+			this.color = color;
+		else
+			this.color = DEFAULT_ICON_COLOR;
+	}
+
+	/**
+	 *  DOCUMENT ME!
+	 *
+	 * @return  DOCUMENT ME!
+	 */
+	public Shape getShape() {
+		return shape;
+	}
+
+	/**
+	 * Get height of icon. This implements Icon interface.
+	 */
+	public int getIconHeight() {
+		return height;
+	}
+
+	/**
+	 * Get width of icon. This implements Icon interface.
+	 */
+	public int getIconWidth() {
+		return width;
+	}
+
+	/**
+	 * Set width.
+	 *
+	 * @param width
+	 *            Width of icon
+	 */
+	public void setIconWidth(int width) {
+		this.width = width;
+	}
+
+	/**
+	 * Set height.
+	 *
+	 * @param height
+	 *            Height of icon
+	 */
+	public void setIconHeight(int height) {
+		this.height = height;
+	}
+
+	/**
+	 * Get human-readable name of this icon.
+	 *
+	 * @return
+	 */
+	public String getName() {
+		return name;
+	}
+
+	/**
+	 * Set human-readable name of this icon.
+	 *
+	 * @param name
+	 */
+	public void setName(String name) {
+		this.name = name;
+	}
+
+	/**
+	 * Get color of icon
+	 *
+	 * @return Icon color.
+	 */
+	public Color getColor() {
+		return color;
+	}
+
+	/**
+	 * Set icon color.
+	 *
+	 * @param color
+	 *            Icon color.
+	 */
+	public void setColor(Color color) {
+		this.color = color;
+	}
+
+	/**
+	* Insert space on the left.
+	*
+	* @param pad DOCUMENT ME!
+	*/
+	public void setLeftPadding(int pad) {
+		this.leftPad = pad;
+	}
+
+	/**
+	 *  DOCUMENT ME!
+	 *
+	 * @param pad DOCUMENT ME!
+	 */
+	public void setBottomPadding(int pad) {
+		this.bottomPad = pad;
+	}
+}

Property changes on: view/src/main/java/org/cytoscape/view/VisualPropertyIcon.java
___________________________________________________________________
Added: svn:mergeinfo

Index: view/src/main/java/org/cytoscape/view/impl/DNodeDetails.java
===================================================================
--- view/src/main/java/org/cytoscape/view/impl/DNodeDetails.java	(.../trunk)	(revision 14573)
+++ view/src/main/java/org/cytoscape/view/impl/DNodeDetails.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -37,7 +37,6 @@
 package org.cytoscape.view.impl;
 
 import cytoscape.render.stateful.NodeDetails;
-import cytoscape.render.stateful.CustomGraphic;
 
 
 import cytoscape.util.intr.IntObjHash;
@@ -65,9 +64,6 @@
 	// The values are Byte objects; the bytes are shapes defined in
 	// cytoscape.render.immed.GraphGraphics.
 	final HashMap<Integer,Object> m_shapes = new HashMap<Integer,Object>();
-	final HashMap<Integer,Object> m_fillPaints = new HashMap<Integer,Object>();
-	final HashMap<Integer,Object> m_borderWidths = new HashMap<Integer,Object>();
-	final HashMap<Integer,Object> m_borderPaints = new HashMap<Integer,Object>();
 	final HashMap<Integer,Object> m_labelCounts = new HashMap<Integer,Object>();
 	final HashMap<Integer,Object> m_labelTextAnchors = new HashMap<Integer,Object>();
 	final HashMap<Integer,Object> m_labelNodeAnchors = new HashMap<Integer,Object>();
@@ -88,11 +84,8 @@
 		if ((o != null) && (o != m_deletedEntry))
 			m_colorsLowDetail.put(node, m_deletedEntry);
 
-		final Integer key = Integer.valueOf(node);
+		final Integer key = new Integer(node);
 		m_shapes.remove(key);
-		m_fillPaints.remove(key);
-		m_borderWidths.remove(key);
-		m_borderPaints.remove(key);
 		m_labelTextAnchors.remove(key);
 		m_labelNodeAnchors.remove(key);
 		m_labelJustifys.remove(key);
@@ -103,7 +96,7 @@
 		final int labelCount = ((intr == null) ? 0 : ((Integer) intr).intValue());
 
 		for (int i = 0; i < labelCount; i++) {
-			final Long lKey = Long.valueOf((((long) node) << 32) | ((long) i));
+			final Long lKey = new Long((((long) node) << 32) | ((long) i));
 			m_labelTexts.remove(lKey);
 			m_labelFonts.remove(lKey);
 			m_labelPaints.remove(lKey);
@@ -147,7 +140,7 @@
 	 * @return DOCUMENT ME!
 	 */
 	public byte shape(int node) {
-		final Object o = m_shapes.get(Integer.valueOf(node));
+		final Object o = m_shapes.get(new Integer(node));
 
 		if (o == null)
 			return super.shape(node);
@@ -161,37 +154,12 @@
 	 */
 	void overrideShape(int node, byte shape) {
 		if ((shape < 0) || (shape == super.shape(node)))
-			m_shapes.remove(Integer.valueOf(node));
+			m_shapes.remove(new Integer(node));
 		else
-			m_shapes.put(Integer.valueOf(node), new Byte(shape));
+			m_shapes.put(new Integer(node), new Byte(shape));
 	}
 
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @param node DOCUMENT ME!
-	 *
-	 * @return DOCUMENT ME!
-	 */
-	public Paint fillPaint(int node) {
-		final Object o = m_fillPaints.get(Integer.valueOf(node));
 
-		if (o == null)
-			return super.fillPaint(node);
-
-		return (Paint) o;
-	}
-
-	/*
-	 * A null paint has the special meaning to remove overridden paint.
-	 */
-	void overrideFillPaint(int node, Paint paint) {
-		if ((paint == null) || paint.equals(super.fillPaint(node)))
-			m_fillPaints.remove(Integer.valueOf(node));
-		else
-			m_fillPaints.put(Integer.valueOf(node), paint);
-	}
-
 	/**
 	 * DOCUMENT ME!
 	 *
@@ -199,60 +167,8 @@
 	 *
 	 * @return DOCUMENT ME!
 	 */
-	public float borderWidth(int node) {
-		final Object o = m_borderWidths.get(Integer.valueOf(node));
-
-		if (o == null)
-			return super.borderWidth(node);
-
-		return ((Float) o).floatValue();
-	}
-
-	/*
-	 * A negative width value has the special meaning to remove overridden width.
-	 */
-	void overrideBorderWidth(int node, float width) {
-		if ((width < 0.0f) || (width == super.borderWidth(node)))
-			m_borderWidths.remove(Integer.valueOf(node));
-		else
-			m_borderWidths.put(Integer.valueOf(node), new Float(width));
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @param node DOCUMENT ME!
-	 *
-	 * @return DOCUMENT ME!
-	 */
-	public Paint borderPaint(int node) {
-		final Object o = m_borderPaints.get(Integer.valueOf(node));
-
-		if (o == null)
-			return super.borderPaint(node);
-
-		return (Paint) o;
-	}
-
-	/*
-	 * A null paint has the special meaning to remove overridden paint.
-	 */
-	void overrideBorderPaint(int node, Paint paint) {
-		if ((paint == null) || paint.equals(super.borderPaint(node)))
-			m_borderPaints.remove(Integer.valueOf(node));
-		else
-			m_borderPaints.put(Integer.valueOf(node), paint);
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @param node DOCUMENT ME!
-	 *
-	 * @return DOCUMENT ME!
-	 */
 	public int labelCount(int node) {
-		final Object o = m_labelCounts.get(Integer.valueOf(node));
+		final Object o = m_labelCounts.get(new Integer(node));
 
 		if (o == null)
 			return super.labelCount(node);
@@ -265,9 +181,9 @@
 	 */
 	void overrideLabelCount(int node, int labelCount) {
 		if ((labelCount < 0) || (labelCount == super.labelCount(node)))
-			m_labelCounts.remove(Integer.valueOf(node));
+			m_labelCounts.remove(new Integer(node));
 		else
-			m_labelCounts.put(Integer.valueOf(node), Integer.valueOf(labelCount));
+			m_labelCounts.put(new Integer(node), new Integer(labelCount));
 	}
 
 	/**
@@ -280,7 +196,7 @@
 	 */
 	public String labelText(int node, int labelInx) {
 		final long key = (((long) node) << 32) | ((long) labelInx);
-		final Object o = m_labelTexts.get(Long.valueOf(key));
+		final Object o = m_labelTexts.get(new Long(key));
 
 		if (o == null)
 			return super.labelText(node, labelInx);
@@ -295,9 +211,9 @@
 		final long key = (((long) node) << 32) | ((long) labelInx);
 
 		if ((text == null) || text.equals(super.labelText(node, labelInx)))
-			m_labelTexts.remove(Long.valueOf(key));
+			m_labelTexts.remove(new Long(key));
 		else
-			m_labelTexts.put(Long.valueOf(key), text);
+			m_labelTexts.put(new Long(key), text);
 	}
 
 	/**
@@ -310,7 +226,7 @@
 	 */
 	public Font labelFont(int node, int labelInx) {
 		final long key = (((long) node) << 32) | ((long) labelInx);
-		final Object o = m_labelFonts.get(Long.valueOf(key));
+		final Object o = m_labelFonts.get(new Long(key));
 
 		if (o == null)
 			return super.labelFont(node, labelInx);
@@ -325,9 +241,9 @@
 		final long key = (((long) node) << 32) | ((long) labelInx);
 
 		if ((font == null) || font.equals(super.labelFont(node, labelInx)))
-			m_labelFonts.remove(Long.valueOf(key));
+			m_labelFonts.remove(new Long(key));
 		else
-			m_labelFonts.put(Long.valueOf(key), font);
+			m_labelFonts.put(new Long(key), font);
 	}
 
 	/**
@@ -340,7 +256,7 @@
 	 */
 	public Paint labelPaint(int node, int labelInx) {
 		final long key = (((long) node) << 32) | ((long) labelInx);
-		final Object o = m_labelPaints.get(Long.valueOf(key));
+		final Object o = m_labelPaints.get(new Long(key));
 
 		if (o == null)
 			return super.labelPaint(node, labelInx);
@@ -355,68 +271,11 @@
 		final long key = (((long) node) << 32) | ((long) labelInx);
 
 		if ((paint == null) || paint.equals(super.labelPaint(node, labelInx)))
-			m_labelPaints.remove(Long.valueOf(key));
+			m_labelPaints.remove(new Long(key));
 		else
-			m_labelPaints.put(Long.valueOf(key), paint);
+			m_labelPaints.put(new Long(key), paint);
 	}
 
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @param node DOCUMENT ME!
-	 *
-	 * @return DOCUMENT ME!
-	 */
-	@Deprecated public int graphicCount(int node) {
-		final DNodeView nv = (DNodeView) m_view.getNodeView(~node);
-
-		return nv.getCustomGraphicCount();
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @param node DOCUMENT ME!
-	 * @param inx DOCUMENT ME!
-	 *
-	 * @return DOCUMENT ME!
-	 */
-	@Deprecated public Shape graphicShape(int node, int inx) {
-		final DNodeView nv = (DNodeView) m_view.getNodeView(~node);
-
-		return nv.getCustomGraphicShape(inx);
-	}
-
-	/**
-	 * DOCUMENT ME!
-	 *
-	 * @param node DOCUMENT ME!
-	 * @param inx DOCUMENT ME!
-	 *
-	 * @return DOCUMENT ME!
-	 */
-	@Deprecated public Paint graphicPaint(int node, int inx) {
-		final DNodeView nv = (DNodeView) m_view.getNodeView(~node);
-
-		return nv.getCustomGraphicPaint(inx);
-	}
-    // overrides NodeDetails.customGraphicCount():
-    public int customGraphicCount(final int node) {
-	final DNodeView dnv = (DNodeView) m_view.getNodeView(~node);	
-	return dnv.getNumCustomGraphics();
-    }
-
-    // overrides NodeDetails.customGraphics():
-    public Iterator<CustomGraphic> customGraphics (final int node) {
-	final DNodeView dnv = (DNodeView) m_view.getNodeView(~node);
-	return dnv.customGraphicIterator();
-    }
-    // overrides NodeDetails.customGraphicLock():
-    public Object customGraphicLock (final int node) {
-	final DNodeView dnv = (DNodeView) m_view.getNodeView(~node);
-	return dnv.customGraphicLock();	
-    }
-
 	// label positioning
 	/**
 	 *  DOCUMENT ME!
@@ -427,7 +286,7 @@
 	 * @return  DOCUMENT ME!
 	 */
 	public byte labelTextAnchor(final int node, final int labelInx) {
-		final Object o = m_labelTextAnchors.get(Integer.valueOf(node));
+		final Object o = m_labelTextAnchors.get(new Integer(node));
 
 		if (o == null)
 			return super.labelTextAnchor(node, labelInx);
@@ -437,9 +296,9 @@
 
 	void overrideLabelTextAnchor(final int node, final int inx, final int anchor) {
 		if (convertG2ND(anchor) == super.labelTextAnchor(node, inx))
-			m_labelTextAnchors.remove(Integer.valueOf(node));
+			m_labelTextAnchors.remove(new Integer(node));
 		else
-			m_labelTextAnchors.put(Integer.valueOf(node), Integer.valueOf(anchor));
+			m_labelTextAnchors.put(new Integer(node), new Integer(anchor));
 	}
 
 	/**
@@ -451,7 +310,7 @@
 	 * @return  DOCUMENT ME!
 	 */
 	public byte labelNodeAnchor(final int node, final int labelInx) {
-		final Object o = m_labelNodeAnchors.get(Integer.valueOf(node));
+		final Object o = m_labelNodeAnchors.get(new Integer(node));
 
 		if (o == null)
 			return super.labelNodeAnchor(node, labelInx);
@@ -461,9 +320,9 @@
 
 	void overrideLabelNodeAnchor(final int node, final int inx, final int anchor) {
 		if (convertG2ND(anchor) == super.labelNodeAnchor(node, inx))
-			m_labelNodeAnchors.remove(Integer.valueOf(node));
+			m_labelNodeAnchors.remove(new Integer(node));
 		else
-			m_labelNodeAnchors.put(Integer.valueOf(node), Integer.valueOf(anchor));
+			m_labelNodeAnchors.put(new Integer(node), new Integer(anchor));
 	}
 
 	/**
@@ -475,7 +334,7 @@
 	 * @return  DOCUMENT ME!
 	 */
 	public float labelOffsetVectorX(final int node, final int labelInx) {
-		final Object o = m_labelOffsetXs.get(Integer.valueOf(node));
+		final Object o = m_labelOffsetXs.get(new Integer(node));
 
 		if (o == null)
 			return super.labelOffsetVectorX(node, labelInx);
@@ -485,9 +344,9 @@
 
 	void overrideLabelOffsetVectorX(final int node, final int inx, final double x) {
 		if (((float) x) == super.labelOffsetVectorX(node, inx))
-			m_labelOffsetXs.remove(Integer.valueOf(node));
+			m_labelOffsetXs.remove(new Integer(node));
 		else
-			m_labelOffsetXs.put(Integer.valueOf(node), new Double(x));
+			m_labelOffsetXs.put(new Integer(node), new Double(x));
 	}
 
 	/**
@@ -499,7 +358,7 @@
 	 * @return  DOCUMENT ME!
 	 */
 	public float labelOffsetVectorY(final int node, final int labelInx) {
-		final Object o = m_labelOffsetYs.get(Integer.valueOf(node));
+		final Object o = m_labelOffsetYs.get(new Integer(node));
 
 		if (o == null)
 			return super.labelOffsetVectorY(node, labelInx);
@@ -509,9 +368,9 @@
 
 	void overrideLabelOffsetVectorY(final int node, final int inx, final double y) {
 		if (((float) y) == super.labelOffsetVectorY(node, inx))
-			m_labelOffsetYs.remove(Integer.valueOf(node));
+			m_labelOffsetYs.remove(new Integer(node));
 		else
-			m_labelOffsetYs.put(Integer.valueOf(node), new Double(y));
+			m_labelOffsetYs.put(new Integer(node), new Double(y));
 	}
 
 	/**
@@ -523,7 +382,7 @@
 	 * @return  DOCUMENT ME!
 	 */
 	public byte labelJustify(final int node, final int labelInx) {
-		final Object o = m_labelJustifys.get(Integer.valueOf(node));
+		final Object o = m_labelJustifys.get(new Integer(node));
 
 		if (o == null)
 			return super.labelJustify(node, labelInx);
@@ -533,9 +392,9 @@
 
 	void overrideLabelJustify(final int node, final int inx, final int justify) {
 		if (convertG2ND(justify) == super.labelJustify(node, inx))
-			m_labelJustifys.remove(Integer.valueOf(node));
+			m_labelJustifys.remove(new Integer(node));
 		else
-			m_labelJustifys.put(Integer.valueOf(node), Integer.valueOf(justify));
+			m_labelJustifys.put(new Integer(node), new Integer(justify));
 	}
 
 	static byte convertG2ND(int giny) {
Index: view/src/main/java/org/cytoscape/view/impl/DGraphView.java
===================================================================
--- view/src/main/java/org/cytoscape/view/impl/DGraphView.java	(.../trunk)	(revision 14573)
+++ view/src/main/java/org/cytoscape/view/impl/DGraphView.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -526,7 +526,7 @@
 			while (elms.numRemaining() > 0)
 				// GINY requires all node indices to be negative (why?), 
 				// hence the bitwise complement here.
-				returnThis.add(m_nodeViewMap.get(Integer.valueOf(~elms.nextInt())).getNode());
+				returnThis.add(m_nodeViewMap.get(new Integer(~elms.nextInt())).getNode());
 
 			return returnThis;
 		}
@@ -562,7 +562,7 @@
 			final ArrayList<Edge> returnThis = new ArrayList<Edge>();
 
 			while (elms.numRemaining() > 0)
-				returnThis.add(m_edgeViewMap.get(Integer.valueOf(~elms.nextInt())).getEdge());
+				returnThis.add(m_edgeViewMap.get(new Integer(~elms.nextInt())).getEdge());
 
 			return returnThis;
 		}
@@ -599,7 +599,7 @@
 				m_backgroundCanvas.setBackground((Color) paint);
 				m_contentChanged = true;
 			} else {
-				System.out.println("DGraphView.setBackgroundPaint(), Color not found!");
+				System.out.println("DGraphView.setBackgroundPaint(), Color not found!: "+paint);
 			}
 		}
 	}
@@ -637,7 +637,7 @@
 			newView = addNodeViewInternal(nodeInx);
 
 			if (newView == null) {
-				return (NodeView) m_nodeViewMap.get(Integer.valueOf(nodeInx));
+				return (NodeView) m_nodeViewMap.get(new Integer(nodeInx));
 			}
 
 			m_contentChanged = true;
@@ -659,7 +659,7 @@
 	 * Should synchronize around m_lock.
 	 */
 	private NodeView addNodeViewInternal(int nodeInx) {
-		final NodeView oldView = (NodeView) m_nodeViewMap.get(Integer.valueOf(nodeInx));
+		final NodeView oldView = (NodeView) m_nodeViewMap.get(new Integer(nodeInx));
 
 		if (oldView != null) {
 			return null;
@@ -678,7 +678,7 @@
 
 		final NodeView newView;
 		newView = new DNodeView(this, nodeInx);
-		m_nodeViewMap.put(Integer.valueOf(nodeInx), newView);
+		m_nodeViewMap.put(new Integer(nodeInx), newView);
 		m_spacial.insert(~nodeInx, m_defaultNodeXMin, m_defaultNodeYMin, m_defaultNodeXMax,
 		                 m_defaultNodeYMax);
 
@@ -698,7 +698,7 @@
 		EdgeView edgeView = null;
 
 		synchronized (m_lock) {
-			final EdgeView oldView = (EdgeView) m_edgeViewMap.get(Integer.valueOf(edgeInx));
+			final EdgeView oldView = (EdgeView) m_edgeViewMap.get(new Integer(edgeInx));
 
 			if (oldView != null) {
 				return oldView;
@@ -724,7 +724,7 @@
 
 			m_structPersp.restoreEdge(edgeInx);
 			edgeView = new DEdgeView(this, edgeInx);
-			m_edgeViewMap.put(Integer.valueOf(edgeInx), edgeView);
+			m_edgeViewMap.put(new Integer(edgeInx), edgeView);
 			m_contentChanged = true;
 		}
 
@@ -843,7 +843,7 @@
 			for (int i = 0; i < hiddenEdgeInx.length; i++)
 				removeEdgeViewInternal(hiddenEdgeInx[i]);
 
-			returnThis = (DNodeView) m_nodeViewMap.remove(Integer.valueOf(nodeInx));
+			returnThis = (DNodeView) m_nodeViewMap.remove(new Integer(nodeInx));
 			returnThis.unselectInternal();
 
 			// If this node was hidden, it won't be in m_drawPersp.
@@ -933,7 +933,7 @@
 	 * Should synchronize around m_lock.
 	 */
 	private DEdgeView removeEdgeViewInternal(int edgeInx) {
-		final DEdgeView returnThis = (DEdgeView) m_edgeViewMap.remove(Integer.valueOf(edgeInx));
+		final DEdgeView returnThis = (DEdgeView) m_edgeViewMap.remove(new Integer(edgeInx));
 
 		if (returnThis == null) {
 			return returnThis;
@@ -1104,7 +1104,7 @@
 	 */
 	public NodeView getNodeView(int nodeInx) {
 		synchronized (m_lock) {
-			return (NodeView) m_nodeViewMap.get(Integer.valueOf(nodeInx));
+			return (NodeView) m_nodeViewMap.get(new Integer(nodeInx));
 		}
 	}
 
@@ -1210,7 +1210,7 @@
 	 */
 	public EdgeView getEdgeView(int edgeInx) {
 		synchronized (m_lock) {
-			return (EdgeView) m_edgeViewMap.get(Integer.valueOf(edgeInx));
+			return (EdgeView) m_edgeViewMap.get(new Integer(edgeInx));
 		}
 	}
 
@@ -1318,7 +1318,7 @@
 				}
 
 				for (int i = 0; i < edges.length; i++)
-					hideGraphObjectInternal(m_edgeViewMap.get(Integer.valueOf(edges[i])), false);
+					hideGraphObjectInternal(m_edgeViewMap.get(new Integer(edges[i])), false);
 
 				nView.unselectInternal();
 				m_spacial.exists(~nodeInx, m_extentsBuff, 0);
@@ -2210,7 +2210,7 @@
 	public void drawSnapshot(Image img, GraphLOD lod, Paint bgPaint, double xCenter,
 	                         double yCenter, double scaleFactor) {
 		synchronized (m_lock) {
-			GraphRenderer.renderGraph((FixedGraph) m_drawPersp, m_spacial, lod, m_nodeDetails,
+			GraphRenderer.renderGraph((FixedGraph) m_drawPersp, this, m_spacial, lod, m_nodeDetails,
 			                          m_edgeDetails, m_hash, new GraphGraphics(img, false),
 			                          bgPaint, xCenter, yCenter, scaleFactor);
 		}
Index: view/src/main/java/org/cytoscape/view/impl/InnerCanvas.java
===================================================================
--- view/src/main/java/org/cytoscape/view/impl/InnerCanvas.java	(.../trunk)	(revision 14573)
+++ view/src/main/java/org/cytoscape/view/impl/InnerCanvas.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -267,7 +267,7 @@
 
 		synchronized (m_lock) {
 			if (m_view.m_contentChanged || m_view.m_viewportChanged) {
-				m_lastRenderDetail = GraphRenderer.renderGraph((FixedGraph) m_view.m_drawPersp,
+				m_lastRenderDetail = GraphRenderer.renderGraph((FixedGraph) m_view.m_drawPersp, m_view,
 				                                               m_view.m_spacial, m_lod[0],
 				                                               m_view.m_nodeDetails,
 				                                               m_view.m_edgeDetails, m_hash,
@@ -334,7 +334,7 @@
 										  m_backgroundColor.getBlue(), alpha);
 
 		synchronized (m_lock) {
-			GraphRenderer.renderGraph((FixedGraph) m_view.m_drawPersp, m_view.m_spacial,
+			GraphRenderer.renderGraph((FixedGraph) m_view.m_drawPersp, m_view, m_view.m_spacial,
 			                          m_view.m_printLOD, m_view.m_nodeDetails,
 			                          m_view.m_edgeDetails, m_hash, new GraphGraphics(img, false),
 			                          backgroundColor, m_xCenter, m_yCenter, m_scaleFactor);
@@ -355,7 +355,7 @@
 										  m_backgroundColor.getBlue(), alpha);
 
 		synchronized (m_lock) {
-			GraphRenderer.renderGraph((FixedGraph) m_view.m_drawPersp, m_view.m_spacial,
+			GraphRenderer.renderGraph((FixedGraph) m_view.m_drawPersp, m_view, m_view.m_spacial,
 			                          m_view.m_printLOD, m_view.m_nodeDetails,
 			                          m_view.m_edgeDetails, m_hash, new GraphGraphics(img, false),
 			                          backgroundColor, m_xCenter, m_yCenter, m_scaleFactor);
@@ -1373,12 +1373,19 @@
 	protected synchronized void processNodeContextMenuEvent(MouseEvent event) {
 		NodeView nv = m_view.getPickedNodeView(event.getPoint());
 
+		//         System.out.println ("   over selected nodeview: " + nv);
 		if (nv != null) {
 			String nodeLabel = nv.getNode().getIdentifier();
 			JPopupMenu menu = new JPopupMenu(nodeLabel);
 			menu.setLabel(nodeLabel);
 
-			for ( NodeContextMenuListener l : nodeContextMenuListeners ) {
+			Enumeration e = nodeContextMenuListeners.elements();
+
+			while (e.hasMoreElements()) {
+				NodeContextMenuListener l = (NodeContextMenuListener) e.nextElement();
+				System.out.println("Adding context menu items for NodeContextMenuListener: " + l);
+
+				//                              EventListener l = (EventListener) e.nextElement();
 				l.addNodeContextMenuItems(nv, menu);
 			}
 
@@ -1395,7 +1402,11 @@
 			JPopupMenu menu = new JPopupMenu(edgeLabel);
 			menu.setLabel(edgeLabel);
 
-			for ( EdgeContextMenuListener l : edgeContextMenuListeners ) {	
+			Enumeration e = edgeContextMenuListeners.elements();
+
+			while (e.hasMoreElements()) {
+				EdgeContextMenuListener l = (EdgeContextMenuListener) e.nextElement();
+				System.out.println("Adding context menu items for EdgeContextMenuListener: " + l);
 				l.addEdgeContextMenuItems(ev, menu);
 			}
 
Index: view/src/main/java/org/cytoscape/view/impl/InternalFrameComponent.java
===================================================================
--- view/src/main/java/org/cytoscape/view/impl/InternalFrameComponent.java	(.../trunk)	(revision 14573)
+++ view/src/main/java/org/cytoscape/view/impl/InternalFrameComponent.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -194,8 +194,8 @@
 		layeredPane.removeAll();
 
 		// foreground followed by network followed by background
-		layeredPane.add(backgroundCanvas, Integer.valueOf(ZOrder.BACKGROUND_PANE.layer()));
-		layeredPane.add(networkCanvas, Integer.valueOf(ZOrder.NETWORK_PANE.layer()));
-		layeredPane.add(foregroundCanvas, Integer.valueOf(ZOrder.FOREGROUND_PANE.layer()));
+		layeredPane.add(backgroundCanvas, new Integer(ZOrder.BACKGROUND_PANE.layer()));
+		layeredPane.add(networkCanvas, new Integer(ZOrder.NETWORK_PANE.layer()));
+		layeredPane.add(foregroundCanvas, new Integer(ZOrder.FOREGROUND_PANE.layer()));
 	}
 }
Index: view/src/main/java/org/cytoscape/view/impl/DEdgeDetails.java
===================================================================
--- view/src/main/java/org/cytoscape/view/impl/DEdgeDetails.java	(.../trunk)	(revision 14573)
+++ view/src/main/java/org/cytoscape/view/impl/DEdgeDetails.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -78,7 +78,7 @@
 		if ((o != null) && (o != m_deletedEntry))
 			m_colorsLowDetail.put(edge, m_deletedEntry);
 
-		final Integer key = Integer.valueOf(edge);
+		final Integer key = new Integer(edge);
 		m_segmentThicknesses.remove(key);
 		m_sourceArrows.remove(key);
 		m_sourceArrowPaints.remove(key);
@@ -129,7 +129,7 @@
 	 * @return DOCUMENT ME!
 	 */
 	public byte sourceArrow(int edge) {
-		final Object o = m_sourceArrows.get(Integer.valueOf(edge));
+		final Object o = m_sourceArrows.get(new Integer(edge));
 
 		if (o == null)
 			return super.sourceArrow(edge);
@@ -143,9 +143,9 @@
 	 */
 	void overrideSourceArrow(int edge, byte arrowType) {
 		if ((arrowType >= 0) || (arrowType == super.sourceArrow(edge)))
-			m_sourceArrows.remove(Integer.valueOf(edge));
+			m_sourceArrows.remove(new Integer(edge));
 		else
-			m_sourceArrows.put(Integer.valueOf(edge), new Byte(arrowType));
+			m_sourceArrows.put(new Integer(edge), new Byte(arrowType));
 	}
 
 	/**
@@ -156,7 +156,7 @@
 	 * @return DOCUMENT ME!
 	 */
 	public Paint sourceArrowPaint(int edge) {
-		final Object o = m_sourceArrowPaints.get(Integer.valueOf(edge));
+		final Object o = m_sourceArrowPaints.get(new Integer(edge));
 
 		if (o == null)
 			return super.sourceArrowPaint(edge);
@@ -169,9 +169,9 @@
 	 */
 	void overrideSourceArrowPaint(int edge, Paint paint) {
 		if ((paint == null) || paint.equals(super.sourceArrowPaint(edge)))
-			m_sourceArrowPaints.remove(Integer.valueOf(edge));
+			m_sourceArrowPaints.remove(new Integer(edge));
 		else
-			m_sourceArrowPaints.put(Integer.valueOf(edge), paint);
+			m_sourceArrowPaints.put(new Integer(edge), paint);
 	}
 
 	/**
@@ -182,7 +182,7 @@
 	 * @return DOCUMENT ME!
 	 */
 	public byte targetArrow(int edge) {
-		final Object o = m_targetArrows.get(Integer.valueOf(edge));
+		final Object o = m_targetArrows.get(new Integer(edge));
 
 		if (o == null)
 			return super.targetArrow(edge);
@@ -196,9 +196,9 @@
 	 */
 	void overrideTargetArrow(int edge, byte arrowType) {
 		if ((arrowType >= 0) || (arrowType == super.targetArrow(edge)))
-			m_targetArrows.remove(Integer.valueOf(edge));
+			m_targetArrows.remove(new Integer(edge));
 		else
-			m_targetArrows.put(Integer.valueOf(edge), new Byte(arrowType));
+			m_targetArrows.put(new Integer(edge), new Byte(arrowType));
 	}
 
 	/**
@@ -209,7 +209,7 @@
 	 * @return DOCUMENT ME!
 	 */
 	public Paint targetArrowPaint(int edge) {
-		final Object o = m_targetArrowPaints.get(Integer.valueOf(edge));
+		final Object o = m_targetArrowPaints.get(new Integer(edge));
 
 		if (o == null)
 			return super.targetArrowPaint(edge);
@@ -222,9 +222,9 @@
 	 */
 	void overrideTargetArrowPaint(int edge, Paint paint) {
 		if ((paint == null) || paint.equals(super.targetArrowPaint(edge)))
-			m_targetArrowPaints.remove(Integer.valueOf(edge));
+			m_targetArrowPaints.remove(new Integer(edge));
 		else
-			m_targetArrowPaints.put(Integer.valueOf(edge), paint);
+			m_targetArrowPaints.put(new Integer(edge), paint);
 	}
 
 	private final MinIntHeap m_heap = new MinIntHeap();
@@ -402,7 +402,7 @@
 	 * @return DOCUMENT ME!
 	 */
 	public float segmentThickness(int edge) {
-		final Object o = m_segmentThicknesses.get(Integer.valueOf(edge));
+		final Object o = m_segmentThicknesses.get(new Integer(edge));
 
 		if (o == null)
 			return super.segmentThickness(edge);
@@ -416,9 +416,9 @@
 	 */
 	void overrideSegmentThickness(int edge, float thickness) {
 		if ((thickness < 0.0f) || (thickness == super.segmentThickness(edge)))
-			m_segmentThicknesses.remove(Integer.valueOf(edge));
+			m_segmentThicknesses.remove(new Integer(edge));
 		else
-			m_segmentThicknesses.put(Integer.valueOf(edge), new Float(thickness));
+			m_segmentThicknesses.put(new Integer(edge), new Float(thickness));
 	}
 
 	/**
@@ -429,7 +429,7 @@
 	 * @return DOCUMENT ME!
 	 */
 	public Paint segmentPaint(int edge) {
-		final Object o = m_segmentPaints.get(Integer.valueOf(edge));
+		final Object o = m_segmentPaints.get(new Integer(edge));
 
 		if (o == null)
 			return super.segmentPaint(edge);
@@ -442,9 +442,9 @@
 	 */
 	void overrideSegmentPaint(int edge, Paint paint) {
 		if ((paint == null) || paint.equals(super.segmentPaint(edge)))
-			m_segmentPaints.remove(Integer.valueOf(edge));
+			m_segmentPaints.remove(new Integer(edge));
 		else
-			m_segmentPaints.put(Integer.valueOf(edge), paint);
+			m_segmentPaints.put(new Integer(edge), paint);
 	}
 
 	/**
@@ -455,7 +455,7 @@
 	 * @return DOCUMENT ME!
 	 */
 	public float segmentDashLength(int edge) {
-		final Object o = m_segmentDashLengths.get(Integer.valueOf(edge));
+		final Object o = m_segmentDashLengths.get(new Integer(edge));
 
 		if (o == null)
 			return super.segmentDashLength(edge);
@@ -469,9 +469,9 @@
 	 */
 	void overrideSegmentDashLength(int edge, float length) {
 		if ((length < 0.0f) || (length == super.segmentDashLength(edge)))
-			m_segmentDashLengths.remove(Integer.valueOf(edge));
+			m_segmentDashLengths.remove(new Integer(edge));
 		else
-			m_segmentDashLengths.put(Integer.valueOf(edge), new Float(length));
+			m_segmentDashLengths.put(new Integer(edge), new Float(length));
 	}
 
 	/**
@@ -482,7 +482,7 @@
 	 * @return DOCUMENT ME!
 	 */
 	public int labelCount(int edge) {
-		final Object o = m_labelCounts.get(Integer.valueOf(edge));
+		final Object o = m_labelCounts.get(new Integer(edge));
 
 		if (o == null)
 			return super.labelCount(edge);
@@ -495,9 +495,9 @@
 	 */
 	void overrideLabelCount(int edge, int labelCount) {
 		if ((labelCount < 0) || (labelCount == super.labelCount(edge)))
-			m_labelCounts.remove(Integer.valueOf(edge));
+			m_labelCounts.remove(new Integer(edge));
 		else
-			m_labelCounts.put(Integer.valueOf(edge), Integer.valueOf(labelCount));
+			m_labelCounts.put(new Integer(edge), new Integer(labelCount));
 	}
 
 	/**
@@ -510,7 +510,7 @@
 	 */
 	public String labelText(int edge, int labelInx) {
 		final long key = (((long) edge) << 32) | ((long) labelInx);
-		final String o = m_labelTexts.get(Long.valueOf(key));
+		final String o = m_labelTexts.get(new Long(key));
 
 		if (o == null)
 			return super.labelText(edge, labelInx);
@@ -525,9 +525,9 @@
 		final long key = (((long) edge) << 32) | ((long) labelInx);
 
 		if ((text == null) || text.equals(super.labelText(edge, labelInx)))
-			m_labelTexts.remove(Long.valueOf(key));
+			m_labelTexts.remove(new Long(key));
 		else
-			m_labelTexts.put(Long.valueOf(key), text);
+			m_labelTexts.put(new Long(key), text);
 	}
 
 	/**
@@ -540,7 +540,7 @@
 	 */
 	public Font labelFont(int edge, int labelInx) {
 		final long key = (((long) edge) << 32) | ((long) labelInx);
-		final Font o = m_labelFonts.get(Long.valueOf(key));
+		final Font o = m_labelFonts.get(new Long(key));
 
 		if (o == null)
 			return super.labelFont(edge, labelInx);
@@ -555,9 +555,9 @@
 		final long key = (((long) edge) << 32) | ((long) labelInx);
 
 		if ((font == null) || font.equals(super.labelFont(edge, labelInx)))
-			m_labelFonts.remove(Long.valueOf(key));
+			m_labelFonts.remove(new Long(key));
 		else
-			m_labelFonts.put(Long.valueOf(key), font);
+			m_labelFonts.put(new Long(key), font);
 	}
 
 	/**
@@ -570,7 +570,7 @@
 	 */
 	public Paint labelPaint(int edge, int labelInx) {
 		final long key = (((long) edge) << 32) | ((long) labelInx);
-		final Paint o = m_labelPaints.get(Long.valueOf(key));
+		final Paint o = m_labelPaints.get(new Long(key));
 
 		if (o == null)
 			return super.labelPaint(edge, labelInx);
@@ -585,9 +585,9 @@
 		final long key = (((long) edge) << 32) | ((long) labelInx);
 
 		if ((paint == null) || paint.equals(super.labelPaint(edge, labelInx)))
-			m_labelPaints.remove(Long.valueOf(key));
+			m_labelPaints.remove(new Long(key));
 		else
-			m_labelPaints.put(Long.valueOf(key), paint);
+			m_labelPaints.put(new Long(key), paint);
 	}
 
 	/**
Index: view/src/main/java/org/cytoscape/view/impl/DNodeView.java
===================================================================
--- view/src/main/java/org/cytoscape/view/impl/DNodeView.java	(.../trunk)	(revision 14573)
+++ view/src/main/java/org/cytoscape/view/impl/DNodeView.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -37,7 +37,6 @@
 package org.cytoscape.view.impl;
 
 import cytoscape.render.immed.GraphGraphics;
-import cytoscape.render.stateful.CustomGraphic;
 import cytoscape.render.stateful.NodeDetails;
 
 
@@ -49,6 +48,7 @@
 import org.cytoscape.view.Label;
 import org.cytoscape.view.NodeView;
 import org.cytoscape.view.EdgeView;
+import org.cytoscape.view.renderers.NodeRenderer;
 
 import java.awt.AlphaComposite;
 import java.awt.BasicStroke;
@@ -65,6 +65,7 @@
 
 import java.util.ArrayList;
 import java.util.HashSet;
+import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.List;
@@ -89,7 +90,9 @@
 	Paint m_unselectedPaint;
 	Paint m_selectedPaint;
 	Paint m_borderPaint;
-
+	NodeRenderer m_renderer;
+	
+	public HashMap<String, Object>visualAttributes;
 	/**
 	 * Stores the position of a nodeView when it's hidden so that when the 
 	 * nodeView is retored we can restore the view into the same position.
@@ -105,19 +108,6 @@
 	// AJK: 04/26/06 for tooltip
 	String m_toolTipText = null;
 	
-    // A LinkedHashSet of the custom graphics associated with this
-    // DNodeView.  We need the HashSet linked since the ordering of
-    // custom graphics is important.  For space considerations, we
-    // keep _customGraphics null when there are no custom
-    // graphics--event though this is a bit more complicated:
-    private LinkedHashSet<CustomGraphic> _customGraphics;
-    // CG_LOCK is used for synchronizing custom graphics operations on this DNodeView.
-    // Arrays are objects like any other and can be used for synchronization. We use an array
-    // object assuming it takes up the least amount of memory:
-    private final Object[] CG_LOCK = new Object[0];
-    private final static HashSet<CustomGraphic> EMPTY_CUSTOM_GRAPHICS = new LinkedHashSet<CustomGraphic>(0);
-
-
 	/*
 	 * @param inx the RootGraph index of node (a negative number).
 	 */
@@ -125,13 +115,24 @@
 		m_view = view;
 		m_inx = ~inx;
 		m_selected = false;
-		m_unselectedPaint = m_view.m_nodeDetails.fillPaint(m_inx);
+		m_unselectedPaint = Color.red;
 		m_selectedPaint = Color.yellow;
 		m_borderPaint = m_view.m_nodeDetails.borderPaint(m_inx);
 		m_graphicShapes = null;
 		m_graphicPaints = null;
+		m_renderer = null;
+		visualAttributes = new HashMap<String, Object>();
+		/* default values -- FIXME: should be somewhere else */
+		visualAttributes.put("selectedPaint", Color.orange);
+		visualAttributes.put("unselectedPaint", Color.blue);
+		visualAttributes.put("borderWidth", new Double(0.1));
+		visualAttributes.put("borderPaint", Color.green);
+		visualAttributes.put("borderStroke", new BasicStroke((float) 0.1));
 	}
 
+	public HashMap<String, Object> getVisualAttributes(){
+		return visualAttributes;
+	}
 	/**
 	 * DOCUMENT ME!
 	 *
@@ -196,27 +197,20 @@
 		}
 	}
 
+	public NodeRenderer getRenderer(){
+		return m_renderer;
+	}
+	
+	public void setRenderer(NodeRenderer renderer){
+		m_renderer = renderer;
+	}
 	/**
 	 * DOCUMENT ME!
 	 *
 	 * @param paint DOCUMENT ME!
 	 */
 	public void setSelectedPaint(Paint paint) {
-		synchronized (m_view.m_lock) {
-			if (paint == null)
-				throw new NullPointerException("paint is null");
-
-			m_selectedPaint = paint;
-
-			if (isSelected()) {
-				m_view.m_nodeDetails.overrideFillPaint(m_inx, m_selectedPaint);
-
-				if (m_selectedPaint instanceof Color)
-					m_view.m_nodeDetails.overrideColorLowDetail(m_inx, (Color) m_selectedPaint);
-
-				m_view.m_contentChanged = true;
-			}
-		}
+		visualAttributes.put("selectedPaint", paint);
 	}
 
 	/**
@@ -225,7 +219,7 @@
 	 * @return DOCUMENT ME!
 	 */
 	public Paint getSelectedPaint() {
-		return m_selectedPaint;
+		return (Paint) visualAttributes.get("selectedPaint");
 	}
 
 	/**
@@ -234,21 +228,7 @@
 	 * @param paint DOCUMENT ME!
 	 */
 	public void setUnselectedPaint(Paint paint) {
-		synchronized (m_view.m_lock) {
-			if (paint == null)
-				throw new NullPointerException("paint is null");
-
-			m_unselectedPaint = paint;
-
-			if (!isSelected()) {
-				m_view.m_nodeDetails.overrideFillPaint(m_inx, m_unselectedPaint);
-
-				if (m_unselectedPaint instanceof Color)
-					m_view.m_nodeDetails.overrideColorLowDetail(m_inx, (Color) m_unselectedPaint);
-
-				m_view.m_contentChanged = true;
-			}
-		}
+		visualAttributes.put("unselectedPaint", paint);
 	}
 
 	/**
@@ -257,7 +237,7 @@
 	 * @return DOCUMENT ME!
 	 */
 	public Paint getUnselectedPaint() {
-		return m_unselectedPaint;
+		return (Paint) visualAttributes.get("unselectedPaint");
 	}
 
 	/**
@@ -266,11 +246,8 @@
 	 * @param paint DOCUMENT ME!
 	 */
 	public void setBorderPaint(Paint paint) {
-		synchronized (m_view.m_lock) {
-			m_borderPaint = paint;
-			fixBorder();
-			m_view.m_contentChanged = true;
-		}
+		visualAttributes.put("borderPaint", paint);
+		//m_view.m_contentChanged = true; // TODO
 	}
 
 	/**
@@ -279,7 +256,7 @@
 	 * @return DOCUMENT ME!
 	 */
 	public Paint getBorderPaint() {
-		return m_borderPaint;
+		return (Paint)visualAttributes.get("borderPaint");
 	}
 
 	/**
@@ -288,10 +265,7 @@
 	 * @param width DOCUMENT ME!
 	 */
 	public void setBorderWidth(float width) {
-		synchronized (m_view.m_lock) {
-			m_view.m_nodeDetails.overrideBorderWidth(m_inx, width);
-			m_view.m_contentChanged = true;
-		}
+		visualAttributes.put("borderWidth", new Double(width));
 	}
 
 	/**
@@ -300,9 +274,7 @@
 	 * @return DOCUMENT ME!
 	 */
 	public float getBorderWidth() {
-		synchronized (m_view.m_lock) {
-			return m_view.m_nodeDetails.borderWidth(m_inx);
-		}
+		return ((Double) visualAttributes.get("borderWidth")).floatValue();
 	}
 
 	/**
@@ -311,71 +283,16 @@
 	 * @param stroke DOCUMENT ME!
 	 */
 	public void setBorder(Stroke stroke) {
-		if (stroke instanceof BasicStroke) {
-			synchronized (m_view.m_lock) {
-				setBorderWidth(((BasicStroke) stroke).getLineWidth());
-
-				final float[] dashArray = ((BasicStroke) stroke).getDashArray();
-
-				if ((dashArray != null) && (dashArray.length > 1)) {
-					m_borderDash = dashArray[0];
-					m_borderDash2 = dashArray[1];
-				} else {
-					m_borderDash = 0.0f;
-					m_borderDash2 = 0.0f;
-				}
-
-				fixBorder();
-			}
-		}
+		visualAttributes.put("borderStroke", stroke);
 	}
 
-	private float m_borderDash = 0.0f;
-	private float m_borderDash2 = 0.0f;
-	private final static Color s_transparent = new Color(0, 0, 0, 0);
-
-	// Callers of this method must be holding m_view.m_lock.
-	private void fixBorder() {
-		if ((m_borderDash == 0.0f) && (m_borderDash2 == 0.0f))
-			m_view.m_nodeDetails.overrideBorderPaint(m_inx, m_borderPaint);
-		else {
-			final int size = (int) Math.max(1.0f, (int) (m_borderDash + m_borderDash2)); // Average times two.
-
-			if ((size == m_view.m_lastSize) && (m_borderPaint == m_view.m_lastPaint)) {
-				/* Use the cached texture paint. */ } else {
-				final BufferedImage img = new BufferedImage(size, size, BufferedImage.TYPE_INT_ARGB);
-				final Graphics2D g2 = (Graphics2D) img.getGraphics();
-				g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC));
-				g2.setPaint(s_transparent);
-				g2.fillRect(0, 0, size, size);
-				g2.setPaint(m_borderPaint);
-				g2.fillRect(0, 0, size / 2, size / 2);
-				g2.fillRect(size / 2, size / 2, size / 2, size / 2);
-				m_view.m_lastTexturePaint = new TexturePaint(img,
-				                                             new Rectangle2D.Double(0, 0, size, size));
-				m_view.m_lastSize = size;
-				m_view.m_lastPaint = m_borderPaint;
-			}
-
-			m_view.m_nodeDetails.overrideBorderPaint(m_inx, m_view.m_lastTexturePaint);
-		}
-	}
-
 	/**
 	 * DOCUMENT ME!
 	 *
 	 * @return DOCUMENT ME!
 	 */
 	public Stroke getBorder() {
-		synchronized (m_view.m_lock) {
-			if ((m_borderDash == 0.0f) && (m_borderDash2 == 0.0f))
-				return new BasicStroke(getBorderWidth());
-			else
-
-				return new BasicStroke(getBorderWidth(), BasicStroke.CAP_SQUARE,
-				                       BasicStroke.JOIN_MITER, 10.0f,
-				                       new float[] { m_borderDash, m_borderDash2 }, 0.0f);
-		}
+		return (Stroke) visualAttributes.get("borderStroke");
 	}
 
 	/**
@@ -699,15 +616,9 @@
 	boolean selectInternal() {
 		if (m_selected)
 			return false;
-
+		
 		m_selected = true;
-		m_view.m_nodeDetails.overrideFillPaint(m_inx, m_selectedPaint);
 
-		if (m_selectedPaint instanceof Color)
-			m_view.m_nodeDetails.overrideColorLowDetail(m_inx, (Color) m_selectedPaint);
-
-		m_view.m_selectedNodes.insert(m_inx);
-
 		return true;
 	}
 
@@ -739,13 +650,7 @@
 			return false;
 
 		m_selected = false;
-		m_view.m_nodeDetails.overrideFillPaint(m_inx, m_unselectedPaint);
 
-		if (m_unselectedPaint instanceof Color)
-			m_view.m_nodeDetails.overrideColorLowDetail(m_inx, (Color) m_unselectedPaint);
-
-		m_view.m_selectedNodes.delete(m_inx);
-
 		return true;
 	}
 
@@ -918,364 +823,14 @@
 			m_view.m_contentChanged = true;
 		}
 	}
-
-	// Custom graphic stuff.
-
-	/**
-	 * Returns the number of custom graphic objects currently set on this
-	 * node view.
-	 * @deprecated use {@link #getNumCustomGraphics() getNumCustomGraphics()}.
-	 * Note that the new API methods work independent of the old API methods.
-	 * See {@link #addCustomGraphic(Shape,Paint,int) addCustomGraphic(Shape,Paint,int)}
-	 * for details.
-	 */
-	@Deprecated public int getCustomGraphicCount() {
-		synchronized (m_view.m_lock) {
-			if (m_graphicShapes == null)
-				return 0;
-
-			return m_graphicShapes.size();
-		}
-	}
-
-	/**
-	 * Returns the shape of the custom graphic object at specified index on
-	 * this node view.  The index parameter must be in the range
-	 * [0, getCustomGraphicCount()-1].
-	 * @deprecated use {@link cytoscape.render.stateful.CustomGraphic#getShape() cytoscape.render.stateful.CustomGraphic.getShape()}.
-	 * Note that the new API methods work independent of the old API methods.
-	 * See {@link #addCustomGraphic(Shape,Paint,int) addCustomGraphic(Shape,Paint,int)}
-	 * for details.
-	 */
-	@Deprecated public Shape getCustomGraphicShape(int index) {
-		synchronized (m_view.m_lock) {
-			return (Shape) m_graphicShapes.get(index);
-		}
-	}
-
-	/**
-	 * Returns the paint on the custom graphic object at specified index on
-	 * this node view.  The index parameter must be in the range
-	 * [0, getCustomGraphicCount()-1].
-	 * @deprecated use {@link cytoscape.render.stateful.CustomGraphic#getPaint() cytoscape.render.stateful.CustomGraphic.getPaint()}.
-	 * Note that the new API methods work independent of the old API methods.
-	 * See {@link #addCustomGraphic(Shape,Paint,int) addCustomGraphic(Shape,Paint,int)}
-	 * for details.
-	 */
-	@Deprecated public Paint getCustomGraphicPaint(int index) {
-		synchronized (m_view.m_lock) {
-			return (Paint) m_graphicPaints.get(index);
-		}
-	}
-
-	/**
-	 * Removes the custom graphic object at specified index.  The index parameter
-	 * must be in the range [0, getCustomGraphicCount()-1].  Once the object
-	 * at specified index is removed, all object remaining and at a higher index
-	 * will be shifted such that their index is decreased by one.
-	 * @deprecated use {@link #removeCustomGraphic(CustomGraphic) removeCustomGraphic(CustomGraphic)}.
-	 * Note that the new API methods work independent of the old API methods.
-	 * See {@link #addCustomGraphic(Shape,Paint,int) addCustomGraphic(Shape,Paint,int)}
-	 * for details.
-	 */
-	@Deprecated public void removeCustomGraphic(int index) {
-		synchronized (m_view.m_lock) {
-			m_graphicShapes.remove(index);
-			m_graphicPaints.remove(index);
-			if (m_graphicShapes.size() == 0) {
-				m_graphicShapes = null;
-				m_graphicPaints = null;
-			}
-
-			m_view.m_contentChanged = true;
-		}
-	}
-
-
-
-    /**
-     * Adds a custom graphic, <EM>in draw order</EM>, to this
-     * DNodeView in a thread-safe way.  This is a convenience method
-     * that is equivalent to calling:
-     * <CODE>
-     *   addCustomGraphic (new CustomGraphic (shape,paint,anchor))
-     * </CODE>
-     * except the the new CustomGraphic created is returned.
-     * @param shape
-     * @param paint
-     * @param anchor The byte value from NodeDetails, that defines where the graphic anchor point lies on this DNodeView's extents rectangle. A common anchor is NodeDetails.ANCHOR_CENTER.
-     * @since Cytoscape 2.6
-     * @throws IllegalArgumentException if shape or paint are null or anchor is not in the range 0 <= anchor <= NodeDetails.MAX_ANCHOR_VAL.
-     * @return The CustomGraphic added to this DNodeView.
-     * @see #addCustomGraphic(CustomGraphic)
-     * @see cytoscape.render.stateful.CustomGraphic
-     */
-      public CustomGraphic addCustomGraphic(Shape shape, Paint paint, byte anchor) {
-	  CustomGraphic cg = new CustomGraphic (shape, paint, anchor);
-	  addCustomGraphic (cg);
-	  return cg;
-      }
-
-    /**
-     * Adds a given CustomGraphic, <EM>in draw order</EM>, to this
-     * DNodeView in a thread-safe way.  Each CustomGraphic will be
-     * drawn in the order is was added. So, if you care about draw
-     * order (as for overlapping graphics), make sure you add them in
-     * the order you desire.  Note that since CustomGraphics may be
-     * added by multiple plugins, your additions may be interleaved
-     * with others.
-     *
-     * <P>A CustomGraphic can only be associated with a DNodeView
-     * once.  If you wish to have a custom graphic, with the same
-     * paint and shape information, occur in multiple places in the
-     * draw order, simply create a new CustomGraphic and add it.
-     *
-     * @since Cytoscape 2.6
-     * @throws IllegalArgumentException if shape or paint are null.
-     * @return true if the CustomGraphic was added to this DNodeView.
-     *         false if this DNodeView already contained this CustomGraphic.
-     * @see cytoscape.render.stateful.CustomGraphic
-     */
-    public boolean addCustomGraphic(CustomGraphic cg) {
-	boolean retVal = false;
-	//	CG_RW_LOCK.writeLock().lock();
-	//	if (_customGraphics == null) {
-	//	    _customGraphics = new LinkedHashSet<CustomGraphic>();
-	//	}
-	//	retVal = _customGraphics.add (cg);
-	//	CG_RW_LOCK.writeLock().unlock();
-	synchronized (CG_LOCK) {
-	    if (_customGraphics == null) {
-		_customGraphics = new LinkedHashSet<CustomGraphic>();
-	    }
-	    retVal = _customGraphics.add (cg);
-	}
-	ensureContentChanged ();
-	return retVal;
-    }
-
-    /**
-     * A thread-safe way to determine if this DNodeView contains a given custom graphic.
-     * @param cg the CustomGraphic for which we are checking containment.
-     * @since Cytoscape 2.6
-     */
-    public boolean containsCustomGraphic (CustomGraphic cg) {
-	//	CG_RW_LOCK.readLock().lock();
-	//	boolean retVal = false;
-	//	if (_customGraphics != null) {
-	//	    retVal = _customGraphics.contains (cg);
-	//	}
-	//	CG_RW_LOCK.readLock().unlock();
-	//	return retVal;
-	synchronized (CG_LOCK) {
-	    if (_customGraphics == null) {
-		return false;
-	    }
-	    return _customGraphics.contains (cg);
-	}
-    }
-
-    /**
-     * Return a non-null, read-only Iterator over all CustomGraphics contained in this DNodeView.
-     * The Iterator will return each CustomGraphic in draw order.
-     * The Iterator cannot be used to modify the underlying set of CustomGraphics.
-     * @return The CustomGraphics Iterator. If no CustomGraphics are
-     * associated with this DNOdeView, an empty Iterator is returned.
-     * @throws UnsupportedOperationException if an attempt is made to use the Iterator's remove() method.
-     * @since Cytoscape 2.6
-     */
-    public Iterator<CustomGraphic> customGraphicIterator() {
-	Iterator<CustomGraphic> retVal = null;
-	final Iterable<CustomGraphic> toIterate;
-	//	CG_RW_LOCK.readLock().lock();	
-	//	if (_customGraphics == null) {
-	//	    toIterate = EMPTY_CUSTOM_GRAPHICS;
-	//	} else {
-	//	    toIterate = _customGraphics;
-	//	}	    
-	//	retVal = new LockingIterator<CustomGraphic>(toIterate);
-	//	retVal = new Iterator<CustomGraphic>() {
-	//	    Iterator<? extends CustomGraphic> i = toIterate.iterator();
-	//	    public boolean hasNext() {return i.hasNext();}
-	//	    public CustomGraphic next() 	 {return i.next();}
-	//	    public void remove() {
-	//		throw new UnsupportedOperationException();
-	//	    }
-	//	};
-	//	CG_RW_LOCK.readLock().unlock();		   
-	//	return retVal;
-	synchronized (CG_LOCK) {
-	    if (_customGraphics == null) {
-		toIterate = EMPTY_CUSTOM_GRAPHICS;
-	    } else {
-		toIterate = _customGraphics;
-	    }
-	    return new ReadOnlyIterator<CustomGraphic>(toIterate);
-	}
-    }
-
-    /**
-     * A thread-safe method for removing a given custom graphic from this DNodeView.
-     * @return true if the custom graphic was found an removed. Returns false if 
-     *         cg is null or is not a custom graphic associated with this DNodeView.
-     * @since Cytoscape 2.6
-     */
-    public boolean removeCustomGraphic(CustomGraphic cg) {
-	boolean retVal = false;
-	//	CG_RW_LOCK.writeLock().lock();
-	//	if (_customGraphics != null) {
-	//	    retVal = _customGraphics.remove (cg);
-	//	}	
-	//	CG_RW_LOCK.writeLock().unlock();
-	synchronized (CG_LOCK) {	
-	    if (_customGraphics != null) {
-		retVal = _customGraphics.remove (cg);
-	    }
-	}
-	ensureContentChanged ();
-	return retVal;
-    }
-
-    /**
-     * A thread-safe method returning the number of custom graphics
-     * associated with this DNodeView. If none are associated, zero is
-     * returned.
-     * @since Cytoscape 2.6
-     */
-    public int getNumCustomGraphics () {
-	//	CG_RW_LOCK.readLock().lock();
-	//	int retVal = 0;
-	//	if (_customGraphics != null) {
-	//	    retVal = _customGraphics.size();
-	//	}
-	//	CG_RW_LOCK.readLock().unlock();
-	//	return retVal;
-	synchronized (CG_LOCK) {
-	    if (_customGraphics == null) {
-		return 0;
-	    }
-	    return _customGraphics.size();
-	}
-    }
-
-    
+   
     private void ensureContentChanged () {
 	synchronized (m_view.m_lock) {
 	    m_view.m_contentChanged = true;
 	}
     }
-    /**
-     * Obtain the lock used for reading information about custom
-     * graphics.  This is <EM>not</EM> needed for thread-safe custom graphic
-     * operations, but only needed for use with
-     * thread-compatible methods, such as customGraphicIterator().
-     * For example, to iterate over all custom graphics without fear of
-     * the underlying custom graphics being mutated, you could perform:
-     * <PRE>
-     *    DNodeView dnv = ...;
-     *    CustomGraphic cg = null;
-     *    synchronized (dnv.customGraphicLock()) {
-     *       Iterator<CustomGraphic> cgIt = dnv.customGraphicIterator();
-     *       while (cgIt.hasNext()) {
-     *          cg = cgIt.next();
-     *          // PERFORM your operations here.
-     *       }
-     *   }
-     * </PRE>
-     * NOTE: A better concurrency approach would be to return the read
-     *       lock from a
-     *       java.util.concurrent.locks.ReentrantReadWriteLock.
-     *       However, this requires users to manually lock and unlock
-     *       blocks of code where many times try{} finally{} blocks
-     *       are needed and if any mistake are made, a DNodeView may be
-     *       permanently locked. Since concurrency will most
-     *       likely be very low, we opt for the simpler approach of
-     *       having users use synchronized {} blocks on a standard
-     *       lock object.
-     * @return the lock object used for custom graphics of this DNodeView.
-     */
-    public Object customGraphicLock () {
-	return CG_LOCK;
-    }
 
-    private class ReadOnlyIterator<T> implements Iterator<T> {
-	private Iterator<? extends T> _iterator;
-	public ReadOnlyIterator (Iterable<T> toIterate) {
-	    _iterator = toIterate.iterator();
-	}
-	public boolean hasNext() {return _iterator.hasNext();}
-	public T next() 	 {return _iterator.next();}
-	public void remove() {
-	    throw new UnsupportedOperationException();
-	}
-    };
-
-
 	/**
-	 * Adds a custom graphic object at specified index.  The index of an object
-	 * is only important in that objects with lower index are rendered before
-	 * objects with higher index; if objects overlap, this order may be important
-	 * to consider.  A custom graphic object consists of the specified shape
-	 * that is filled with the specified paint; the shape is placed relative to
-	 * this node's location.
-	 * @deprecated use {@link #addCustomGraphic(Shape,Paint,byte) addCustomGraphic(Shape,Paint,byte)}.
-	 * <P>The entire index-based custom graphic API has been deprecated.
-	 * This includes all the methods that refer to custom graphics using indices:
-	 * <PRE>
-	 *   public int addCustomGraphic(Shape s, Paint p, int index);
-	 *   public void removeCustomGraphic(int index);
-	 *   public Paint getCustomGraphicPaint(int index);
-	 *   public Shape getCustomGraphicShape(int index);
-	 *   public int getCustomGraphicCount();
-	 * </PRE>
-	 * <B>To keep things completetly backwards compatible
-	 * and to avoid introducing bugs, the new API methods are
-	 * completely independent from the the old API methods.  Thus,
-	 * a custom graphic added using the new API will not be
-	 * accessible from the old API and visa versa.</B>
-	 * <P>The reason for the deprecation is:
-	 * <OL>
-	 * <LI>Complexity in managing the indices.
-	 * <P>In order for multiple plugins to use the old API, each
-	 * must monitor deletions to custom graphics and update their
-	 * saved indices, since the indices will shift down as graphics
-	 * are deleted. This management isn't even possible with the old
-	 * API because there's no event mechanism to inform plugins when
-	 * the indices change. Also, each plugin must keep a list of all
-	 * indices for all graphics added, since the indices may not be
-	 * contiguous.
-	 * <LI>There is no way to ensure that an index you want to use
-	 * will not be used by another plugin by the time you attempt
-	 * to assign it (thread safety).
-	 * <P>Using indices forces the need for a locking mechanism to
-	 * ensure you are guaranteed a unique and correct index
-	 * independent of any other plugins.
-	 * </OL>
-	 * For more information, see <A HREF="http://cbio.mskcc.org/cytoscape/bugs/view.php?id=1500">Mantis Bug 1500</A>.
-	 */
-
-    @Deprecated public void addCustomGraphic(Shape s, Paint p, int index) {
-		if ((s == null) || (p == null))
-			throw new NullPointerException("shape and paint must be non-null");
-
-		synchronized (m_view.m_lock) {
-			if (index < 0)
-				index = 0;
-			else if (index > getCustomGraphicCount())
-				index = getCustomGraphicCount();
-
-			if (m_graphicShapes == null) {
-				m_graphicShapes = new ArrayList<Shape>();
-				m_graphicPaints = new ArrayList<Paint>();
-			}
-
-			m_graphicShapes.add(index, s);
-			m_graphicPaints.add(index, p);
-			m_view.m_contentChanged = true;
-		}
-	}
-
-	/**
 	 *  DOCUMENT ME!
 	 *
 	 * @param position DOCUMENT ME!
Index: view/src/main/java/org/cytoscape/view/DiscreteVisualProperty.java
===================================================================
--- view/src/main/java/org/cytoscape/view/DiscreteVisualProperty.java	(.../trunk)	(revision 0)
+++ view/src/main/java/org/cytoscape/view/DiscreteVisualProperty.java	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -0,0 +1,121 @@
+package org.cytoscape.view;
+
+import java.awt.Stroke;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Properties;
+
+import javax.swing.Icon;
+
+import org.cytoscape.view.renderers.NodeRenderer;
+
+/** A Visual Property that has a finite site of discrete values.
+ * The set of values is dynamically extendible via OSGi 
+ */
+public class DiscreteVisualProperty implements VisualProperty {
+	private String name;
+	private Class dataType = DiscreteValue.class; // Data type
+	private Class underlyingDataType; // Data type of the values
+	private boolean isNodeProp; // indicates whether or not property is for a node or edge
+	private Object [] values;
+	private Map<Object, Icon> icons;
+	private DependentVisualPropertyCallback callback;
+	
+	// note: default value is the first one; number of values and icons must match
+	public DiscreteVisualProperty(final String name, final Class dataType, final boolean isNodeProp, Object [] values, Map<Object, Icon>icons) {
+		this(name, dataType, isNodeProp, values, icons, null);
+	}
+	public DiscreteVisualProperty(final String name, final Class dataType, final boolean isNodeProp, Object [] values, Map<Object, Icon>icons,
+			DependentVisualPropertyCallback callback) {
+		this.underlyingDataType = dataType;
+		this.isNodeProp = isNodeProp;
+		this.name = name;
+		this.values = values;
+		this.icons = icons;
+		this.callback = callback;
+	}
+
+	public void applyToEdgeView(EdgeView ev, Object o) {
+		// FIXME FIXME FIXME: this will be replaced with a simple "ev.setVisualAttribute(o)" -- infact, such a method isn't even needed in VisualProperty
+		// the following is only needed until we refactor the ViewModel layer & rendering
+		if ((o == null) || (ev == null)){
+			return;
+		} else if (name.equals("EDGE_LINE_STYLE")){
+			if (((Stroke) o) != ev.getStroke() )
+				ev.setStroke((Stroke) o);
+		} else if (name.equals("EDGE_SRCARROW_SHAPE")){
+			final int newSourceEnd = ((Integer) o).intValue();
+			if (newSourceEnd != ev.getSourceEdgeEnd() ) {
+				ev.setSourceEdgeEnd(newSourceEnd);
+			}
+		} else if (name.equals("EDGE_TGTARROW_SHAPE")){
+			final int newTargetEnd = ((Integer) o).intValue();
+			if (newTargetEnd != ev.getTargetEdgeEnd()) {
+				ev.setTargetEdgeEnd(newTargetEnd);
+			}
+		}	
+	}
+
+	public void applyToNodeView(NodeView nv, Object o) {
+		// FIXME FIXME FIXME: this will be replaced with a simple "ev.setVisualAttribute(o)" -- infact, such a method isn't even needed in VisualProperty
+		// the following is only needed until we refactor the ViewModel layer & rendering
+		if ((o == null) || (nv == null)) {
+			return;
+		} else if (name.equals("NODE_SHAPE")){
+			final int newShape = ((Integer) o).intValue();
+			
+			if (nv.getShape() != newShape)
+				nv.setShape(newShape);
+		} else if (name.equals("NODE_RENDERER")){
+			NodeRenderer newRenderer = (NodeRenderer) o;
+			if (nv.getRenderer() != newRenderer)
+				nv.setRenderer(newRenderer);
+		} 
+	}
+
+	public Class getDataType() {
+		return dataType;
+	}
+
+	public Object getDefaultAppearanceObject() {
+		if (values.length > 0)
+			return values[0];
+		else
+			return null;
+	}
+
+	public Icon getDefaultIcon() {
+		if (values.length > 0)
+			return icons.get(values[0]);
+		else
+			return null;
+	}
+
+	public Icon getIcon(Object value) {
+		return icons.get(value);
+	}
+
+	public Map<Object, Icon> getIconSet() {
+		//return icons; //FIXME: shouldn't this work?
+		return new HashMap<Object, Icon>(icons);
+	}
+
+	public String getName() {
+		return name;
+	}
+
+	public boolean isNodeProp() {
+		return isNodeProp;
+	}
+
+	public Object parseProperty(Properties props, String baseKey) {
+		// FIXME FIXME: do IO later 
+		return null;
+	}
+	public Object parseStringValue(String string){
+		return null; // FIXME FIXME FIXME
+	}
+	public DependentVisualPropertyCallback dependentVisualPropertyCallback(){
+		return callback;
+	}
+}
Index: pom.xml
===================================================================
--- pom.xml	(.../trunk)	(revision 14573)
+++ pom.xml	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -1,296 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project
-	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"
-	xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
-	<name>Cytoscape Core</name>
-	<url>http://cytoscape.org</url>
-	<description>A network visualization and analysis application.</description>
-	<organization>
-		<name>Cytoscape</name>
-		<url>http://cytoscape.org</url>
-	</organization>
-	<licenses>
-		<license>
-			<name>GNU Lesser General Public License</name>
-			<url>http://www.gnu.org/licenses/lgpl-3.0.txt</url>
-		</license>
-	</licenses>
-	<issueManagement>
-		<system>Mantis</system>
-		<url>http://cbio.mskcc.org/cytoscape/bugs/main_page.php</url>
-	</issueManagement>
-	<ciManagement>
-		<system>cruisecontrol</system>
-		<url>http://chianti.ucsd.edu/cruisecontrol</url>
-	</ciManagement>
-	<mailingLists>
-		<mailingList>
-			<name>Cytoscape Discuss: A list for users to ask and discuss
-				questions about Cytoscape.</name>
-			<subscribe>http://groups.google.com/group/cytoscape-discuss</subscribe>
-			<unsubscribe>http://groups.google.com/group/cytoscape-discuss</unsubscribe>
-			<post>cytoscape-discuss@googlegroups.com</post>
-			<archive>http://groups.google.com/group/cytoscape-discuss</archive>
-		</mailingList>
-		<mailingList>
-			<name>Cytoscape Helpdesk: A list for users to request help
-				about Cytoscape.</name>
-			<subscribe>http://groups.google.com/group/cytoscape-helpdesk</subscribe>
-			<unsubscribe>http://groups.google.com/group/cytoscape-helpdesk</unsubscribe>
-			<post>cytoscape-helpdesk@googlegroups.com</post>
-			<archive>http://groups.google.com/group/cytoscape-helpdesk</archive>
-		</mailingList>
-		<mailingList>
-			<name>Cytoscape Announce: A low volume list for
-				announcements relevant to Cytoscape users and developers.</name>
-			<subscribe>http://groups.google.com/group/cytoscape-announce</subscribe>
-			<unsubscribe>http://groups.google.com/group/cytoscape-announce</unsubscribe>
-			<post>cytoscape-announce@googlegroups.com</post>
-			<archive>http://groups.google.com/group/cytoscape-announce</archive>
-		</mailingList>
-	</mailingLists>
-	<scm>
-		<connection>scm:svn:http://chianti.ucsd.edu/svn/cytoscape3/trunk</connection>
-		<developerConnection>scm:svn:svn+ssh://grenache.ucsd.edu/cellar/common/svn/cytoscape3/trunki</developerConnection>
-		<url>http://chianti.ucsd.edu/svn/cytoscape3/trunk</url>
-	</scm>
-	<developers>
-		<developer>
-			<id>mes</id>
-			<name>Mike Smoot</name>
-			<email>msmoot ~ ucsd / edu</email>
-			<url>http://chianti.ucsd.edu/~mes</url>
-			<organization>U.C. San Diego</organization>
-			<organizationUrl>http://ucsd.edu</organizationUrl>
-			<roles>
-				<role>Architect</role>
-				<role>Core Developer</role>
-			</roles>
-			<timezone>-8</timezone>
-		</developer>
-		<developer>
-			<id>kono</id>
-			<name>Keiichiro Ono</name>
-			<email>kono at ucsd dot edu</email>
-			<url>http://chianti.ucsd.edu/kono</url>
-			<organization>U.C. San Diego</organization>
-			<timezone>-8</timezone>
-			<roles>
-				<role>Core Developer</role>
-			</roles>
-		</developer>
-	</developers>
-	<modelVersion>4.0.0</modelVersion>
-	<groupId>cytoscape</groupId>
-	<artifactId>core</artifactId>
-	<version>1.0-SNAPSHOT</version>
-	<properties>
-    <!--
-     | some example OSGi runtime properties
-    -->
-		<org.osgi.service.http.port>8080</org.osgi.service.http.port>
-		<org.osgi.service.http.port.secure>8443</org.osgi.service.http.port.secure>
-	</properties>
-	<packaging>pom</packaging>
-	<repositories>
-    <!-- for biojava -->
-		<repository>
-			<id>wwmm</id>
-			<snapshots>
-				<enabled>false</enabled>
-			</snapshots>
-			<name>Murray-Rust Research Group</name>
-			<url>http://wwmm.ch.cam.ac.uk/maven2</url>
-		</repository>
-    	<!-- for jars I can't find anywhere else -->
-		<repository>
-			<id>chianti</id>
-			<snapshots>
-				<enabled>false</enabled>
-			</snapshots>
-			<name>Cytoscape Internal Repository</name>
-			<url>http://chianti.ucsd.edu/maven2</url>
-		</repository>
-    	<!-- for freehep jars -->
-		<repository>
-			<id>freehep-maven</id>
-			<name>Maven FreeHEP</name>
-			<url>http://java.freehep.org/maven2</url>
-		</repository>
-		<!-- SpringSource OSGi Bundle Repository -->
-		<repository>
-			<id>com.springsource.repository.bundles.release</id>
-			<name>SpringSource OSGi Bundle Repository</name>
-			<url>http://repository.springsource.com/maven/bundles/release</url>
-			<snapshots>
-				<enabled>false</enabled>
-			</snapshots>
-		</repository>
-		<repository>
-			<id>com.springsource.repository.bundles.external</id>
-			<name>SpringSource OSGi Bundle Repository</name>
-			<url>http://repository.springsource.com/maven/bundles/external</url>
-			<snapshots>
-				<enabled>false</enabled>
-			</snapshots>
-		</repository>
-	</repositories>
-	<build>
-		<plugins>
-			<plugin>
-				<groupId>org.apache.maven.plugins</groupId>
-				<artifactId>maven-surefire-plugin</artifactId>
-				<configuration>
-					<redirectTestOutputToFile>true</redirectTestOutputToFile>
-				</configuration>
-			</plugin>
-			<plugin>
-				<groupId>org.ops4j</groupId>
-				<artifactId>maven-pax-plugin</artifactId>
-				<configuration>
-          <!--  some example Pax-Runner settings -->
-					<provision>
-						<param>--platform=felix</param>
-						<param>--profiles=minimal</param>
-						<param>--vmOptions=-Xbootclasspath/a:bundles/com.jgoodies.looks_2.1.2.jar:bundles/cytoscape-sun.jhall_1.0.0.jar</param>
-					</provision>
-				</configuration>
-				<!--
-					executions> <execution> <id>ide-support</id> <phase>package</phase>
-					<goals> <goal>eclipse</goal> </goals> </execution> </executions
-				-->
-			</plugin>
-			<!--
-				<plugin> <artifactId>maven-assembly-plugin</artifactId>
-				<configuration> <descriptors> <descriptor>assembly.xml</descriptor>
-				</descriptors> </configuration> </plugin>
-			-->
-			<plugin>
-				<groupId>org.apache.maven.plugins</groupId>
-				<artifactId>maven-compiler-plugin</artifactId>
-				<configuration>
-					<source>1.5</source>
-					<target>1.5</target>
-					<showWarnings>true</showWarnings>
-					<showDeprecation>true</showDeprecation>
-					<!--
-						compilerArguments> <Xlint:all></Xlint:all>
-						<Xlint:-path></Xlint:-path> <Xmaxwarns>10000</Xmaxwarns>
-						<Xmaxerrs>10000</Xmaxerrs> </compilerArguments
-					-->
-				</configuration>
-			</plugin>
-		</plugins>
-	</build>
-	<reporting>
-		<plugins>
-			<plugin>
-				<groupId>org.codehaus.mojo</groupId>
-				<artifactId>taglist-maven-plugin</artifactId>
-				<version>2.2</version>
-				<configuration>
-					<tags>
-						<tag>TODO</tag>
-						<tag>FIXME</tag>
-						<tag>@todo</tag>
-						<tag>@deprecated</tag>
-						<tag>DOCUMENT ME</tag>
-					</tags>
-				</configuration>
-			</plugin>
-			<plugin>
-				<groupId>org.apache.maven.plugins</groupId>
-				<artifactId>maven-pmd-plugin</artifactId>
-				<configuration>
-					<linkXref>true</linkXref>
-					<sourceEncoding>utf-8</sourceEncoding>
-					<minimumTokens>100</minimumTokens>
-					<targetJdk>1.5</targetJdk>
-					<excludes>
-						<exclude>**/*Bean.java</exclude>
-						<exclude>**/generated/*.java</exclude>
-					</excludes>
-				</configuration>
-			</plugin>
-			<plugin>
-				<groupId>org.codehaus.mojo</groupId>
-				<artifactId>cobertura-maven-plugin</artifactId>
-			</plugin>
-			<plugin>
-				<groupId>org.codehaus.mojo</groupId>
-				<artifactId>findbugs-maven-plugin</artifactId>
-				<configuration>
-					<threshold>Normal</threshold>
-				</configuration>
-			</plugin>
-			<plugin>
-				<groupId>org.codehaus.mojo</groupId>
-				<artifactId>jdepend-maven-plugin</artifactId>
-			</plugin>
-			<plugin>
-				<artifactId>maven-javadoc-plugin</artifactId>
-				<configuration>
-					<excludePackageNames>*.impl</excludePackageNames>
-				</configuration>
-				<reportSets>
-					<reportSet>
-						<reports>
-							<report>javadoc</report>
-              <!-- <report>test-javadoc</report> -->
-						</reports>
-					</reportSet>
-				</reportSets>
-			</plugin>
-			<plugin>
-				<groupId>org.codehaus.mojo</groupId>
-				<artifactId>jxr-maven-plugin</artifactId>
-			</plugin>
-			<plugin>
-				<groupId>org.apache.maven.plugins</groupId>
-				<artifactId>maven-surefire-report-plugin</artifactId>
-			</plugin>
-		</plugins>
-	</reporting>
-	<modules>
-		<module>poms</module>
-		<module>provision</module>
-		<module>util.intr</module>
-		<module>graph.fixed</module>
-		<module>graph.dynamic</module>
-		<module>network</module>
-		<module>render.immed</module>
-		<module>geom.spacial</module>
-		<module>render.stateful</module>
-		<module>geom.rtree</module>
-		<module>render.export</module>
-		<module>attributes</module>
-		<module>tunable</module>
-		<module>task</module>
-		<module>view</module>
-		<module>undo</module>
-		<module>phoebe.dnd</module>
-		<module>automatic.layout</module>
-		<module>layout</module>
-		<module>wrappers</module>
-		<module>vizmap</module>
-		<module>commons.cli</module>
-		<module>application</module>
-		<module>cpath</module>
-		<module>merge</module>
-		<module>math.xform</module>
-		<module>psi.mi</module>
-		<module>biopax</module>
-		<module>editor</module>
-		<module>linkout</module>
-		<module>attribute.browser</module>
-		<module>cpath2</module>
-		<module>filters.old</module>
-		<module>filters</module>
-		<module>sbml.reader</module>
-		<module>manual.layout</module>
-		<module>quickfind</module>
-		<module>table.import</module>
-    <!--
-	-->
-	</modules>
-</project>
\ No newline at end of file
Index: depends2sif.pl
===================================================================
--- depends2sif.pl	(.../trunk)	(revision 14573)
+++ depends2sif.pl	(.../branches/abeld-gsoc/dev/pluggable-renderers)	(revision 14700)
@@ -1,37 +0,0 @@
-#!/usr/bin/perl
-
-$everything = 0;
-if ( $ARGV[0] eq "-everything" ) {
-	$everything = 1;
-}
-
-$currentModule = "";
-$record = 0;
-
-open COM, "mvn dependency:list -DexcludeTransitive|" or die "couldn't execute mvn dependency:list\n";
-while (<COM>) {
-
-	if ( $_ =~ /Building\s+(\S+)\s+/ ) {
-		$currentModule = $1;
-		$record = 0;
-	} elsif ( $currentModule ne "" &&
-	          $_ =~ /The following files have been resolved/ ) {
-		$record = 1; 
-    } elsif ( $record == 1 &&
-	          $_ =~ /\s+(\S+)\:(\S+)\:\S+\:\S+\:(\S+)/ ) {
-		$org = $1;
-		$depModule = $2;
-		$phase = $3;
-		if ( $phase eq "compile" ) {
-			if ( $everything == 1 ) {
-				print "$currentModule	dependsOn	$depModule\n";
-			} else {
-				if ( $org =~ /cytoscape/ ) {
-					print "$currentModule	dependsOn	$depModule\n";
-				}
-			}
-		}
-	}
-}
-
-close COM;
